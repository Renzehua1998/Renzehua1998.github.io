[{"title":"【复杂网络】高级操作","date":"2023-02-04T04:00:00.000Z","path":"2023/02/04/图与复杂网络-4高级操作/","text":"菲尔兹数学科学研究所 复杂网络2019夏令营课程 学习笔记 高级操作 图嵌入（Graph Embedding） 图半监督学习（SSL） 超图 图嵌入 Graph Embedding，也叫图表示学习(Network Representation Learning) 图嵌入的快速概述 一些算法：node2vec、LINE、Verse 比较嵌入算法的框架 示例 概述 目标： 将网络（节点）映射到向量（特征）空间 将相似节点映射到向量空间中的附近位置。“相似”可能有不同含义： 图拓扑上较近 图中相似的角色（例如：度相似） 相似的节点属性 应用实例： 特征学习（不是特征工程） 可视化 链接预测 社区检测 异常检测 网络演化（动力学） 形式化描述： 输入：G = (V , E) 输出：特征向量 算法 ——大部分算法基于随机游走和 用于词嵌入的 SkipGram 方法 词的语义由其上下文决定(A word can be characterized by the company it keeps) 相似上下文中的词（相近的词）具有相似的含义 考虑每个单词周围的窗口；构建“词向量”（例如：word2vec） 使用这些作为训练数据 SkipGram： 使用滑动窗口邻域对每个词上下文的相关词进行组合，构建“词向量” DeepWalk（深度游走）： 单词——对应于节点 句子——对应于图 G 上的随机游走 句子中的词频呈现幂律分布——游走中的顶点也呈现幂律分布 node2vec： 定义了有偏随机游走（biased random walks）混合了广度和深度优先搜索 关键参数： p：控制重新访问同一节点的概率（留在附近） q：控制探索更远的概率 概率选择 参数允许在以下之间进行权衡： 低 p：在本地探索；这将侧重于图形拓扑结构中的社区结构（同质性）； 低q：探索更远；这允许捕获节点之间的一些结构相似性（例如：集线器hubs，网桥bridges）； 其他算法： 统计表见课件 在我们的测试中使用了： node2vec：q=1，p各不相同 VERSE：来自相似性度量（具有个性化page rank）的多功能图嵌入算法：使用默认参数 LINE：Large-scale Information Network Embedding（大规模信息网络嵌入），它使用邻接矩阵的近似分解来尝试保留一阶和二阶邻近度 比较框架 我应该使用哪种嵌入算法？ 如何选择参数？ 我怎么知道这种嵌入算法对图的表示就好？ GIGO：向量空间中的错误表示会导致错误的结果...... 算法之间的结果可能会有很大差异，并且随着参数的选择也会有很大不同 核心：使用嵌入后的向量构建同分布随机图，比较随机图和原图的JS散度，若很小，说明相近，进而说明嵌入效果良好 概述 框架模型： 给定具有度分布 的 n 个顶点上图 G = (V , E) 及其顶点到 k 维空间的嵌入，。 我们的目标是为这个嵌入分配一个“分歧分数”(divergence score)。 分数越低，嵌入越好。这将使我们能够在不同的维度上比较多个嵌入的结果 总述： 非随机图表现出类似社区的结构，所以我们一般： 将节点分组为集群 测量簇之间和簇内的边缘密度 通过 计算散度分数 将其与嵌入（矢量）空间中空间模型的预测密度进行比较 选择得分最高的嵌入 我们的框架中有两个主要部分： 图拓扑视图：一个好的、稳定的图聚类算法；我们默认使用 ECG，但我们也尝试使用 Louvain 和 InfoMap 空间视图：我们引入了基于度分布 w 和嵌入 ε 的几何 Chung-Lu (GCL) 模型。 几何Chung-Lu(GCL) 模型 Chung-Lu 模型：（引子） 在原始的 Chung-Lu 模型中，每个集合 被独立采样为边，概率为： 它产生的分布保留了每个顶点的预期度数 几何Chung-Lu(GCL) 模型： 考虑预期的度分布： 以及节点 的嵌入，以便我们知道所有距离： 模型应该满足 ，g为递减函数，因此长边的出现频率应该低于短边 我们使用以下归一化函数 ： 其中 是一个定值： ——我们使用裁剪（clipping）来强制 和/或 当 α = 0 时，此模型退化为原始的 Chung-Lu 模型，忽略了节点对的距离 参数 α 越大，对长边的厌恶越大 因此，模型的唯一参数是 α ∈ [0, ∞) 在实践中，我们会尝试一系列值并保持最佳拟合。 GCL模型是基于顶点集 上的随机图 其中 vi, vj, 形成一条边的概率为： 权重选择： 顶点vi的度期望为： 定理：当 G 中的最大度数小于所有其他顶点的度数之和时，仅有唯一的权重选择。 ——由于 G 的每个连通分量都可以独立嵌入，我们可以假设 G 是连通的，因此 G 的最小度数至少为 1。因此，除非 G 是 n 个顶点上的星形，否则这个非常温和的条件是平凡的。 我们要做的，就是通过选择权重，使得度分布期望等于原图度分布。 解GCL模型 我们使用一个简单的数值近似程序 从任意向量开始 给定 ，如果我们以如下概率在 vi 和 vj 之间引入一条边： 那么 vi 的度期望将是：（这对应于上小节度期望） 通过用 替换 来调整权重，使 与 匹配 这也会影响 的其他值，并且 其他部分的变化也会影响 自身。 因此，我们让每个顶点向正确的方向迈出一小步 这个过程很快收敛到理想状态：对于所有 i， 都非常接近 。 迭代步骤： 对于每个 i，1 ≤ i ≤ n，我们定义 重复调整过程直到 定义 ε = 0.1 、 δ = 0.001 分歧分数算法 计算嵌入分歧分数（embedding divergence score）的算法 给定 G = (V, E)，它在 V 上的度分布 w，以及它的顶点的嵌入，我们将执行接下来详述的五个步骤 通过算法，我们获得 ，嵌入的分歧分数 我们可以应用这个算法来比较几个嵌入算法的分歧分数指标，选出最好的（最小的）那个 第一步： 在 G 上运行一些稳定的图聚类算法以获得顶点集 V 的分区 ，一共产生 个社区 。 此教程中使用ECG，其实任何稳定的算法都可以。 第二步： 令： ：两个端点都在 中的边的比例 ：一个端点在 中且另一个端点在 中的边的比例 定义： ——这些向量从 图 G 的角度表征分区 C，嵌入 不影响 和 ——接下来我们在 α 的一系列值上重复步骤 3-4 第三步： 给定 ，使用的GCL 模型。 从这个模型，我们计算： ： 内边的比例期望 ： 中一个端点和 中另一个端点的边的比例期望 定义： ——这些向量从 嵌入 的角度表征分区 C 第四步： 计算 和 之间的距离，以及 和 之间的距离 我们使用 Jensen-Shannon 散度 (JSD)： ——这是给定 α 的（分歧）分数。 第五步： 从重复的步骤 3-4，我们获得了一系列 选择 将分歧分数定义为： 总结： 为了比较同一个图 G 的多个嵌入，我们重复上面的步骤 3-5 并比较分歧分数（分数越低越好）。 步骤 1-2 只执行一次，因此我们对每个嵌入使用相同的图划分算法到 个社区 示例 空手道俱乐部：找到最适合嵌入的α值 足球比赛：使用分歧分数选择最合适的嵌入算法 LFR 数据集：使用此方法选出的最好和最坏embedding算法效果 关系数据上的半监督学习 简介（转导学习） 我们使用一种转导学习（transductive learning）的方法: 没有显式地构造任何模型 学习是“基于数据”的 在图上使用正则化框架，正则化包含以下两种情况： 局部结构：与稀缺标记顶点一致 全局结构：所有顶点的平滑 形式化描述： 设， 设函数 ，同时定义两个函数的内积： 我们定义一个函数 满足： 是一个依赖于G的泛函：平滑泛函 ——取决于图的类型：无向、有向、联合链接(两者都有) 编码先验知识(顶点标签) ——取决于要解决的问题： 二进制分类： 排序： 无监督： :平滑度(smoothness)和一致性(consistency)之间的权衡 应用-示例 给出一个包含一些“有趣”实体的大型图 求解以放大附近的顶点 最终可以： 获得未知实体的排名 能可视化关键子图 网络安全环境中的几个应用 异常检测 恶意软件检测 图和超图通常太大，不适合直接分析或可视化 无向图 图模型： 设无向图为 是所有 的边权 的矩阵。 设D为节点度的对角线矩阵： 无监督N-cut问题：（回顾） 对于一个分割 其中： 这可以被视为具有转移概率 的随机游走： 这个问题可以通过松弛实值来解决 其中 且： 是(归一化)图拉普拉斯矩阵 ——这被称为归一化谱聚类（normalized spectral clustering） 半监督问题： 概述： 拉普拉斯矩阵也出现在半监督问题中： 如果节点接近(很大)，那么它们应该有相似的标签()，以保持较小 在整个图上，这相当于保持较小 这可以看作是找到一个“平滑”函数f，它在图的密集区域中变化很小，但在稀疏区域中变化更大。 形式化描述： 现在假设顶点上有一些初始(种子)值y： 将半监督问题定义为关于图拓扑的“平滑性”和关于y的一致性之间的权衡，例如: 令 , 则有： 若 , 且 ,存在一个封闭式解： 其中: , 归一化图拉普拉斯矩阵 , 平滑矩阵 求解： 可通过多种方式获得： 迭代方法: 从开始， 迭代， 它可以写成一个 对角占优 的线性问题，其反演技术存在，且复杂度为，其中m为非零项的个数 通过共轭梯度法 map-reduce框架具有良好的可伸缩性 其他图 有向图 形式化描述： 定义进出节点度： . 上的然随机游走的转换概率为： 设 为唯一平稳分布，即： 这需要定义一个传送随机游走（teleporting random walk）——用于描述随机游走的概率 考虑泛函： 正则化问题和之前一样 其中 是转移概率的矩阵， 平稳概率的对角矩阵。（和无向图的差别在平滑矩阵S上） 和之前一样: . ——这是对无向情况的推广。对于无向图，随机游走的概率是固定的： ——此时平滑矩阵退化为无向图情况： 枢纽/权威型网络 Hubs&amp;Authorities graphs 概述： 考虑顶点的两种可能角色: 具有高“入度”的权威(authority) 具有高“出度”的枢纽(hub) 对于有向图， u是“枢纽”，v是“权威” 平滑矩阵： 权威型： 定义节点 和 相对于节点 的权威距离为： 由此我们建立了平滑矩阵： 枢纽型 我们同样定义相对于节点 的枢纽距离为： 平滑矩阵： 求解模型： 令 ，其中 , 我们可以得到： 对于枢纽型我们可以类似地得到 . 令： 我们可以像以前一样解决正则化问题：（带入平滑矩阵求解即可） 对于一个无向图： . 混合图 我们可以将平滑泛函推广为 其中 基于随机游走， 是“枢纽&amp;权威”平滑 这允许3种衡量顶点“接近”的方式： 存在一条短路径 指向几个公共顶点 由几个公共顶点指向 ——2和3对于无向图是一样的 超图 模型 符号说明： 对于(无向)超图，定义: ：超边集合——超边为节点子集 ：超边权值 ：节点度 ：“超边度” 关联矩阵 权重矩阵， 节点度矩阵， 超边度矩阵。 Ncut问题可以推广到超图： 超图体积 对于一个分割 ，令： ——对于最后一个表达式，如果e被映射到分割的两端，分子是将被切割的“边”的数量。（就是转为普通图以后的割边数） 可以再次通过随机游走来说明: 通过定义节点转移的平稳分布 得到以下结果： 超图拉普拉斯矩阵 解松弛后的问题得到与用图相同的形式，但是有 当所有 时，有: 也就是拉普拉斯矩阵的一半，因此可以定义为超图拉普拉斯矩阵 问题定义 我们定义了与图相同的半监督问题: 其中: 以上问题的解又下式给出： 随机游走模型1 从顶点u，随机选取 的超边e 随机选取一个顶点 ，然后跳转到v 我们可以将上面的超图视为一个加权邻接矩阵为 的普通图，其中： 行和为： 如果所有 , 我们有 而对于 我们有 , 所以 其中A是这个超图的图表示的(加权)邻接矩阵 因此，对于此随机游走模型，将G视为图和将G视作超图，转导学习问题的解将有所不同 ——需要进一步改进 随机游走模型2（改进） 我们定义一个新的随机游走如下: 从顶点u，随机选取 的超边e 随机选取一个顶点, ，然后跳转到v 我们可以将上面的图视为一个加权邻接矩阵为 的普通图，其中： 行和为： 邻接矩阵表达式为: 其中 是对角阵，其元素为： . 在这种情况下，调整后的超图Laplacian矩阵采用以下形式: 如果所有，我们得到，其中A是这个超图的 图表示 的(加权)邻接矩阵 有向超图的情况 我们可以推广到有向超图，其中: 表示每个超边缘的尾部(tail)和头部(head) 向多个收件人发送电子邮件是有向超边的一个例子 分类数据（应用） 超图可以用来对分类数据建模 示例：“蘑菇数据集”(UCI ML存储库): 22个分类属性，23个物种的8124个观察值 目标：二分类——可食用或可能不可食用 每个分类属性建模为一个超边 “帽形=钟形” “帽形=圆锥形” 学生作业： 用Python编写超图转导学习代码 在分类数据上验证已发表的结果——与图模型进行比较 研究权衡参数α的影响 提出并探索顶点嵌入框架 说明： 转导学习 颜色代表蘑菇的分类：能不能吃 参数α对结果值的量级有较大影响 排序结果基本相同 嵌入 顶点嵌入是一个热门话题 尝试从不同初始值运行TL（转导学习）过程 生成多维顶点表示 和随机游走类似 超图模块度和聚类 普通图聚类：模块度和Chung-Lu模型 超图的模块度 超图Chung-Lu模型 严格超图模块度 其他超图模块度 超图聚类 普通图聚类（回顾） 模块度： 我们可以把图G的划分 的模块度写成: 叫做边贡献（edge contribution）——社区内的边相连的数量 叫做度税（degree tax）——社区节点相关的边在随机图的数量 Chung-Lu模型： 只需要的时间复杂度，更常用 在顶点V中选择条边， 根据多项式分布从V独立采样： 边可以重复，所以我们得到的是预期的边数而不是概率 我们将定义为使用模型2获得的图的分布： 其中图为获得的新随机图： 新图的度期望为： 我们总是有 允许存在多条边 也允许有自环 ——引理：图G的模块度函数中的 度税 是图 上 边贡献 的期望值。 我们能把这个模型推广到超图吗? 超图模块度 超图表示 背景： 存在比图更复杂的关联关系——涉及多个实体 传统图经常以两两之间的关系表示——丢失信息 超图： 超图 其中， 超边 其中， 边可以有权重 我们考虑无向超图 超图 ——有些数据更适合用超图建模：电子邮件交换、跟踪主机代管、分类数据建模、数值线性代数 然而在实际操作中： 数据科学中，很少有基于超图的算法 它们通常比较慢 有些有等效的普通图表示 ——问题：我们能在超图上定义模块度函数吗？ 超图Chung-Lu模型 符号说明： 考虑一个超图 其中节点为： .、 超边 是节点数大于1的节点集合 的子集: 中顶点 的多重性（权值） 是超边 的大小 , 是节点的度 是节点集合的体积 生成概率： 设 是大小为 的节点集的集合，即： 随机模型中的超图是通过独立随机实验生成的。 对于每个 使 ， 产生 的概率为： 其中 . 度期望： ——我们使用Chung-Lu模型的这种泛化（超图Chung-Lu）作为零模型(度税)来定义超图模块度 超图模块度 设， ，，是V的一个分区方案。对于尺寸大于2的边，可以使用几个定义来量化给定A的边贡献，例如: 一条边的所有顶点都必须属于其中一个社区——这是一个严格的定义 一条边的大多数顶点属于其中的一个社区 一条边的至少2个顶点属于同一社区——当我们用超图的2段图表示代替超图时，隐式地使用了这种方法 严格超图模块度： 的边贡献为： 在 上的严格模块度定义为标准模块度的自然延伸，如下所示： 也可以写成： 和超图Chung-Lu模型的关系： 我们将Chung-Lu模型II推广到超图上： 对于每个d，选取 个边 ，，，其中每个 独立地从V中采样，且 我们将定义为使用上述模型获得的超图的分布： 其中超图为获得的新随机图： 新超图的度期望为： 我们总是有 允许存在多条边 在一条边内可以有重复的顶点 ——引理：超图 的模块度函数中的 度税 是超图 上 边贡献 的期望值。 其他超图模块度： 我们可以根据边贡献的许多自然定义来调整度税，例如多数定义 在这种情况下 改成了只要大于边内节点数的一半即可 ——这相当于 变成了 超图划分的多数模块度函数为： 将H分解为d-uniform 超图，得到如下的度无关模块度函数： 这和以前一样，但是对于每个的d，将通过计算的体积替换为通过计算的体积 最后，我们可以推广模块化函数，以允许加权超边 超图聚类 概述 我们在超图上寻求一个划分 , 使严格超图模块度 最大化. 集合 对于节点集 的所有划分来说是巨大的. 令 并定义： 这个函数将 的一个子超图映射到其连通分量在 上划分的函数. 我们定义一个等价关系： 并定义一个商集 . 商集（quotient set）是集合论的基本概念之一，指由集合和该集合上的等价关系导出的集合。设～是非空集合A的一个等价关系，若把以A关于～的全部等价类作为元素组成一个新的集合B，则把集合B叫做A关于～的商集合，简称为商集，记作B=A/～. 定义规范表示映射： 它将等价类映射到类中最大的成员: . 设 是 在正则表达式 上的像（也就是输入 输出的值域区间）. 我们将证明最优解在 中，它是一个子集，规模最大为 . 示例 上述5节点的超图，对其进行划分， 共有B5 = 52种可能 而 只有7种，远小于52中——缩小了搜索范围 证明 引理1：设 为超图， 是 的分区. 如果存在 使得 , 则 的边贡献为 , 其中 是 的典型代表 的边集。——即部分子集超边的比例。 引理2：设 是一个超图， 是 的任意划分。如果 是 的细化， 的度税小于等于 的度税，当且仅当 时取等号。 ——我们证明了对任意分区，存在某个 使得 是该分区的一个细化，且具有相同的边贡献。 定理：设 为超图， 如果 使模块度函数 最大化，则 算法 前面的结果给出了定义启发式算法的步骤: 循环遍历 ，令 找到 并计算 的边贡献 找到 并计算 的度税 在 中寻找合适组合的简单方法: 贪婪随机: 把超边随机重新排列，当 增加时，将其按顺序添加到 ; 重复这一操作; 类CNM: 在每一步中寻找添加到 的最佳边。 Hypergraph-CNM算法： 数据输入: 超图 结果输出: , 针对模块度函数 对 的一个划分 初始化 ： 每个节点独自为一个社区，计算对应的模块度 ; repeat foreach do 设置 end foreach 接触到 中两个或更多的部分 do 计算新分区 ：将原始 中被 接触到的分区合并得到的分区; 计算新分区对应的模块度函数 ; end 选择具有最大模块度函数值 的 ; if then ， ; end until ; 输出: 和 实验 ——好用吗？得到的模块度是最大模块度吗？ 小demo： 建立超图，有3个社区，20个顶点，50条边，大小为2≤d≤5 添加3≤k≤60条相同大小的随机边 在k值范围内多次运行随机算法(重复25次) 对于每个k，计算平均调整兰德指数; ——结果：随着添加随机边的增加，聚类结果逐渐变差，但在随机边数小于30时，聚类效果还是OK的 合成超图： 在不同坡度的平面上沿3条线生成噪声点 添加一些随机点 选择3或4个点的集合(超边) 都来自同一条线(“信号”) 不来自同一条线(“噪声”) 采样超边，其中点对齐良好，因此预期的信号与噪声的比例为2:1 我们考虑3种不同的情况：(i)主要是3-边，(ii)主要是4-边，(iii)在3和4-边之间平衡。 在(加权)普通图上通过鲁汶聚类顶点。——我们观察到相比于普通图模块度，Hcut（不相交超边的数量）和超图模块度相关性更高 DBLP超图： ——引文网络 小型合著者超图，有1637个节点和865个大小为2到7的超边。 我们比较了鲁汶(超过2-section)和超图-cnm(严格模块化)两种算法 ——与Louvain算法相比，基于超图模块度 的算法倾向于切割更少的大边，代价是切割更多的2节点边 总结： 已有工作： 超图的广义Chung-Lu模型 超图的广义模块度函数 超图聚类算法的步骤 两种简单的启发式算法：贪婪随机和超图CNM 未来工作： 更直观地理解模块化函数 更好的、可伸缩的聚类算法 真实数据集实验","tags":[{"name":"图与网络","slug":"图与网络","permalink":"https://renzehua1998.github.io/tags/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/"}]},{"title":"【复杂网络】社区结构","date":"2023-02-03T04:00:00.000Z","path":"2023/02/03/图与复杂网络-3社区结构/","text":"菲尔兹数学科学研究所 复杂网络2019夏令营课程 学习笔记 社区结构 图划分（graph partitions）算法比较 图聚类算法 图上的集成聚类（ECG） 图社区 定义 谱分割 Girvan-Newman聚类 基准：种植分区，LFR 模块度 算法 定义 两个基本假设：[Barabasi,Network Science] 一个网络的社区结构在其布局图中是唯一的。 一个社区是网络中的一个局部密集连接子图。 模型： 对于一个图，考虑由一个节点的子集诱导的连接子图C（C中的节点满足）。 内部外部度： 定义节点的内部度（其在子图C内的度）： 节点i的外部度是： 其中是节点i在G中的总度 强弱社区： 如果对每个节点 ， ，则C是一个强社区（strong community） 如果对每个节点 ， ，则C是一个弱社区（weak community） 集团和核： 集团（clique）是G的一个完全连接的子图。 k核（k-core）是G的一个最大连接子图，其中所有节点的度数至少为k 我们可以通过反复删除所有度数小于k的节点来找到k-cores 如果一个节点属于k-core但不属于(k+1)-core，那么这个节点的核心度（coreness）为k 簇（聚类）： 大小为k的图的聚类（clustering）是一个节点的分区，其中： 所有 对于每个部分（或集群），其诱导子图是连通的 谱聚类 谱聚类（Spectral clustering）是一个庞大的话题，本课程只介绍明谱分割（spectral bisection） 参考： https://blog.csdn.net/weixin_45591044/article/details/122747024 https://blog.csdn.net/SL_World/article/details/104423536 模型： 考虑未加权的无向图，邻接矩阵为A D是节点度组成的对角矩阵 是G的（未归一化的）拉普拉斯系数矩阵 G中的社群结构与L的特征分解之间关系紧密 对于所有的： 因此，当时，使上述表达式最小化相当于使 求解： 考虑比率切分法 ratio-cut ： 与之对应的还有normalized-cut（将拉普拉斯矩阵归一化） 这可以近似求解为： 其中，结果是对应于L的第二个最小特征值的特征向量——结论推导见参考博客 讨论： L是对称的和半正定的，所以所有的特征值都是实数和非负数。 L有最小的特征值0；这个特征值的倍数对应于G中连接组件的数量。 因此，我们可以对这些特征值进行排序，同时对它们各自的特征向量进行排序。 非连通图情况： 有至少两个0特征值 按照第二小特征值对应的特征向量，有0和非0两种情况，按这个分类即可。 连通图情况： 考虑一个连通图G。它只有一个0特征值。 在一个连通图中，特征向量对应于费德勒向量中的。 谱分割是基于费德勒向量（第二小的特征向量）中条目的符号。——正为一类，负为另一类 多个社区： 如果有2个以上的聚类，这样的过程可以被递归应用 这是一个分裂性层次聚类的例子 然而，它可能表现得很糟糕，可能会分割本来存在的社区 所以我们去，再利用k-means等算法对得到的特征向量进行聚类 总结： 一般适用于分组数量已知的情况，核心是最小化割边总和并最大化每个簇的节点数 GN算法 Girvan-Newman算法 步骤： 计算每个 的边介数，并删除具有最高值的边 将生成的图按连通分支拆分（簇）并递归地应用该方法 这会产生一个聚类层次结构，我们可以将其表示为树状图 ——根据一些标准选择最好的分区，比如模块度（modularity）、或指定集群数量 问题： 该算法的一个问题是它的时间复杂度： 对于非常稀疏的图，也有 ，仍然很高 其他算法可以达到 或 基准 为什么要有社区基准模型？ 测试和比较算法 控制噪音水平、社区规模等 真实图数据很少有真实值（ground-truth） 有ground-truth，但可能与基本假设不一致 种植-分区模型 Planted partitions model 固定节点数 n 和社区数 k，对于社区，我们： 平均分配节点到每个社区 或将每个节点独立分配给社区 i，概率为 ， 对于分别在社区i和社区j中的节点对，我们按照概率添加边 可以指定、 LFR模型 Lancichinetti-Fortunato-Radicchi model 固定节点数 n 设定三个主要参数： ：节点度服从 的幂律分布；推荐值为 。 ：社区规模服从 的幂律分布；推荐值为 。 µ：对于每个节点，这是连接到其他社区的边的预期比例，而 µ 是其自己社区内的比例。 ——µ 称为噪声水平或混合参数 把每个节点都分配到社区 存在允许重叠社区的变体 可以提供额外参数来限制度分布（平均和最大度）和社区大小（最小和最大） 从配置模型开始，重新连接节点以逼近目标分布 初始阶段可以使用BA等其他模型 基准代码生成 3 个文件： 包含节点标记为 1 的边列表的文件 包含节点列表及其社区成员的文件，社区也被标记为 1 具有度分布、社区大小分布和混合参数等统计信息的文件 讨论： LFR 的可扩展性有些受限，一些可扩展的基准模型有： RMAT ，生成具有幂律度数分布的图；在 Graph-500 中使用 BTER (Block Two-level ER)，生成服从幂律度分布以及社区结构的图 SBM（Stochastic Block Model），它也生成具有社区结构的图。 ——它最简单的定义是种植分区模型的变体。 模块度 引言： Barabasi 的第三个基本假设：随机连线的网络缺乏固有的社区结构 模块度使用随机连接作为空模型来量化某些图分区的社区结构 模型： 考虑无向图 令, , 为节点 i 的度数 设 当且仅当 ，否则为 0；设当且仅当 当我们随机连线时，节点 i 和 j 之间的预期边数（概率）为： 令 ，将图划分为 k 个簇。对于某些簇 ，定义： 展开为： 令： 代入可得： 模块度最终定义为： 我们将上面的第一项称为边缘贡献（edge contribution），将第二项称为度税（degree tax） 图的模块度 有时被定义为所有可能分区中上述指标所取的最大值 讨论（局限）： Barabasi 的第四个基本假设：对于一个给定的网络，具有最大模块化的分区对应于最佳社区结构。 然而，模块化有一些已知的问题——\"最佳 \"可能并不总是转化为 \"直观\"。 基于模块化的算法受到分辨率限制问题的影响： 考虑l个大小为m的集团（m-clique）组成的环， 当时，对相邻的集团进行分组，模块度高于每个集团自己形成集群 正如我们将说明的那样，一些基于模块化的算法因此倾向于对已有社区进行组合 算法 CNM： CNM算法（Clauset、Newman、Moore），也称为快速贪心算法（Fast Greedy） 开始，每个顶点作为一个单独集群 选择最能提高模块度的一对集群（如果有的话），然后合并它们 当没有办法提高模块度的时候停止 复杂度：，稀疏图更少 Louvain： 也称为多级算法（Multilevel algorithm）或快速折叠算法（fast unfolding） 开始，每个顶点作为一个单独集群 循环遍历每个顶点，将其移动到模块度增加最多（如果有的话）的邻居社区 重复以上步骤，直到没有任何提升空间为止 将每个社区折叠成一个节点并重新运行上述步骤——另一个层级 当图折叠到单个节点（或者当最后一级没有移动）时停止 复杂度： Infomap： Infomap基于信息论：使用概率随机游走和压缩算法来实现 给定 G 和一个初始化分区方案，尽可能高效地编码随机游走 利用随机游走往往在同一社区中停留更长时间的性质 优化图方程：社区间游走的平均位数+社区内游走的平均位数 复杂度： 标签传播： 开始，每个顶点作为一个单独集群，有自己的簇标签 循环遍历每个顶点，每个顶点都采用其邻居中最流行的标签（使用随机来打破死锁） 当每个顶点具有与其邻域中最频繁出现的标签相同的簇标签时，算法停止 复杂度： ——注意：此算法速度很快，但并不总能收敛到一个解。 其他： WalkTrap：一种基于短距离随机游走的分层算法。它的复杂度是 。 Leading eigenvector（前导特征向量）：基于模块化矩阵的谱分解。对于每个双分区，其复杂度为 Louvain和Infomap的算法目前被认为是最先进的。 2023年评论：应该是Leiden算法 图分区的比较（指标） 介绍：图聚类 常见的相似性测度量 与二元分类的联系 图感知度量 （Graph-aware measures） 拓扑学特征 图聚类 符号描述： A，邻接矩阵： ：顶点i的程度 术语解释： 图聚类/分割（clustering/partitioning）：将顶点分割成相连的子图 社区发现（Community finding）：并非所有的顶点都需要被分配到一个群组中去 模糊聚类（Fuzzy clustering）：节点不属于、属于一个或多个群组 图划分：，为节点集的一个划分（partition） 每个诱导出一个连通子图 是连通分支的泛化 集群内的边密度大；集群间的边密度小 应用： 图聚类是关系型EDA（互联网数据分析）的一个重要工具 图尺寸缩减 社区检测 异常检测 …… 如何挑选聚类算法？ 集群的质量 稳定性 效率（时间空间） 其他：不需要指定聚类的数量（k）、集群的层次结构等 优化目标： 这是无监督学习，所以没有明确的目标函数 不同算法使用不同的目标函数： 模块度： 同一簇 N-cut 不同分割方法对比： 质量的衡量标准： 稳定性的衡量标准：同一算法的运行多次比较 比较算法之间的结果： 相似性 总体分类： 基于成对计数（Pairwise-counting） 基于信息论 基于卡方分布（） 基于成对计数： 考虑对图节点的两个划分： 度量指标基于A和B里面各个集群中的成对元素 关键值为： 示例： Jaccard 指数： 兰德指数 基于信息论： 基于 A 和 B 之间的互信息 关键值为： 示例：归一化互信息 (NMI)： 基于卡方分布： 关键值为： 示例：Cramer 的 V指标 和 Tschurprow 的 T指标 测量指标vs.大小分布： 问题：比较不同大小的分区时，这些度量指标表现怎么样？ 实验（多次重复）： ：节点V的划分 ，V 的随机分区 ，、、、、、、、 测量 和所有分区 之间的相似性——期望所有相似度都很低 ——结果：只有兰德系数变得接近1，其他都随着t的增大减小或趋向0 按概率进行调整： 实现 “在聚类结果随机产生的情况下，指标应该接近零” 成对计数指标的调整： Jaccard 没有已知的调整形式 调整兰德指数定义为： 基于信息论和基于 的也可以针对机会进行调整 最常用的有： ARI：调整兰德系数 AMI：调整互信息 ——调整后的指标在随机下都趋近于0 二元划分 我们已经有了对比划分的指标，但我们根本没有考虑图拓扑。 测量相似性时应该考虑边吗？ 这就引出了下面要讲的图感知测量，在这之前，要先讲下二元划分 边分类： 图分区可以由节点 V 上的集合分区表示 我们还可以考虑二元边分类（顶点是否在同一簇中） ——两端节点在同一簇的边 ——两端节点在不同簇的边 更正式地说，对于顶点分区 A，我们定义长度为 m 的二元向量 ，其中，对于每条边 ： 更进一步地，可以利用此方法对类别1边子集的边进行搜寻。 二元分类器的评估： 考虑 和 ，两个二元边分类器。 用于比较二元分类器的四个基本计数是： 对应的各种度量指标如下： 准确性分数余弦相似度 图感知度量 （调整）图感知度量： 上一节的指标可以用二元分类向量的乘积表示： 我们提出一系列成对计数的图感知度量指标：（一个是普通、另一个是调整后的） 实验： 在LFR模型构建的社区中，调整图感知度量的性能指标都很好 不同种类的度量指标的度量效果不同（引子） 补充： ——图感知和图无关度量在解决问题方面具有相反的行为 图无关度量即前面说的普通相似性指标ARI等 设 G 的真实社区情况为 A， 并设 B1 和 B2 分别是 A 的粗化和细化 在某些情况下，在图无关度量下A更接近B2（细化）；在图感知度量下A更接近B1（粗化） 当使用图无关的度量时，集群的数量更多 图感知度量生成的集群的数量更少 这两种指标都获得高值是我们做图聚类所希望的 定理的公式化描述： 考虑Girvan 和 Newman 模型的变体 G(n, p, q, A)，用于研究具有社区结构的图族 图有 n 个顶点，A为分区结果 p为随机选择两个节点，其中的边在同一分区内的比例； q为随机选择两个节点，其中的边在不同分区内的比例。 拓扑特征 验证集群的另一种方法是比较集群的拓扑特征：参考Orman et al.,arXiv:1206.4987 示例：对于具有 个节点和 个边的社区 —— 缩放密度(scaled density)： 内部传递性(internal transitivity)： 其中 是 c 中 i 的邻居之间的边数， 是 c 中 i 的度数。 可以将特征作为簇大小的函数进行比较——比较聚类算法结果和ground truth的图形相似度 结论 使用调整后的基于集合的相似性度量，可以减少度量对分区粒度的偏差，消除随机性 图无关（ARI，AMI）和图感知（AGRI）度量是互补的：在评估算法的优越性时应同时使用它们 图的集成聚类（ECG） 共识聚类和 ECG 分辨率和稳定性 LFR 图上的研究 一些真实的图示例 ECG 权重 在异常检测中的应用 ECG 符号说明： 令图 G = (V , E), V = {1, 2, . . . , n}, 为无向图 对于每个 e ∈ E，边可以具有权重 w(e) &gt; 0，或者考虑所有 w(e) = 1 令 是大小为 的 V 的一个分区 定义指示函数，表示 图聚类的目标：好的、可扩展的、通用的——注意这是无监督学习 关联强度的度量 聚类的层次结构 不需要或尽量少调整参数 ——使用集成学习（Ensemble learning）来实现这些目标：利用生成的多个分区来集成——如何合并多个图分区？ ECG算法： ECG算法是图的共识聚类算法。步骤是： 生成步骤：来自 Louvain (ML) 算法的 k 个随机的 1级别（level-1） 分区：。 集成步骤：在初始图 G = (V, E) 的重新加权版本上运行 ML。 ECG权重是通过联合获得的。 边 的 ECG 权重定义为： 是人工定义的最小权重 表示是否在 的簇中共现。 通过示例可以看到，一个社区内的节点间的边在集成后权重变大，集团（clique）内的边尤其明显，而社区间的边集成后权重减小，变得很容易区分 分辨率和稳定性 分辨率： 基于模块化的算法存在分辨率限制问题：举例集团组成的环，相邻两个组合后模块度更大 w* 值较小的 ECG 算法缓解了这个问题 使用 level-1的Louvain 作为弱学习器是关键——第一层louvain不会聚合那些环上的边 实验： 在广义集团环上ECG算法表现也很好：将ECG和louvain、InfoMap比较，分别考察环上连接集团边数从1增加到5时的表现 即使噪音很大，权重仍然很显著：当噪声很大时，同一集团中的边权重仍然显著 在LFR生成的社区发现上，ECG算法能够很好地保留原始数量：level1的louvain数量过多，最终的louvain数量过少 在上一章的图感知与图无关度量上表现也很好 稳定性： Louvain 和其他算法的已知问题：多次重新运行同一个算法会得到不同的结果 我们通过运行每个算法两次并应用一些比较措施（例如 ARI）来量化稳定性 实验： ECG相比louvain在稳定性方面有了很大的改善 实证研究表明，结果对参数的选择不是很敏感（低级聚类次数k和最小权重W*）——不过一般情况下k越大、W*越小效果越好。 LFR 图上的比较研究 论文在数千个 LFR 图上比较 8 种算法 各种指标水平都是ECG较好 本研究只考虑γ1 = 2, γ2 = 1，在不同参数的LFR模型下，ECG大部分情况下都比较好 一些观察结论： InfoMap 在大小相同的小型社区上提供最佳结果 ECG 在其他情况下提供最佳结果 ECG 的效果始终优于单个 Louvain (ML) 真实网络 足球俱乐部网络 ECG和InfoMap都取得了最佳结果 YouTube网络 1,134,890 个节点（用户）和 2,987,624 条边（好友关系） 2-core 仅覆盖 41.1% 的顶点 8,385 个社区被声明为用户组，这些社区从拓扑角度来看非常薄弱 只有 12 个合格作为弱社区，外部度与总度的比率低于 0.5 我们将此比率扩展到 0.75（类似于 LFR 图中的 µ） 在图感知度量上ECG比InfoMap略胜一筹 权重 ECG 重新加权有助于提升聚类准确性和稳定性 我们讨论了计算的 ECG 权重的其他一些应用 我们定义了一个新的社区强度指数 (CSI) 我们展示了如何使用权重来放大种子顶点 社区强度指数CSI： 边界（0 和 1）附近的 ECG 权重的双峰分布(bi-modal distribution)表明了强大的社区结构 我们提出了一个基于点质量 Wasserstein 距离（推土机距离（Earth Mover's distance））的简单社区强度指标 (CSI) 定义： 对于所有边 ，以及来自 ECG 的 ，我们定义： 使得 关联强度： 从图上直观看出高 ECG 权重表示强关联 从经验上比较 ECG 权重和三角形出现次数：正相关关系 我们可以使用 ECG 权重作为自我网络的替代方案来放大种子节点 给定一个种子节点 v： 确定它所属的集群 删除所有 ECG 权重低于某个阈值 τ 的边 放大包含 v 的连通分量 增加 τ 可以对其进一步放大 ——使用此方法可以很好地保留ground truth里面的真实同社区节点 异常检测 最近提出了CADA（community-aware anomaly detection社团感知异常检测） CADA： 对于每个节点 ，令： ：v 的邻居数。 ： v 属于出现次数最多社区的邻居数（通过图聚类）。 ——：即InfoMap算法和Louvain算法 实验： 原论文仅在 γ1 = 3、 γ2 = 2 的 LFR 图上验证了他们的算法——生成的是大小均一的小社区 我们用 ECG 重新审视了这种方法，并为幂律指数提供了更多值 对于每个图，我们添加了 200 个具有与 LFR 中相同的度分布的随机异常节点（随机边） ECG算法表现都比较好 AUC（Area Under Curve）被定义为ROC曲线下与坐标轴围成的面积，显然这个面积的数值不会大于1。又由于ROC曲线一般都处于y=x这条直线的上方，所以AUC的取值范围在0.5和1之间。AUC越接近1.0，检测方法真实性越高;等于0.5时，则真实性最低，无应用价值。","tags":[{"name":"图与网络","slug":"图与网络","permalink":"https://renzehua1998.github.io/tags/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/"}]},{"title":"【复杂网络】关系型数据挖掘","date":"2023-02-02T04:00:00.000Z","path":"2023/02/02/图与复杂网络-2关系型数据挖掘/","text":"菲尔兹数学科学研究所 复杂网络2019夏令营课程 学习笔记 关系型数据挖掘（Relational data mining） 中心性度量 图模型 基准（benchmarks） 简介：使用jupyter notebook、python3、igraph包 关系型数据 术语 监督学习：分类（classification）、回归（regression） 无监督学习：聚类（clustering）、密度估计（density estimation）、降维（dimension reduction）、异常值检测（outlier detection）。 半监督学习：标记的数据很少，同时使用标记和未标记的数据 特征：feature（连续、分类或排序） 关系型数据 实体表示为点，关系可以表示为边，或超边（是否加权、是否有向） A和B是朋友 A给B发邮件 A，B和C在同一个团队 关系型数据被建模为图（graphs）或超图（hypergraphs） , let and ——得到邻接矩阵（一些性质，不再赘述） 完全图（Complete graph），也叫集团（clique） 图会出现在不同场景中：电子邮件交换、蛋白质-蛋白质相互作用图、社交关系（空手道俱乐部）、赛事（大学足球队之间的比赛） Issues 一个图里面有很多社区，传统机器学习将向量空间进行嵌入降维后可以进行聚类。 有许多工具可以处理这些数据，抽样等统计技术可用于处理大型数据集。 采样保留关键属性（簇、平均距离等），但这些都在图形空间中被破坏。 Problems 中心性度量 寻找社区 异常检测 种子集扩展（seed set expansion）-局部采样 链路（边缘）预测 半监督学习 向量空间嵌入 中心性 度中心性 所有边权值之和 入度、出度：入边权值和、出边权值和 归一化度中心性：无权图（出入）度除以来获得（假设没有自环） 节点中心性 中心性（Centrality）：综合考虑节点度和连接到高度数中心的其他节点 ，唯一解为——连通图无定义，需要进行扩充定义 定义一：特征向量中心性（eigenvector centrality） 将特征向量中心性定义为与（neighbour’s centrality）成比例 节点i的特征向量中心性是以下方程的解： 有向图，入度和出度分别进行定义 对于连通图，我们测量与最大特征值相对应的特征向量的中心性，最大特征值是实的和正的（Perron Frobenius），即： u1是主导特征向量 定义二：接近中心性（closeness centrality） 考虑节点之间的最短路径（最小跳数或最小边权重之和）——测地线（geodesic） dij为最短路径长度，dii=0，不可达定义为无穷，无权图可定义为节点数n 定义三：介数中心性（betweenness centrality） 更常用的方法是考虑所有测地线： 定义为节点j和k之间所有的测地线的数量 定义为节点j和k之间通过节点i的测地线的数量 定义四：Δ中心性（delta-centrality） 考虑从G中删除某些节点i的影响 设P(G)是图G上性能的一些度量 设Gi是通过从图G移除与节点i相邻的所有边而获得的图 ——注意，我们要保证 一种可能的P(G)取值：定义图G的影响力E(G)—— 说明： 对于不连通图，dij=∞的节点对的贡献为零。 通过考虑节点集，所有中心性度量都可以推广到组中心性度量。——节点集的度定义为非g节点连接到g内节点的数量 定义五：谷歌PageRank算法中使用的中心性 思想：互联网中重要页面与许多重要页面相互链接 我们在节点i处随机游走： 以概率：跳到随机节点。 以概率：以概率跳到节点j。 可以用代数或迭代（幂）方法获得PageRank值的解 在有向图中，我们将中枢（hub）定义为具有高出度的节点，而将权威（authority）定义为具有高度入度的节点。 在无向图中，这两个概念是相同的。 定义六：中枢/权威中心性（hub/ authority） 中枢中心性： 权威中心性： 让，我们有： 边中心性 ：节点j和k之间的测地线数 ：通过边e的节点j和k之间的测地线数。 相关性 基础知识： 设pi为出现次数为i次的节点在G中的比例，即度分布 度相关性 度量 由边链接的节点的度之间的关系 在同配网络（assortative network）中，高阶节点倾向于更多地连接到其他高阶节点，低阶节点也是如此 在异配网络（disassortative network）中，高阶节点倾向于更多地连接到低阶节点，反之亦然。 定义： k度节点的平均最近邻度函数： 其中是从k度节点出到k'度节点入的概率 如果没有相关性（中性网络-neutral network），有 pi：i度节点的比例 友谊悖论指出，节点邻居的平均度通常高于其自身的度。这是由于在许多网络中： 即：一个节点更可能与中心（高阶节点）链接 度相关函数可以近似为： µ表示同配网络 µ表示中性网络 µ表示异配网络 图模型（随机图） ER模型：Erdos-Renyi models (ER) CL模型：Chung-Lu model (CL) 配置模型：Configuration model ER模型 概念： G(n, m)模型：n个节点，m条边，任意选两个节点相连。——平均度：k = 2m/n G(n, p)模型：n个节点，任意两个节点之间以概率p相连（边数期望为Np）。——平均度期望：k = p(n − 1) 令p = m/N，此时可以转化为第一种模型 边数分布： 为G(n，p)模型中有m条边的概率，令：（典型二项分布） 假设N很大而p（通常）很小，我们可以使用泊松分布（ 为平均边数的期望）近似二项分布： 度分布： 某个点度数为k的概率为：（ 为平均度的期望） 由于近似服从泊松分布，此类模型不生成hubs节点，即真实网络中常见的高阶节点。 可以绘制度分布直方图，用poisson分布曲线可以很好地拟合 巨型连通分量（Giant connected component-巨片）：（期望平均度）——三种状态 ：亚临界状态；没有巨片，集群主要是树。 ：超临界状态；单个巨片，小集群主要是树。 ：连通状态；没有孤立的节点或小集群。 ——从折线图可以看出，k为1是分界点，一旦超过1，巨片占比迅速扩大；到k = 7逐渐稳定达到100% CL模型 伯努利Chung-Lu模型 模型： 网络G中的节点为： 每个节点的度为： 两个节点i和j连接边的概率为：（为图的体积——所有节点的度数和） 分布： 我们将定义为使用模型1获得的图G的分布： 其中图为获得的新随机图： ，但一般情况下 没有重复边 有自环 ——该模型在实际中不常用，其时间复杂度为 O(m) Chung-Lu模型 模型： 只需要的时间复杂度，更常用 在顶点V中选择条边， 根据多项式分布从V独立采样： 边可以重复，所以我们得到的是预期的边数而不是概率 分布： 我们将定义为使用模型2获得的图G的分布： 其中图为获得的新随机图： 我们总是有 允许存在多条边 也允许有自环 注意： 对于模型II，我们可以忽略重复的多条边，这会减小图的总度期望（体积） 对于这两种模型，我们都可以忽略自边（自环），这会再次减小总体积 配置模型（Degree Sequence） 提出： Chung Lu模型是边生成的概率模型，生成度序列的期望和原来的相等。 对于配置模型，我们为节点指定一个精确的度序列 所有具有n个节点和这个精确度序列的图 被认为是以相同的概率出现的。 模型： 对于每个节点i，我们指定个残边（stubs）——半条边 残边随机互联 可能会产生自环或重复边 对于该模型，节点之间的预期边数为： 对于自环： 边总数的期望为： 基准（小世界 幂律） 小世界网络 聚类系数 幂律网络 Barabasi Albert和其他模型 小世界网络 背景： 真实图通常不像 ER图 或 CL图 具有均匀的度分布 真实图中的一些性质： 节点之间路径相对较短（小直径）(small diameter) 局部密度行为（三角形，社区）(triangles, communities) 大量的低度节点 存在高度节点（枢纽，权威）(hubs, authorities) 定义：如果特征路径长度（节点之间的平均距离）与节点数n的对数成正比增长，那么图就表现出小世界行为。 “六度分割”理论：今天的社会网络通常有较低的特征路径长度（任意两人之间的平均关系路径长度为6） 聚类系数 背景： 大多数网络，特别是社会网络，都表现出同质性（homophily）。——朋友之间分享好友的概率大于随机建立 衡量： 我们可以通过观察图中的三角形（图的传递性(graph transitivity)）或每个节点的邻居之间的边缘密度（聚类系数(clustering coefficient)）来衡量这一点。 定义一个图 图传递性 三元组（triad）是一个由3个节点组成的子图，形成一棵树；设为图G中三元组的数量。 一个三角形（triangle）是一个有3个节点的完全连接的子图；设是图G中三角形的数量。 图传递性定义为： 聚类系数 对于一个度数为的给定节点，让表示节点i的邻居之间的边数 节点i的（本地）聚类系数定义为： 它也被称为局部传递性，因为它对应于节点i的自我网络（ego-net）的 图G的聚类系数定义为： 也被称为平均局部传递性 注意：和往往相似，但这其实是误导 考虑以下有n+2个节点（n个灰色节点）的图 ：， ：红色节点（），灰色节点 对于ER随机图来说，两个点之间形成边的概率为p，所以ER图的两个指标值都为概率p。 幂律网络 背景： 在幂律函数中，一个量按另一个量的幂进行变化 在度分布中很常见 设是度数为k的节点的比例 c是归一化常数 对于社会网络中的度分布，通常观测到的数值是 齐普夫定律：（Zipf’s law 二八定律是它的一个特例） 在书面语言中，从等级r=1开始，按出现的顺序递减排列词语 根据Zipf定律，等级为r的词出现的比例与1/r成正比 幂律函数是无标度或标度不变的：（scale-free / scale-invariant） 标度改变时，函数曲线的形状和函数的指数都没有变，即具有标度不变性 在复杂网络上任选一局部，由于其自相似性，局部网络的形态、规律、功能均与原网络不会发生变化，即在尺度伸缩时具有对称性。——类似于分型 定义的函数： 其中只有常数作为乘数a的函数而变化 在实践中，我们可以从参数为γ的幂律分布中，在某个区间[dmin, dmax]内抽取一串度数。 然后我们通过配置模型或CL模型生成一个图 CL模型可能会出现孤立点：因为存在大量低（期望）度的节点 举例： 见notebook 总结： 幂律网络表现出的度分布为： 许多低度节点 \"长尾\"（long tail）——高度节点的存在 这样的高度节点被称为枢纽（有向图的枢纽和权威 hubs and authorities） BA网络（Barabasi-Albert） 一种典型的幂律分布网络 概念： 这是一个优先依附模式的例子，也被称为富者愈富 逐个节点生成图： 在步骤t=0时，从一些初始图（例如：空图，小集团-small clique）开始。 在步骤t&gt;0时，向现有的节点添加一个新的节点，其边数为（最多为）m 新节点与（现有）节点i有一条边的概率与添加这个新节点之前节点i的度数成正比。 继续下去，直到生成n个节点 性质： 该模型倾向于依附于高度节点，从而形成枢纽 同理，度数为k的节点的比例为： 存在几种变型 ER随机网络就没有这种幂律分布特性","tags":[{"name":"图与网络","slug":"图与网络","permalink":"https://renzehua1998.github.io/tags/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/"}]},{"title":"【复杂网络】绪论","date":"2023-02-01T04:00:00.000Z","path":"2023/02/01/图与复杂网络-1绪论/","text":"菲尔兹数学科学研究所 复杂网络2019夏令营课程 学习笔记 菲尔兹数学科学研究所 复杂网络2019夏令营课程 授课老师来自：Tutte数学与计算研究所 ——加拿大政府研究机构，成立于2011年 基于Python3、igraph框架。2019.8 ComplexNetworks2019 本夏令营的其它课程资料（Julia）： day1day2 day3day4day5 研究领域 密码学 经典密码学 后量子公钥密码学 “高级密码学” 数据科学 机器学习理论与实践 图挖掘技术 网络防御和安全应用 脆弱性研究 GC系统的网络安全 流水线 本课程涉及的内容 UMAP：统一流形逼近和投影——是一种降维技术，可用于类似于 t-SNE 的可视化，但也可用于一般的非线性降维。UMAP 是一种基于流形学习技术和拓扑数据分析思想的降维算法。它为处理流形学习和降维提供了一个非常通用的框架，但也可以提供具体的具体实现。 图聚类（Graph clustering）：各算法比较，一种新算法（ECG） 图嵌入（Graph embedding） 图上的半监督学习 超图模块化和聚类 拓扑数据分析：UMAP 降维技术 范畴论（Utilizes category）和代数拓扑学（algebraic topology）的使用 真实应用 和t-SNE算法的对比 t-SNE是一种非线性降维算法，非常适用于高维数据降维到 2 维或者 3 维，进行可视化。在实际应用中，t-SNE很少用于降维，主要用于可视化 ECG：图上的集成聚类 ——Ensemble Clustering on Graphs 总目录 关系数据挖掘 中心性度量 图模型 基准（benchmarks） 社区结构 图划分（graph partitions）算法比较 图聚类算法 图上的集成聚类（ECG） 图嵌入 图上的半监督学习 超图模块化和聚类","tags":[{"name":"图与网络","slug":"图与网络","permalink":"https://renzehua1998.github.io/tags/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/"}]},{"title":"【态势感知】第二章 传统战与网空战","date":"2023-01-21T04:00:00.000Z","path":"2023/01/21/网络空间安全防御与态势感知-02传统战与网空战/","text":"《网络空间安全防御与态势感知》阅读笔记 引言 态势感知在复杂企业运营和传统战争领域历史较长 讨论传统冲突中态势感知本质 回顾对传统态势感知（KSA）的认识 将其与网空态势感知（CSA）做对比 相似点——挑战和机遇是类似的，都会对任务完成效果产生较大影响、都存在认知偏差 不同点——传统态势感知依赖广泛使用的表现形式（战场物理地形图），网空领域还没有这种形式 从传统战场过渡到虚拟战场 20世纪面对面互动形式的工业时代冲突变为信息时代的冲突 当前既包含传统战场也包含虚拟战场 将来将越来越强调虚拟战场 网络化组织形式：协作者数量无限、可利用信息无限 战争越来越多地发生在虚拟空间中不同网络之间 传统军事行动和网空行动特点： 威胁领域差异显著： 物理世界直接观察、增强观察可以看到威胁 网络世界具有高度可塑性且容易进行欺骗 优势互换： 传统军事行动防守者更占优势 网空领域攻击者更占优势 匿名性 针对性攻击 攻击利用 人性弱点 取证难度 ——虽然有很大差异，但仍有可借鉴之处 态势感知重要性 “网络支撑作战行动”概念框架： 高度网络化的部队应改善信息共享和人员协作 共享与协作可以改进信息质量和共享态势感知质量 可以反过来促进进一步自同步，改善指挥速度和可持续性 上述原则组合可以进一步提高任务执行效能 ——信息化程度越高，越能获得更好的态势感知 局限性：这些序列中任何一环出问题都有可能成为瓶颈，制约整体效能。 传统态势感知 物理传感器+人体感官+远距离情报监视平台 敌我双方都可以获取相同信息 为物理战场建立准确的模拟模型是一个关键 信息的获取与理解存在折中关系： 一定的数据帮助认识形式分析状态 过量数据压垮处理者——人类信息理解的局限性 网空态势感知 互联网的出现打破了地理边界 我们要建立网空防御体系、支撑网空任务并提供态势感知能力 发现漏洞路径自动勘察、多源数据关联融合、攻击路径可视化、自动生成方案、影响分析…… 传统态势感知研究示例 两个对传统态势感知进行量化描述的案例——传统领域特有挑战 DARPA的MDC2计划 美国国防高级研究计划局（DARPA）：多单源徒步作战指挥控制 目的：对高度信息化分布式轻型装甲部队进行作战指挥 以深入了解敌人信息取代了厚装甲——能否克服认知挑战？ 开发了人机系统原型：自动融合所有数据到共享态势图、帮助士兵收集评估情报的工具等 进行了战斗模拟：对战局进行等比例刻画、对态势进行定量描述 RAID计划 也是DARPA：实时敌方情报和决策制定 目标：开发自动预估敌人态势并预测近期行动的工具 聚焦于特定场景：红蓝城市战术战斗，红队攻蓝队防 蓝队指挥人员借助信息融合系统整合信息 依据信息得出红队当前态势评估+意图、和对所预估未来事件的描述 对照试验：参谋人员vs自动化系统 上述两个计划的效果将在下一节与网空态势感知进行比较 相似点与巨大差异","tags":[{"name":"态势感知","slug":"态势感知","permalink":"https://renzehua1998.github.io/tags/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5/"}]},{"title":"【态势感知】第一章 基础理论与当前挑战","date":"2023-01-20T04:00:00.000Z","path":"2023/01/20/网络空间安全防御与态势感知-01基础理论与当前挑战/","text":"git的简单使用 引言 背景：军事、政府和商业界更多地应用网络技术，给敌人利用漏洞进行攻击利用提供了可乘之机。 特点： 攻击者业余到高度组织化的都有 攻击来自内部和外部 手段多样，甚至可以绕过或利用防御系统 对操作员的要求： 首先实现并维持一定程度的态势感知 做到对不断演化威胁的识别、理解和预见 采取行动抵御并展开报复 存在的困难： 怎样将技术与人类认知能力融合 海量数据规模超过人类认知极限，导致难以处置 新的攻击手段被不断开发出来 怎样聚焦发展方向： 充分理解需求：理解破坏的效果、理解情境需要的信息、理解操作员要做的决策 清晰定义内容：定义获得感知的过程、构建支撑系统的理论基础。 网空态势感知 定义 态势感知：在一定时间和空间内观察环境中的元素，理解它们的意义并预测不久将来的状态。 第一级：观察——感官检测（显示、信号） 各类系统节点、当前协议、被攻击节点、历史活动记录、受影响系统IP等 第二级：理解——弄清楚事件意义和显著性 特点节点易受攻击程度、攻击行为特征、攻击关联、事件对当前任务影响、优先级排序 第三级：预测——前向时间推断、心智模型、个题理解 预测恶意活动影响、预测未来攻击途径 需要实时对态势感知作出动态更新：获取最新信息+对系统执行操作 需求 取决于个体担任的角色，依据分工不同而有所不同，但都需要进行总体把控。 传统的分析方法是目标导向任务分析（GDTA）。为每个角色在三个阶段分别： 确定高阶目标结构 列出需要的主要决策 描述对支持决策所出现的需求 ——可以确定要给分析员提供什么信息、确定需要整合哪些信息 详细需求见原书表1-1 认知机制 人类收集、理解信息最终形成态势感知的过程： 影响人们获得和维持态势感知的程度的因素 外因：环境的关键特征 系统提供信息能力 系统界面设计 系统复杂性 系统自动化程度 压力和工作负荷 内因：短时感官记忆、观察力、工作记忆、长时记忆机制 以“前注意”方式对环境元素进行并行处理，检测出涌现特性——有限的注意力是最大限制 工作记忆和长时记忆引导观察——经验丰富（工作记忆多）有助于更快的识别 长时记忆： 心智模型：系统组件和如何相互作用的认知——不增加工作记忆负荷的前提下提供高层次感知 图式模型：系统状态的原型类别（抽象出的类别特性）——瞬时的模式匹配 专业知识起着重要作用——系统呈现的信息要足以支持操作员将当前情况与心智模型和图式进行匹配 操作员目标也很重要——引导对环境的哪些部分进行关注 需要交替采用目标驱动和数据驱动： 数据驱动效率低 目标驱动可能遗漏关键信息 ——态势感知是动态过程，受到认知机制影响。在复杂环境中形成准确感知仍具有挑战性。 ——主要目标就是开发出能增强态势感知的可选储备、培训计划和系统设计。 面临的挑战 复杂多变的拓扑结构 特点：规模庞大、结构复杂、变化快。 网络状态很难保持一个准确的图景 细微变更带来的影响难以理解预测 超过人们的心智模型处理能力 快速变化的技术 难以保持对系统拓扑结构的准确理解 变革带来的新能力对系统漏洞和系统行为产生深刻影响 需要不断更新迭代心智模型 高信噪比 异常经常发生：故障、更新、遗忘密码…… 用户习惯性忽视异常 嘈杂背景掩盖真实攻击特征 定时炸弹和潜伏攻击 攻击发生和效果显现存在时间间隔 长期潜伏的恶意代码在特定时间或特定条件下被触发 快速演化的多面威胁 攻击者可以利用非常广泛的潜在攻击向量——指数级增长 事件发展的速度 观察-调整-决策-行动（OODA）循环难以应对一秒以内发生的快速攻击 无法实时响应、只能做到取证分析、事后评估 非整合的工具 缺少一套完整工具、只能依赖各种工具，工作量大 数据过载和含义欠载 数据量太大人工难以分析 理解预测方面的信息缺少支撑 自动化导致的态势感知损失 将操作员排除在外，降低了感知水平，难以理解运行状态并更新事件库 总结： 缺少辅助网空行动操作员获得所需全面信息的整合工具 缺少对数据进行转化从而理解事件影响的机制 缺少支撑积极网络防御的工具 研发需求 必须从反应式取证响应变为实时、积极的和预防性的网空对抗行动模式 网络空间通用作战态势图 COP 以态势感知为导向的设计过程（SAOD） 要求分析阶段：GDTA（目标导向的任务分析）过程来确定特定角色的目标 不再局限于任务步骤或过程 聚焦于操作员的认知需求 广泛应用于各个领域 态势感知设计阶段： 每个界面都包含高水平态势信息 高度可视化、便于进行理解与预测 保持全局大图景，也提供理解态势所需细节 将用户注意力引导至关键信息 直接支撑多任务处理 其他：整合复杂与不确定性、有效利用报警系统、分布式团队共享 有效性评估阶段： 态势感知、工作负荷、性能和可用性的度量 用来评估操作员态势感知水平和系统的有效性 示例：SAGAT一种态势感知全局评估技术 动态变化大规模复杂网络可视化 最好是能展示网络的动态变化 不仅要解决抽象可视化问题，也要解决显示类型问题，满足不同需求 例如评估某一恶意行动对资产影响——目前还没有很好的方案 对决策者的支持 需要把网空态势作为决策者目标里的一环考虑 需要提供通用作战态势图 协同人员与自主系统结合团队 快速和大量都超过了人类处理能力，必须使用自动化工具 自动化工具会使人类脱离闭环外：因为使用自动化系统会降低警惕性、界面不利于理解、不理解系统状态模式和对自动化工具不信任等 自动化仅能在面对已知问题时才能工作，未知攻击来临时还是需要人类 支持人员与自动化系统有效组队的协同设计原则： 为各层次自动化机制提供灵活的受监督自主能力 通过机制透明度对自主行动与未来预测提供支持 人类操作员保持在闭环以内运作 进行信息整合以提供必须的理解与预测支持 保证系统的可理解性：系统模式最小化、系统状态显著 ——自动系统和操作员高度共享，使得两者目标和任务保持一致 组件代码的检验和确认 要建立新的检验与确认方法以保证对自主系统的信任 是为自主网空行动提供置信度的必由之路 积极控制 需要能预防已知未知攻击的能力 需要对攻击者进行画像以制定防御策略 需要能评估攻击和对抗措施对任务行动的影响 小结 网络空间战争可能会改变战争的形貌。 态势感知三个层级：观察、理解、预测，输出直接馈送至决策行动循环中 某个人员的任务取决于他在防御行动中的角色 传统解决方案：GDTA 确定高阶目标结构 列出需要的主要决策 描述对支持决策所出现的需求 制约当前态势感知的因素： 复杂多变的拓扑结构 快速变化的技术 …… 最直接的网空行动需求：创建有效的通用作战态势图（COP） 根据不同操作员的位置而定制 需要更好的可视化方案 支持人们了解系统状态、预测潜在攻击 平衡人类与自主系统，建立共享的高水平态势感知","tags":[{"name":"态势感知","slug":"态势感知","permalink":"https://renzehua1998.github.io/tags/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5/"}]},{"title":"【态势感知】前言","date":"2023-01-19T04:00:00.000Z","path":"2023/01/19/网络空间安全防御与态势感知-00各种序/","text":"《网络空间安全防御与态势感知》阅读笔记 《网络空间安全防御与态势感知》 作者前言 第一章：操作员怎样形成感知，关于态势感知的要求。必要性和当前面临的问题。 第二章：传统战争中的态势感知KSA和网空态势感知CSA的比较、相关性和差异性。 第三章：网空态势感知在不同阶段如何形成、各阶段涉及的角色。 第四章：如何形成感知，面向整体网络视图——宏观态势感知。 第五章：人类态势感知中信息整合技术和计算表达方面的挑战与方法。 第六章：怎样弥合与人类认知推理的差距——提取分析师推理过程。 第七章：可视化相关——科学可视化、信息可视化、可视化系统。 第八章：清晰的语义和标准的本体模型辅助推理。 第九章：机器学习算法有效性和语义清晰度的折中关系。 第十章：第二级态势感知——“理解”，如何评估影响。 第十一章：第三级态势感知——“预测”，推断演化和未来预测。 第十二章：对可能实现的改进进行量化评价——评估指标。 第十三章：最终目标——态势管理，维护任务的弹性恢复能力。 译者序 总述：网络空间安全防御与态势感知学术文章合集。建议先阅读原作者前言。 网空态势感知研究：精读全部内容 网空安全防御：精读1-3章 由几个问题引出： 为什么需要态势感知 ——网空态势感知正是实现网络空间保障的先决条件 网络信息技术的应用发展 早期，将物理隔离作为最值得信赖的防御措施 信息系统较少时，“一刀切”，应对业余爱好者的攻击 信息系统较多时，“突出重点”，保护重要系统 云计算、大数据广泛应用的如今，信息系统成为不容有失的关键基础设施 安全防护工作模式转变 立足于更加积极的合规驱动工作模式，进一步针对关键基础设施等重要领域实现主动有效的全方位体系化防护工作模式。 网络安全防御理念演化 将网络空间和传统物理空间中的威胁综合考虑——以威胁对抗有效性为导向的防御理念 网络安全防御体系建设模式变革 传统军事领域的实践具有积极借鉴作用——从基于威胁规划变为基于能力规划 “内网基本安全，只需查漏补缺”想法已经过时，——需要“找出来、赶出去” 基础防线为动态防御提供了有力的对抗环境，屏蔽低水平攻击干扰、加强隐匿行动发现能力 网络安全防御机制创新 叠加演进的网络空间安全能力模型： 基础结构安全 纵深防御 积极防御 威胁情报 反制能力 不仅要静态，更要动态：一套有效的动态指挥控制体系 态势感知是什么 ——在一定时间和空间内观察环境中的元素，理解这些元素的意义并预测这些元素在不久的将来的状态。 三个分层阶段：观察、理解、预测。——一种“知识的状态” 和态势评估的差别：态势评估是实现、获取或维持态势感知状态的过程。 “态势”不只是宏观态势，也有“中观情境” “感知”不仅仅是观察，更侧重于运用知识获得面向响应处置的机敏能力 一些困惑 应面向策略调整还是战术响应？ ——兼顾宏观中观、结合实时采集与知识经验（中长期情报）。最终支撑短期响应和中长期战略调整。 仅仅依靠宏观态势感知难以支撑有效的积极防御体系——关注中观层面 应当能够支撑战术响应，可以接受处理微观数据。 侧重于微观上的入侵检测-&gt;在中观层面对观察到信息进行组织与理解-&gt;根据中观层面的合理推测在宏观层面制定决策-&gt;执行行动对节点实体产生微观影响。 要结合中长时间周期对抗威胁积累的知识经验发现高级威胁。 只是为了满足整体安全状态展示吗？ ——不仅是整体安全状态，还要具体分工确定需求，以交互方式向运维人员提供必要的信息支撑和分析能力。 不仅是要处理海量数据，还要能及时处理高速源源不断产生的安全事件。——仍会有大量安全事件让安全人员分析。 安全分析师仍是不可或缺的，还需要得到信息化建设与运维人员等的配合。 地图+炮形式态势感知效果为何不显著？ 大部分人将地理信息放入其中，称为“态势感知”，侧重于展现宏观整体安全态势、罗列部分微观信息 只能回答“有或无”，无法提供攻击行动阶段和攻击者位置等信息，更不能回答影响、演化、行为等一系列问题。缺乏中观呈现能力——感而不知 缺乏安全人员的分析和交互操作能力，无法有效指挥积极防御。——感而不为 如何实现态势感知 提法1——观察层：加强采集能力；理解层：可视化展示；预测层：数学模型预测。 提法2——观察层：采集+可视化；理解层：提高安全人员技术水平；预测层：人工智能深度学习。 提法3——简单态势感知：地图+炮；高级态势感知：理解+预测。 ——这三个阶段不是分立的，而是相互融合的 本书观点—— 观察层：传感（sensing），获得微观层面感知——是什么 理解层：结合防御目标解释数据含义，结构化中观呈现全貌图景——意味着什么 节点视角：易受攻击的程度 模式角度：攻击行为的检测特征 事件关联视角：哪些事件可能相互关联 事件影响视角：对当前任务运行的影响 竞争性事件的优先级排序 预测层：对安全事件进行前向时间推断，确定未来影响，预测下一步可能发生的情况——会造成什么 人工预测的问题——效果与运维人员认知状态有关 完全依赖人工预测具有不可持续性，可能导致低水平感知：注意力与工作记忆制约。 缺乏明显线索引导 难以发现关键关联 信息不足造成乱猜 无行动支持难以想出对抗方案 海量数据超越认知局限性阈值 过分强调可视化，造成“掌控一切”的虚假感受 怎么做？——改变依赖分析人员的低效模式，进行高效态势感知——如何高效？ 如何实现高效态势感知 ——威胁情报驱动态势感知以指挥积极防御的动态综合体系化网空安全防御模式。 大量的记忆查找转化为模式匹配 大量经验知识抽象为长时记忆模型 适合长时间记忆的认知结构：图式、心智模型 图式：过去的情境态势抽象为结构化知识，可用于模式匹配、可用于长时间存储与查找 心智模型：人员对系统目的和形态形成的描述、对状态的解释、对未来的预测（特定图式） 主要内容： 图式包含检测攻击需要匹配的模式——威胁指示器 心智模型用结构化形式整合组织信息帮助理解，同时包含着未来状态预测——战术、行为模式：与业务结合 图式绑定的脚本包含着此情景对应的响应序列——行动方案 流程： 前期准备：采集数据与事件信息并行处理——过滤、缩减、预处理。根据经验知识抽取特征、进行标签标定。——提取涌现特性 观察阶段：使用图式信息融合机制，将元素聚合为攻击轨迹等。与图式进行匹配，匹配到的作为疑似事件。 理解阶段：将疑似事件的心智模型作为框架，辅助安全人员实现信息整合组织与结构化呈现。进而理解可能造成的影响。 预测阶段：将当前情境与典型攻击模式结合，推测出未来状态、对影响效果进行评估。 最终效果：确定响应行动优先级，开发行动方案。 困惑 实现了全自动防御响应机制，还需要态势感知吗？ ——并不是“二选一”，而是如何有机结合 攻击行动空间分散、时间间隔很长、可能需要某事件触发 正常维护行为很难与攻击区分 会被人类决策者、攻防博弈等干扰 高度对抗环境中人工智能检测机制可能被操控 结论：需要采用“人在控制闭环上”的“半自动化”防御模式，将安全操作员作为系统的组成部分。 误判可能性小、影响范围可控的低水平或高置信度已知攻击——受管控的自动化处置。 存在不确定性的中等水平威胁——安全人员参与甄别鉴定，自动化执行前进行确认放行。 高水平威胁——基于线索展开深入甄别分析，对响应方案进行优化调整，将自动与手工相结合。 如何围绕网空防御人员实现态势感知 ——还需要建立高阶决策所需的心理模型，加强人机结合 加强整合现有设备、利用各种分析工具、对流量和日志进行过滤等预处理。对可视化机制进行改进增强。 “人员与自主系统协同组队”，系统和人员高度共享。运用高级显示和推荐系统、呈现过往细节的知识结构、提供一系列未来可能的情境态势选项。 系统侧： 采用具有形式化语义的可读语言对事件与关联进行建模，使用类似图结构将结果组织起来； 采用“杀伤链”情境本体模型对事件进行结构化组织，使用心智模型将其与攻击行动等经验结合； 根据推理机制进行预测、使用融合知识表达模型呈现情境态势。 人员侧：实现“二阶”态势感知。 培训安全人员形成长期记忆认知结构、学习如何使用信息可视化和数据钻取等交互方法进行分析、并在呈现信息的引导下进行理解预测。 在系统支持下制定决策，通过界面向系统传达处置指令。 支持实现态势感知的系统形态 涉及方方面面，全都要兼顾考虑 越来越多的网络安全技术与围绕态势感知的积极防御体系关系密切 几乎不可能以一个单体系统达到。——引入复杂超系统理念（system of systems） 以系统工程方法，体系化设计以态势感知为中心、以威胁情报驱动的积极防御体系 推荐序 迄今为止业界最完整最系统的基础理论文献 业界更多涉及态势感知能力建设的场景： 机构客户建立防御体系 监管部门建设监测通报 安全厂商工资体系的自我完善 对手的变化 单点威胁-&gt;高级网空威胁行为体 不再是对上网体验和互联网效率的影响，而是对关键基础设施和重要信息系统的控制、干扰、窃取、破坏。 以大国博弈为背景，高成本支撑下的体系化攻击。 敌已在内，敌将在内。网空防御五条规则： 敌方终将进入我方内网 网络防御者不能改变规则1 敌方已经进入我方内网 攻击将继续进行 情况会越来越糟 威胁行为体等级： 业余黑客、黑产组织、网络犯罪团伙、网络恐怖组织、一般能力国家、高级能力国家、超高能力国家。 视角的变化 从自我闭环到走向客户，实现与攻击者的闭环 定向性的安全威胁在攻击目标场景上具有个性化特点 依靠同一厂商维护分发、自我闭环，难以应对定向性威胁 “片面抗战”到“全面抗战”，充分依赖客户本身的主观能动性 客户的信息资产并不仅仅是攻击目标和防护对象，更是进行布防的战略纵深 思路的变化 从监测平台到战术型态势感知平台 监测型：需求调研、工程实施+情报赋能、定制改造、接口融合、流程电子化、可视化展示 目标主要是提升资产普查能力，对安全威胁进行监测 实际情境中，更多的是互联网侧暴露资产的安全情况，效果并不理想。 原因： 承担方技术能力不足 缺少有效的总体规划和能力整合 感知手段高度单一 对威胁的评价导向，认为阻止了某几种可被建模的威胁就具备了基础检测能力——不适合APT 预测倾向于判断“攻击何时发起”，忽视了如何运行和对未来状态的影响 “地图+炮”的模式 采集手段初级，仅限于互联网暴露资产，关键基础设施内部探针较少 态势感知：“三高”网络作为重点保护对象 承载高信息价值资产 被规定为高安全防护等级 受到常态化高强度网络威胁攻击 效果的变化 从单点防护能力到动态综合防御能力 靠堆砌产品不能形成有效的防御体系 “网络安全滑动标尺模型”：五大类别具有连续性关系，左边为右边提供基础支撑、降低实施难度、提升防御效果、减少资源投入 基础结构安全 纵深防御 态势感知和积极防御 威胁情报 反制 要注意的问题： 辨识网络安全领域各种观念 两种错误倾向： 片面夸大单点防护的作用 片面否定既有成熟单点环节的价值 意识到叠加演进的安全能力建设，以扎实基础可靠的单点基础安全能力为支撑 站在防御体系的角度，多数单点环节形成有效能力同样是体系化的工作 安天的安全理念： 综合发展 深度结合 全面覆盖 动态协同","tags":[{"name":"态势感知","slug":"态势感知","permalink":"https://renzehua1998.github.io/tags/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5/"}]},{"title":"谈谈《霍乱时期的爱情》","date":"2023-01-17T04:00:00.000Z","path":"2023/01/17/谈谈《霍乱时期的爱情》/","text":"《霍乱时期的爱情》读后感 序 马尔克斯自认为是“最好的作品”，比《百年孤独》还要发自内心的创作。刚上大学那会看一部叫《春风十里不如你》的剧，这本书穿插在其中见证了剧中男女主之间的爱情之路。后来和《百年孤独》一起买了来，不过一直没能读完，借着今年定下的读书目标，把它作为书评计划的第一本吧。 刚开始看书的时候，我还以为这本书是讲在霍乱时期一对恋人互相扶持，由于种种原因没能在一起，在主角拯救了许许多多生命后，两人终于走到一起，或留下永远的遗憾之类的故事。随着阅读的深入，越发感觉到自己的浅薄：若真的是我想的这么一个俗套故事的话，又怎么会被传为经典呢？ 在我看来，我们可以为男主阿里萨的痴情而感慨、可以为他爱而不得的痛苦而感同身受。但他无论如何都不能被定性成“好人”，他的某些行为确实足够罪恶，不管是不是出于主观故意。然而我们不能因为主人公“品行不端”这类理由而把一部作品判定为不值一读。 关于故事 网上有人说“这不就是一个男人经过不懈努力最终熬死了初恋老公，最终重新收获白月光爱慕的故事吗？” 是，但如果只用这么一句话概括全书，未免也太浅显了。对于这个短视频泛滥的年代，诸如“几分钟看完xx”的解说账号一定会这样概括。取一个震惊的标题，用几句话概括内容，观众就像在高铁上看了一眼风景，很快就过去了，甚至没有在他们的心里泛起一丝涟漪。当我花了好几个晚上，在台灯前静下心来逐行阅读那些文字，努力体会里面人物的思想的时候，才真正感受到这本书的魅力。 随着阅读的深入，我的好多预期被打破。小说以赫雷米亚·德圣阿莫尔的自杀案件开始，乌尔比诺医生去拜访他生前的情人。本以为是倒叙的展开，让这个女人和医生讲讲他俩的爱情故事。然而并不是这样，作者借此引出了乌尔比诺医生，讲他的爱好、他的生活、他的妻子费尔明娜。当乌尔比诺医生意外跌倒摔死后，我还以为是要倒叙讲这老夫妻在霍乱时期经理的爱情历程。然而我又错了，随着阿里萨的出现，他向乌尔比诺太太声明了自己对她坚贞不渝的爱情，这才引出了本书真正的主人公——阿里萨和费尔明娜。 很难形容刚读完书的感受，似乎没有对于阿里萨最终得偿所愿的兴奋，也没有对于费尔明娜走出亡夫的痛苦开始热爱生活的欣慰，更没有对结局两人决定在船上一生一世的浪漫而动容。在我读到结尾，阿里萨的少女恋人因他而自尽的时候，地震了（真的很巧，我家在地震带，总有小地震），我的心扑通扑通地跳个不停。之前看到养鸽女因为阿里萨被丈夫杀掉都没有这种情感。我深刻地认识到，阿里萨所谓的“肉体放纵而精神纯净”不过是遮羞布罢了。他和费尔明娜的爱情也绝不是苦苦追求修成正果，而是建立在无数被他伤害过的女性身上的。虽然大部分阿里萨的情人都是逢场作戏，但这不能为他的行为开脱。他的放纵，他们的爱情是真真正正伤害了其他人。 看完书去搜索评论的时候，看到许多人说“这本书写尽了世间的爱情”，说的应该是阿里萨的放荡经历。我或许无法认同这种看法，阿里萨在五十年里经历的许许多多女人，真的是爱情吗？他内心深处一直装着自己的初恋，对那些情人更多的是内心苦闷时的替代，是暂时的慰藉罢了。但是爱情的定义又是什么呢？我也不敢妄下定论。 关于初恋 女主费尔明娜和男主阿里萨在年轻时一见钟情，或者说一开始就是男主先爱上了女主，通过锲而不舍的守候、通过女主的姑妈帮助，通过他那一封封诚挚的书信，终于打动了女主。女主甚至因为和男主的恋爱而被教会学校开除。即使女主的父亲极其不同意二人的恋爱，不惜让女主回到老家“体验生活”来忘掉男主，她在心里却从来没有动摇，在旅行期间两人的秘密通信中，甚至到来谈婚论嫁的地步。 然而就在读者以为一切都在想着好的方向发展时，在女主开心地在“代笔人门廊”采买结婚物品时，两人相遇了。男主一句“这可不是花冠女神该来的地方。”就让女主失去了对他的爱慕，甚至立刻绝情地“把他从生活中抹掉了”。在以后的许多年偶然想到他时，只会说一句“可怜的人”。 是什么造成了如此巨大的反差？也许就和如今的“网恋奔现”一样，阿里萨是第一个主动追求她的人，两人之间主要依靠书信交流，之前见面次数也少得可怜，很多时候都是匆匆一瞥。而在看到男主可怜的样子，听他对自己这番似嘲讽又似埋怨的话，忽然好像认清了这个人，发现自己从前恋爱的对象不是内心幻想中的样子，所以瞬间失去了兴趣。 这段无果而终的爱恋，让费尔明娜变得更坚强了，她开始主动承担家庭责任：安排一日三餐、出门采购货物，也开始从排斥变得试着接受父亲给自己安排的追求者。而男主阿里萨却从此一蹶不振，浑浑噩噩地过了好多天，母亲说他表现得“好像得了霍乱”，而爱情就像霍乱，让人如此难受。这段失败的感情也彻底改变了他的恋爱观，开始在肉体上放纵自己。随着进入叔叔的航运公司，他的人生目标成为了“等待女主丈夫死去，努力变成配得上她的人”，并一直为这个目标而努力。 “有些人生来就会爱，而有人一辈子也学不会爱。”也许费尔明娜是前者，而阿里萨是后者。初恋可以让一个人变得自强成熟，也可以成为一个人心中永远的痛，需要一辈子疗愈。 关于陪伴 这部分之前想起的标题是“关于婚姻”，但细想之下原著对婚姻生活的描述或许仅限于女主和她的丈夫乌尔比诺医生。而本部分想探讨的是爱情中关于相守和付出的部分，包括男主和他的黑人女助手、结尾的男女主，所以最终取名为“陪伴”。 书中相守时间最长的无疑是女主费尔明娜和她的丈夫乌尔比诺医生，两人的婚姻在外人看来简直可以用“举案齐眉”来形容。虽然两人一开始或许并没有爱情，女主只是遵照父亲的意愿嫁如贵族家庭，医生也只是和一个合适的女人结了婚。两人的婚姻生活也有诸多磕绊：比如开始女主受不了婆婆和小姑们的生活方式，两人到欧洲居住了好几年才最终解决；医生也曾出轨自己的一位病人，导致两人的婚姻产生了危机，女主独自回到家乡和表姐住了好久两人才和好。不过到最后，两人之间已经到了“因为对方先自己一步而说出自己内心所想而生气”，似乎已经成为了一个人。这个时候两人之间于其说是爱情，不如说是长久陪伴一起生活之下产生的比爱情还坚固的东西。 男主阿里萨那上百端或短或长的爱情无法一一列举，我这里想说的是他和自己的黑人女助手莱昂娜·卡西亚尼的爱情，她也是这许多女人里唯一没有和男主上床的人。两人的初见是在夜晚的电车上，男主还以为卡西亚尼是做皮肉生意的女人，结果发现她只是要求自己提供一份工作而已。后面为了报恩，她在公司为阿里萨扫清了前进路上的各种阻碍，哪怕是最凶险的争斗也在所不辞。最终在男主对她表白时，她说“已经太晚了，在我看来你已经比我小二十岁了”。多年的辛劳摧毁了她的健康，也让她变得比男主更加成熟。或许可以认为两人是“灵魂伴侣”，或许两人之间是那种相互陪伴的类似于亲情的感情。 最后当然是男女主最后的爱情。在经历了五十年的等待，女主终于答应男主，登上航船来一场心灵之旅。两人终于互相表明心意，女主与其说是旧情复燃，不如说是在万年又重新爱上了男主。在自己饱受思念之苦、受人非议、昔日好友离散之时，男主再次出现表明心迹，用一项擅长的书信像人生导师一样帮助她走出困顿，最终两人走到一起。然而以两人的身份，回到岸上是绝对无法在一起的，所以他们升起了代表霍乱疫情的黄旗，决定永生航行在河中，在余生相互陪伴。在书的结尾，这无疑是浪漫的；但落回现实，航船始终要靠岸补给，两人的年纪也注定无法承受持续的航程，所以这种陪伴也只能说是作者给我们的慰藉而已。 非爱情部分 本书毫无疑问是一部爱情小说，人们谈论到它说得最多的话题也是爱情。但是在结束之际，我也想谈谈这本书里面那些和爱情无关的东西。比如书中无处不在的关于“内战”的描述，它像是这场爱情故事背后永久的背景音。马尔克斯以自己的国家哥伦比亚为背景，这个刚从殖民地独立出去的国家经历着持久的战乱和瘟疫： 内战旷日持久，女主在“气球旅行”中看到每个人“死于霍乱”的人脑后都有一个洞；旧贵族纷纷破产，当掉自己的贵重首饰，只在出席活动时短暂赎回维持体面；新兴的航运公司控制着货运，欧洲留学归来的精英倡导着潮流，中国人写出绝美的诗句却被质疑非议；环境恶臭不堪，城市的码头漂浮着无数动物的尸体、蛮横的开荒和狩猎让河流两岸寸草不生…… 爱情故事背后那些其他宏大的东西，似乎都想说又感觉什么都说不好。透过长达五十多年的恋爱故事，我看到的是上世纪初这个地球另一端南美国家的方方面面。这一切似乎很遥远，又似乎近在眼前，穿透一个世纪的时间，穿透整个地球，来到我的面前，不胜感激。","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"正则表达式入门视频笔记","date":"2023-01-10T04:00:00.000Z","path":"2023/01/10/正则/","text":"B站正则表达式入门视频笔记 正则表达式入门视频笔记 正则练习网址： https://www.codejiaonang.com/ 正则在线测试网站： https://regexr-cn.com/ 教程链接：https://www.bilibili.com/video/BV19t4y1y7q 正则表达式入门 一个应用例子：从html提取&lt;span&gt;内容、提取手机号 字符组 方括号：匹配中括号中出现的任意元素一次——[Py]yhon 方括号简化区间：横杠——[0-9]数字；[a-z]小写字母；[a-zA-Z]大小写字母 转义字符\\可以匹配特殊规定的字符-\\()[]等 ^代表取反——[\\^0-9]所有非数字 快捷方式 \\d——所有数字 \\w——所有数字+英文字母+_ \\s——空白：空格、tab、换行 \\b——单词边界 取反：大写字母即可 开始——^：在区间外面表示开始。放在正则开头，表示以匹配到内容开头的字符串 结束——$：放在正则结尾，表示以匹配到内容结尾的字符串 任意字符——.：不能匹配\\n 可选字符——?：放在末尾，表示可以出现可以不出现 可选任意字符——.? 匹配多个数据 重复次数——a{9}：大括号内部表示这个字符出现的次数 重复区间——{M,N}，M是下界而N是上界 正则表达式默认是贪婪模式，尽可能的匹配更多字符。取消贪婪模式，在表达式后面加上 ?——表示慵懒 开闭区间——闭区间不写即可表示匹配一个或无数个 +——{1,} *——{0,} 实践 ^0\\d{2}-?[1-9]\\d{6} ^王.+\\d{4} 总结 实例 描述 [Pp]ython 匹配 “Python” 或 “python”。 rub[ye] 匹配 “ruby” 或 “rube”。 [abcdef] 匹配中括号内的任意一个字母。 [0-9] 匹配任何数字。类似于 [0123456789]。 [a-z] 匹配任何小写字母。 [A-Z] 匹配任何大写字母。 [a-zA-Z0-9] 匹配任何字母及数字。 [^au] 除了au字母以外的所有字符。 [^0-9] 匹配除了数字外的字符。 实例 描述 . 匹配除 “” 之外的任何单个字符。要匹配包括 ‘’ 在内的任何字符，请使用象 ‘[.]’ 的模式。 ? 匹配一个字符零次或一次，另一个作用是非贪婪模式 + 匹配1次或多次 * 匹配0次或多次 \\b 匹配一个长度为0的子串 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ 。 \\S 匹配任何非空白字符。等价于 [^ 。 \\w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。 \\W 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]‘。 正则表达式进阶 分组、回溯和断言 分组 使用括号即可 分组有一个非常重要的功能——捕获数据 想要从匹配好的数据中提取关键数据的时候可以使用分组 (\\d{4})[\\-\\s]?(\\d{4})[\\-\\s]?(\\d{2})也可以 (\\d{4})[\\-\\/](\\d{1,2})[\\-\\/](\\d{1,2}) 或者条件：| 非捕获分组：(?:表达式) (?:\\d{2,5}|tel)[\\-:](\\d{5}) 回溯引用（重要）：() \\N 使用\\N可以引用编号为N的分组 这道题不太好做 (\\w{2,})\\1也可以 其他练习题 先行断言 断言又叫环视、预搜索 正向先行断言：(?=表达式) 不匹配断言内容，会匹配断言条件 从左往右看 表示满足条件 (?=.*?[a-z])(?=.*?[A-Z]).+匹配的字符串中必须包含至少一个大写和小写的字母。 反向先行断言：(?!表达式) 不匹配断言内容，会匹配断言条件 从左往右看 表示不满足条件 注意是从左往右看，所以需要加上开始判断。 &lt;(?!p)(?!/p).+&gt;也可以 后行断言 从右往左看 正向后行断言：(?&lt;=表达式) (?&lt;=王)\\S+更合适，非空名字 反向后行断言：(?&lt;!表达式) 注意如果中间不加非判断的话会匹配到两个中间的带$内容，所以要加上[^\\$]+ 其他练习题 这道题是真的麻烦，还有用反向后行断言判断左边不是三个$。 实践 使用开头和结尾即可，甚至不需要使用断言。","tags":[{"name":"正则","slug":"正则","permalink":"https://renzehua1998.github.io/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"【GitBranch】远程仓库高级操作","date":"2023-01-07T04:00:00.000Z","path":"2023/01/07/GitBranch-07远程仓库高级操作/","text":"git远程仓库的高级操作 推送主分支 将特性分支集成到 main 上 推送并更新远程分支 演示 快速的更新 main 分支并推送到远程：git pull --rebase; git push 练习 这里共有三个特性分支 —— side1 side2 和 side3 我需要将这三分支按顺序推送到远程仓库 因为远程仓库已经被更新过了，所以我们还要把那些工作合并过来 123456git fetchgit rebase o/main side1git rebase side1 side2git rebase side2 side3git rebase side3 maingit push 合并远程仓库 教学 rebase的优缺点： 优点：Rebase 使你的提交树变得很干净, 所有的提交都在一条线上 缺点：Rebase 修改了提交树的历史 练习 和上一题一样，不过不能用rebase，要用merge 1234567git fetchgit checkout maingit merge side1git merge o/maingit merge side2git merge side3git push 标准答案： 123456git checkout maingit pull origin maingit merge side1git merge side2git merge side3git push 远程追踪 pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。 push 操作时, 我们把工作从 main 推到远程仓库中的 main 分支(同时会更新远程分支 o/main) 。这个推送的目的地也是由这种关联确定的！ 教学 关联关系就是由分支的“remote tracking”属性决定的。main 被设定为跟踪 o/main —— 这意味着为 main 分支指定了推送的目的地以及拉取后合并的目标。 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了，会看到如下输出： local branch \"main\" set to track remote branch \"o/main\" 演示 自定义这个属性：可以让任意分支跟踪 o/main——两种方法 git checkout -b totallyNotMain o/main，新建分支让他追踪远程main分支 git checkout -b foo o/main; git pull：foo分支和远程main分支一致，而原来的main分支没变 git checkout -b foo o/main; git commit; git push：本地提交的foo分支被push到了远程的main git branch -u o/main foo：这样 foo 就会跟踪 o/main 了。如果当前就在 foo 分支上, 还可以省略 foo 实现的操作和上面的一样，只不过需要提前创建foo分支 练习 我们在不检出 main 分支的情况下将工作推送到的远程仓库中的 main 分支上 1234git checkout -b side o/main # git checkout -b side; git branch -u o/main sidegit commitgit pull --rebase # 注意顺序git push Git Push的参数 未指定参数时，通过当前检出分支的属性来确定远程仓库以及要 push 的目的地 教程 指定参数语法为：git push &lt;remote&gt; &lt;place&gt; 如：git push origin main切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。 因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性 演示 使用参数后不用考虑HEAD的指向（即当前检出状态） 练习 更新远程仓库中的 foo 和 main, 但是 git checkout 被禁用了 12git push origin maingit push origin foo Git Push的参数2 如果来源和去向分支的名称不同呢？比如你想把本地的 foo 分支推送到远程仓库中的 bar 分支。 教学 同时为源和目的地指定 &lt;place&gt;的话，只需要用冒号 : 将二者连起来就可以了： git push origin &lt;source&gt;:&lt;destination&gt; 演示 source 可以是任何 Git 能识别的位置 练习 12git push origin foo:maingit push origin main^:foo # git push origin HEAD^:foo Git Fetch的参数 git fetch 的参数和 git push 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传） 教学 1git fetch origin foo Git 会到远程仓库的 foo 分支上，然后获取所有本地不存在的提交，放到本地的 o/foo 上。 因为fetch不会更改本地分支，所以本地foo分支没有同步 直接&lt;source&gt;:&lt;destination&gt;的话，确实可以更新本地分支，但不能在当前检出分支上这么做，而且也没有必要，因为pull就是干这个的 source 现在指的是远程仓库中的位置，而 destination 才是要放置提交的本地仓库的位置。它与 git push 刚好相反 演示 一般没人这样做吧喂 如果本地没有bar分支，就会自己新建。和push一样，要是远程没有就新建。 如果 git fetch 没有参数，它会下载所有的提交记录到各个远程分支 练习 抓取目标窗口中指定的提交记录，使用这些魔幻的命令 1234git fetch origin foo:maingit fetch origin main^:foogit checkout foogit merge main 没有Source的Source* 教学 你可以在 git push 或 git fetch 时不指定任何 source，方法就是仅保留冒号和 destination 部分，source 部分留空。 git push origin :side git fetch origin :bugFix 演示 如果 push 空 到远程仓库它会删除远程仓库中的分支！ 如果 fetch 空 到本地，会在本地HEAD位置创建一个新分支 练习 删除一个远程的分支, 再用 git fetch 在本地创建一个新分支 12git fetch origin :bar # pull也是可以的git push origin :foo Git pull 参数 git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。 教学 以下命令在 Git 中是等效的: git pull origin foo 相当于： 1git fetch origin foo; git merge o/foo 还有... git pull origin bar~1:bugFix 相当于： 1git fetch origin bar~1:bugFix; git merge bugFix 演示 git pull 唯一关注的是提交最终合并到哪里（也就是为 git fetch 所提供的 destination 参数传递给merge， merge 到我们的检出位置，无论我们当前检出的位置是哪） pull 也可以用 source:destination 练习 按照目标窗口中的状态进行操作。你需要下载一些提交，然后创建一些新分支，再合并这些分支到其它分支 12git pull origin bar:foogit pull origin main:side Wow！你通关了！ (ﾉ^_^)ﾉ (ﾉ^_^)ﾉ (ﾉ^_^)ﾉ","tags":[{"name":"git","slug":"git","permalink":"https://renzehua1998.github.io/tags/git/"}]},{"title":"【GitBranch】远程仓库","date":"2023-01-06T04:00:00.000Z","path":"2023/01/06/GitBranch-06远程仓库/","text":"git远程仓库的基本使用 远程仓库只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更) Git Clone 演示 创建远程仓库的命令： git clone在本地创建一个远程仓库的拷贝 练习 用 git clone 复制下你的仓库 1git clone 远程分支 教学 在我们的本地仓库多了一个名为 o/main 的分支, 这种类型的分支就叫远程分支 远程分支反映了远程仓库(在你上次和它通信时)的状态。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步 远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。 命名规范： &lt;remote name&gt;/&lt;branch name&gt; 如果你看到一个名为 o/main 的分支，那么这个分支就叫 main，远程仓库的名称就是 o 使用真正的 Git 时, 你的远程仓库默认为 origin 演示 git checkout o/main; git commit Git 变成了分离 HEAD 状态，当添加新的提交时 o/main 也不会更新。这是因为 o/main 只有在远程仓库中相应的分支更新了以后才会更新。 练习 在 main 分支上做一次提交；然后检出 o/main，再做一提交。这有助于你理解远程分支的不同，他们的更新只是反映了远程的状态。 123git commitgit checkout o/maingit commit Git Fetch 从远程仓库获取数据 我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库。 演示 运行git fetch，远程最新提交被下载到本地，同时远程分支 o/main 也被更新 从远程仓库下载本地仓库中缺失的提交记录 更新远程分支指针(如 o/main) 远程分支反映了远程仓库在你最后一次与它通信时的状态，git fetch 就是你与远程仓库通信的方式了 不能做的事：不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。 练习 用 git fetch 下载所有的提交 1git fetch Git Pull 抓取更新再合并到本地分支 演示 git fetch; git merge o/main：先下载远程更新，再合并到当前分支 git pull 就是 git fetch 和 git merge 的缩写 练习 1git pull 模拟团队合作 “假装”你的同事、朋友、合作伙伴更新了远程仓库，有可能是某个特定的分支，或是几个提交记录 引入一个自造命令 git fakeTeamwork 演示 git fakeTeamwork 假装在远程新建一个提交 git fakeTeamwork foo 3 假装在远程foo分支新建三个提交 练习 克隆一个远程仓库（用 git clone），再在刚创建的远程仓库中模拟一些修改，然后在你自己的本地分支上做一些提交，再拉取远程仓库的变更。 1234git clonegit fakeTeamwork 2git commitgit pull Git Push 将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录 教程 git push 不带任何参数时的行为与 Git 的一个名为 push.default 的配置有关。它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 upstream。 在你的项目中进行推送之前，最好检查一下这个配置。 演示 git pull：把本地提交上传到远程仓库 我们的远程分支 (o/main) 也同样被更新了 练习 向远程仓库分享两个提交记录 123git commitgit commit git push 偏离的提交历史 push和pull的困难来自于远程库提交历史的偏离。 例子 假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。 此时是不允许push的 它会强制你先合并远程最新的代码，然后才能分享你的工作。 演示 git push 失效，因为远程仓库有未拉取到本地的提交 你需要做的就是使你的工作基于最新的远程分支——最直接的方法就是通过 rebase 调整你的工作 方法1： git fetch; git rebase o/main; git push 或 git pull --rebase; git push 方法2： git fetch; git merge o/main; git push 或git pull; git push 练习 克隆你的仓库 模拟一次远程提交（fakeTeamwork） 完成一次本地提交 用 rebase 发布你的工作 12345git clonegit fakeTeamworkgit commitgit pull --rebasegit push 锁定的main 大型项目中，main（master）分支被锁定保护，需要一些Pull Request流程来合并修改 教程 卡住原因： 远程服务器拒绝直接推送(push)提交到main, 因为策略配置要求 pull requests 来提交更新. 你应该按照流程,新建一个分支, 推送(push)这个分支并申请pull request,但是你忘记并直接提交给了main.现在你卡住并且无法推送你的更新. 解决办法： 新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题. 练习 1234git branch featuregit reset HEAD^git checkout featuregit push 标准答案： 123git reset --hard o/mastergit checkout -b feature C2git push origin feature git push 后接的参数，第一个为远程仓库名（默认为origin），第二个为分支名（默认为当前HEAD指向的） 补充 参考 1、git reset --hard 重置stage区和工作目录里的内容，就是你的没有commit的修改会被全部擦掉 2、git reset --soft reset --soft：用于版本的回退，只进行对commit操作的回退，不影响工作区的文件。 在提交代码的时候，commit之后，然后我又在工作区添加了东西，这时候突然发现，上一次的commit有错误的文件，需要重新修改，但是我添加的东西友不想丢失，而且我想修改上一次的提交，这时候可进行git reset --soft 版本号 3、git reset --mixed reset 不加参数(mixed)：保留工作目录，并清空暂存区","tags":[{"name":"git","slug":"git","permalink":"https://renzehua1998.github.io/tags/git/"}]},{"title":"【GitBranch】高级话题","date":"2023-01-05T04:00:00.000Z","path":"2023/01/05/GitBranch-05高级话题/","text":"git的高级话题 多分支 rebase 练习 我们准备了很多分支！咱们把这些分支 rebase 到 main 上吧。 你的领导给你提了点要求 —— 他们希望得到有序的提交历史，也就是我们最终的结果应该是 C6' 在 C7' 上面， C5' 在 C6' 上面，依此类推。 ——本关不允许使用cherry-pick 1234git rebase main bugFixgit rebase bugFix sidegit rebase side anothergit branch -f main 两个父节点 教学 操作符 ^ 与 ~ 符一样，后面也可以跟一个数字。 作用是指定合并提交记录的某个父提交 Git 默认选择合并提交的“第一个”父提交 添加数字可以选择切换到第几个父提交上 演示 操作符支持链式操作 练习 在指定的目标位置创建一个新的分支，要求你使用刚刚讲到的相对引用修饰符 123456git checkout HEAD^^2~git branch bugWorkgit checkout main# 或者一句解决git branch bugWork HEAD~^2^ 纠缠不清的分支 练习 现在我们的 main 分支是比 one、two 和 three 要多几个提交。出于某种原因，我们需要把 main 分支上最近的几次提交做不同的调整后，分别添加到各个的分支上。 one 需要重新排序并删除 C5，two 仅需要重排排序，而 three 只需要提交一次。 12345678910# 强制移动分支指针到指定位置git branch -f three HEAD~3git branch -f one HEADgit branch -f two HEAD# 拖动修改one分支git checkout onegit rebase -i HEAD~4 # 修改成指定样子# 拖动修改two分支git checkout onegit rebase -i HEAD~4 # 修改成指定样子 标准答案：使用cherry-pick 12345git checkout onegit cherry-pick c4 c3 c2git checkout twogit cherry-pick c5 c4 c3 c2git branch -f three c2","tags":[{"name":"git","slug":"git","permalink":"https://renzehua1998.github.io/tags/git/"}]},{"title":"【GitBranch】杂项","date":"2023-01-04T04:00:00.000Z","path":"2023/01/04/GitBranch-04杂项/","text":"git杂项 只取一个提交记录 不保留分支中的某些提交记录（日志打印等调试语句） 教学 使用git rebase -i 或 git cherry-pick即可 练习 确保 main 分支能得到 bugFix 分支上的相关提交 方法1： 12git checkout maingit cherry-pick C4 方法2： 1git rebase -i HEAD~3 12git checkout maingit rebase bugFix 提交的技巧1 对某个以前的提交记录进行一些小小的调整 教学 一种思路： 先用 git rebase -i 将提交重新排序，然后把我们想要修改的提交记录挪到最前 然后用 git commit --amend 来进行一些小修改 接着再用 git rebase -i 来将他们调回原来的顺序 最后我们把 main 移到修改的最前端（用你自己喜欢的方法） ——对于 ' 的数量上的不同，并不纳入对比范围内 git commit --amend ：对上一次提交有修改，可以修改文件也可以修改说明，不产生新的commit 练习 12345678git rebase -i HEAD~2 # 交换caption分支的C2和C3git commit --amend # 重新提交C2git rebase -i HEAD~2 # 交换caption分支的C3和C2git branch -f main # 更新main分支到最新，空白默认为当前HEAD# 或git checkout main # 切换到main分支git rebase caption # 更新main分支到最新caption ——本关不允许使用cherry-pick，否则的话直接 123456789git checkout main# 可以达到main分支要求git cherry-pick C2 C3# 达到修改C2提交的要求git cherry-pick C2git commit --amendgit cherry-pick C3 提交的技巧2 上一关进行了两次排序，而这有可能造成由 rebase 而导致的冲突 演示 cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上（只要不是 HEAD 上游的提交就没问题） 练习 通过 --amend 改变提交记录 C2，但你不能用 rebase -i Git Tags 分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。 有没有什么可以永远指向某个提交记录的标识？ 教学 Git 的 tag 可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。 它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。——在tag上进行新git commit --amend会创建新分支。 演示 git tag v1 C1：我们将这个标签命名为 v1，并且明确地让它指向提交记录 C1，如果你不指定提交记录，Git 会用 HEAD 所指向的位置。 练习 按照目标建立两个标签，然后切换到 v1 上面，要注意你会进到分离 HEAD 的状态 —— 这是因为不能直接在v1 上面做 commit。 123git tag v0 C1git tag v1 C2git checkout v1 Git Describe 用来描述离你最近的锚点（也就是标签） 教学 场景：当你用 git bisect（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。 语法是：git describe &lt;ref&gt; &lt;ref&gt; 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD） 输出结果为：&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt; tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。 当 ref 提交记录上有某个标签时，则只输出标签名称 演示 git tag v2 C3打好标记 git describe main输出：v1_2_gC2 git describe side输出：v2_1_gC4 练习 随意指定几个位置来查看即可 都是往上找标签的 随意提交就可以过关","tags":[{"name":"git","slug":"git","permalink":"https://renzehua1998.github.io/tags/git/"}]},{"title":"【GitBranch】移动提交记录","date":"2023-01-03T04:00:00.000Z","path":"2023/01/03/GitBranch-03移动提交记录/","text":"git移动提交记录 整理提交记录——把某个提交放到指定位置 Git Cherry-pick 教学 git cherry-pick &lt;提交号&gt;...：将一些提交复制到当前所在的位置（HEAD）下面 演示 git cherry-pick C2 C4：把这两个提交复制到当前HEAD的下面，可以跳记录 练习 将三个分支中的提交记录复制到 main 上 1git cherry-pick C3 C4 C7 交互式 rebase 不清楚你想要的提交记录的哈希值时 ——交互式rebase：从一系列的提交记录中找到想要的记录 教学 交互式 rebase 指的是使用带参数 --interactive 的 rebase 命令, 简写为 -i 如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。 在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。 当 rebase UI界面打开时, 你能做3件事: 调整提交记录的顺序（通过鼠标拖放来完成） 删除你不想要的提交（通过切换 pick 的状态来完成，关闭就意味着你不想要这个提交记录） 合并提交，它允许你把多个提交记录合并成一个。（本课程不支持） 演示 git rebase -i HEAD~4：把当前HEAD指针往上（包括当前）的四个提交提取出来，进行排序、删除等操作，结束后返回想要调整的顺序 练习 做一次交互式的 rebase，整理成目标窗口中的提交顺序。 1git rebase -i HEAD~4 打开窗口后拖动成要求状态","tags":[{"name":"git","slug":"git","permalink":"https://renzehua1998.github.io/tags/git/"}]},{"title":"【GitBranch】高级篇","date":"2023-01-02T04:00:00.000Z","path":"2023/01/02/GitBranch-02高级篇/","text":"git的高级操作 分离 HEAD 学习在项目的提交树上前后移动的几种方法 教学 HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。 HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。 HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。 演示 git checkout C1; git checkout main; git commit; git checkout C2 HEAD 指向了 main，随着提交向前移动。 注意这部分代码并不是真的在查看 HEAD 指向。 如果想看 HEAD 指向，可以通过 cat .git/HEAD 查看， 如果 HEAD 指向的是一个引用，还可以用 git symbolic-ref HEAD 查看它的指向。 分离头指针HEAD：让其指向了某个具体的提交记录而不是分支名。 刚开始指向HEAD -&gt; main -&gt; C1 git checkout C1 变成了HEAD -&gt; C1 这就是译者注里面说的不是真正的查看HEAD指向 练习 从 bugFix 分支中分离出 HEAD 并让其指向一个提交记录。 ——通过哈希值指定提交记录。每个提交记录的哈希值显示在代表提交记录的圆圈中。（C1C2之类的） 1git checkout C4 相对引用1（^） 教学 实际中提交并非C1C2……而是一串哈希值（40位）。只需要提供能够唯一标识提交记录的前几个字符即可 但这样还是很不方便，使用相对引用可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。 使用 ^ 向上移动 1 个提交记录 使用 ~&lt;num&gt; 向上移动多个提交记录，如 ~3 演示 main^ 是 main 的父节点，main^^ 是 main 的第二个父节点 git checkout main^ ——切换到当前main分支提交的父节点 也可以将 HEAD 作为相对引用的参照：git checkout C3; git checkout HEAD^; git checkout HEAD^; git checkout HEAD^——一直使用HEAD向上移动 练习 切换到 bugFix 的父节点。这会进入分离 HEAD 状态。 1git checkout bugFix^ 相对引用2（~） 教学 该操作符后面可以跟一个数字（可选，不跟数字时与 ^ 相同，向上移动一次），指定向上移动多少次。 演示 后退四步 连续向上后退四个：git checkout HEAD~4 直接使用 -f 选项让分支指向另一个提交 git branch -f main HEAD~3 将 main 分支强制指向 HEAD 的第 3 级父提交。 练习 移动 HEAD，main 和 bugFix 到目标所示的位置 这一关至少要用到一次直接引用 (即哈希值) 123git checkout HEAD^git branch -f main C6git branch -f bugFix bugFix~3 撤销变更 教学 撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。 主要有两种方法用来撤销变更 —— 一是 git reset，还有就是 git revert。 演示 Git Reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。 git reset HEAD~1：把 main 分支移回到 C1；现在本地代码库根本就不知道有 C2 这个提交了。 这种“改写历史”的方法对大家一起使用的远程分支是无效的 Git Revert 撤销更改并分享给别人 git revert HEAD：要撤销的提交记录C2后面多了一个新提交C2' 新提交记录 C2' 引入了更改 —— 这些更改刚好是用来撤销 C2 这个提交的。 也就是说 C2' 的状态与 C1 是相同的。 练习 分别撤销 local 分支和 pushed 分支上的最近一次提交。共需要撤销两个提交（每个分支一个）。 记住 pushed 是远程分支，local 是本地分支 123git reset HEAD^git checkout pushedgit revert HEAD","tags":[{"name":"git","slug":"git","permalink":"https://renzehua1998.github.io/tags/git/"}]},{"title":"【GitBranch】基础篇","date":"2023-01-01T04:00:00.000Z","path":"2023/01/01/GitBranch-01基础篇/","text":"git的简单使用 Git Commit 教学 Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！ Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。 Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因 —— 我们会在图示中用箭头来表示这种关系。对于项目组的成员来说，维护提交历史对大家都有好处。 关于提交记录太深入的东西咱们就不再继续探讨了，现在你可以把提交记录看作是项目的快照。提交记录非常轻量，可以快速地在这些提交记录之间切换！ 演示 使用 git commit 创建一条新的提交记录，把当前节点作为父节点，新生成的子节点放到后面。 练习 创建两个提交 提交两次即可 12git commitgit commit Git Branch 教学 Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂： 早建分支！多用分支！ 这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。 在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“我想基于这个提交以及它所有的父提交进行新的工作。” 演示 使用 git branch newImage 创建一个新分支 使用 git commit 创建一条新的提交记录 main分支前进了，newImage分支没动，这是因为当前还在main（后面有星号） 切换到新分支 git checkout &lt;name&gt; ，再进行提交 Git 2.23 版本中，引入了一个名为 git switch 的新命令，最终会取代 git checkout，因为 checkout 作为单个命令有点超载（它承载了很多独立的功能）。 创建的同时切换：git checkout -b &lt;your-branch-name&gt; 练习 创建一个名为 bugFix 的新分支，然后切换过去。 123git branch bugFixgit checkout bugFix# git switch bugFix 或： 1git chechout -b bugFix Git Merge 教学 新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。——方法1 在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。” 演示 要把 bugFix 合并到 main 里（当前在main分支） git merge bugFix：main 现在指向了一个拥有两个父节点的提交记录 从 main 开始沿着箭头向上看，在到达起点的路上会经过所有的提交记录。这意味着 main 包含了对代码库的所有修改。 再把 main 分支合并到 bugFix git checkout bugFix; git merge main：把 bugFix 移动到 main 所指向的那个提交记录 练习 创建新分支 bugFix 用 git checkout bugFix 命令切换到该分支 提交一次 用 git checkout main 切换回 main 再提交一次 用 git merge 把 bugFix 合并到 main 123456git branch bugFixgit checkout bugFixgit commitgit checkout maingit commitgit merge bugFix Git Rebase 教学 新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。——方法2 取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。 优势就是可以创造更线性的提交历史，如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。 演示 把 bugFix 分支里的工作直接移到 main 分支上。移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的。 git rebase main，bugFix 分支上的工作在 main 的最顶端，同时我们也得到了一个更线性的提交序列。 提交记录 C3 依然存在（树上那个半透明的节点），而 C3' 是我们 Rebase 到 main 分支上的 C3 的副本。 支持两个参数，前一个参数是插入的父节点，后一个参数是最新分支 再切换到main分支运行git rebase bugFix，此时两个分支处在同一顶点上，不会有分叉记录 练习 新建并切换到 bugFix 分支 提交一次 切换回 main 分支再提交一次 再次切换到 bugFix 分支，rebase 到 main 上 123456git checkout -b bugFixgit commitgit checkout maingit commitgit checkout bugFixgit rebase main","tags":[{"name":"git","slug":"git","permalink":"https://renzehua1998.github.io/tags/git/"}]},{"title":"【GitBranch】简介","date":"2023-01-01T02:00:00.000Z","path":"2023/01/01/GitBranch-README/","text":"Learn Git Branching 在线学习地址：https://pcottle.github.io/learnGitBranching/ 仓库地址：https://github.com/pcottle/learnGitBranching 1234567891011levels # 返回选择题目level &lt;name&gt; # 跳转到指定题目objective # 打开目标描述窗口show goal # 打开目标图示窗口hide goal # 隐藏目标图示窗口show solution # 查看答案hint # 进行提示undo # 撤销reset # 返回初始状态delay 2000 # 延时2秒help # 弹出帮助窗口","tags":[{"name":"git","slug":"git","permalink":"https://renzehua1998.github.io/tags/git/"}]},{"title":"Neo4j B站教程笔记","date":"2022-10-01T04:00:00.000Z","path":"2022/10/01/Neo4jB站教程笔记/","text":"Neo4j简单使用指南 Neo4j B站教程笔记 绪论：基于图的关系数据库 简介 环境搭建 CQL语法 与SpringBoot结合 简介 图数据库定义 应用场景：海量复杂关系数据的运算、存储 NoSQL数据库，基于图构成的（graph）——包含大量的结构化，半结构化和非结构化的连接数据 分类： 键值(key/value)数据库（查找块；无结构） 列存储数据库（查找快、扩展方便；功能受限） 文档型数据库（数据结构要求不严格；难以查找） 图数据库（允许图算法；有时会涉及整个图不便于分布式存储） 对比： 关系型数据库中不同表使用外键进行关联 图数据库中使用点和边建立关系，无需join操作 Neo4j优势 最先进的图数据库之一 属性图模型（Property graph model） 专属查询语言 Cypher ——有很多优点 数据模型 图论基础：节点和边——实体和关系 属性图模型：实体和关系都有属性，属性使用键值对表示 label：支持多标签（多种身份） 关系：单向、双向 属性：键值对，可以被索引和约束 Neo4j Browser： 浏览器控制台，可以通过Neo4j、bolt等协议连接数据库，web端口默认7474，数据库服务端口7687 使用场景 欺诈检测 实时推荐引擎 知识图谱 主数据管理 供应链管理 网络运营 身份访问管理 …… 环境搭建 https://neo4j.com/download-center/ 企业版：分布式收费 社区版：Win+Linux，解压即可使用（注意版本）——4.0以上版本要保证JVM环境是jdk11 desktop 社区版Windows安装 Windows下解压到某个文件夹下即可：路径不能有中文 ——bin中有运行脚本、CQL语句脚本；certificates里是身份认证；config配置；data数据文件；import导入csv utf-8文件；lib一些jar包；logs日志；plugins一些插件；run运行。 在对应目录下执行 1234# 将Neo4j作为控制台应用程序运行 &lt;NEO4J_HOME&gt;\\bin\\neo4j console # 将Neo4j作为服务使用进行安装 &lt;NEO4J_HOME&gt;\\bin\\neo4j install-service console: 直接启动 neo4j 服务器 install-service | uninstall-service | update-service ： 安装/卸载/更新 neo4j 服务 start/stop/restart/status: 启动/停止/重启/状态 -V 输出更多信息 注：data里面有store_lock，数据锁，保证使用中无法对数据进行操作 第一次需要更改密码 刚进去是一个入门手册，可以运行一下命令进行学习 每次节点id自动分配，支持重复数据，也可以自己去重（建立唯一标识） 社区版docker安装 注意对端口的开放暴露 7474 for HTTP. web 7473 for HTTPS. 7687 for Bolt. 连接 拉取镜像 12docker pull neo4j:3.5.22-community # 旧版docker pull neo4j:4.4.11-community # 最新版 执行镜像命令 1234567docker run -d -p 7474:7474 -p 7687:7687 --name neo4j \\ -e \"NEO4J_AUTH=neo4j/123456\" \\ # 指定密码 -v /usr/local/soft/neo4j/data:/data \\ # 指定挂载位置 -v /usr/local/soft/neo4j/logs:/logs \\ -v /usr/local/soft/neo4j/conf:/var/lib/neo4j/conf \\ -v /usr/local/soft/neo4j/import:/var/lib/neo4j/import \\neo4j:4.4.11-community # 指定版本号 Desktop安装 官网下载对应版本 下载完成后会提供校验码，傻瓜式安装 封装到客户端里面，可以自定义创建版本 支持连接远程服务 指定对应版本环境start，同样的使用方法 CQL 简介 Cypher语言，Cypher Query Language。专用查询语言、声明性模式匹配、SQL语法、简单可读 CQL命令 用法 CREATE 创建节点，关系和属性 MATCH 检索有关节点，关系和属性数据 RETURN 返回查询结果 WHERE 提供条件过滤检索数据 DELETE 删除节点和关系 REMOVE 删除节点和关系的属性 ORDER BY 排序检索数据 SET 添加或更新标签 小括号()表示节点，箭头-&gt;&lt;-表示关系（带方向），[:]表示标签 注意事项：使用中输入命令按shift+enter才能换行，Enter就会直接运行 常用命令 官方文档 主要语法： 1%名称:%标签 {%属性名:'%属性值'} LOAD CSV：必须在指定目录下 1234// 在%NEO4J_HOME%\\import目录load csv from 'file:///西游记.csv' as linecreate (:西游 {name:line[0],tail:line[1],label:line[3]})// (名称-一般为n:标签 {属性}) CREATE创建 CQL中节点的名称不能相同，如m，n 12345678910111213141516171819//创建简单节点create (n)//创建多个节点create (n),(m)//创建带标签和属性的节点并返回节点create (n:person {name:'如来'}) return n//使用新节点创建关系CREATE (n:person {name:'杨戬'})-[r:师傅]-&gt;(m:person {name:'玉鼎真人'}) returntype(r)//使用已知节点创建带属性的关系match (n:person {name:'沙僧'}),(m:person{name:'唐僧'})create (n)-[r:`师傅`{relation:'师傅'}]-&gt;(m) return r// 检索关系节点的详细信息match (n:person)-[r]-(m:person) return n,m// 创建全路径create p=(:person{name:'蛟魔王'})-[:义兄]-&gt;(:person{name:'牛魔王'})&lt;-[:义兄]-(:person {name:'鹏魔王'}) return p 节点间关系使用()-[]-&gt;()表示 MATCH查询：用于声明待匹配相应节点，可以指定标签（:后面带标签），可以指定属性（用{}括住键值对） 匹配一个节点的全部相关内容，使用match p=()-[]-&gt;()形式返回p即可 RETURN返回：加入return才会显示在屏幕上，可以返回标签、属性——属性使用n.name，id使用id(n) WHERE子句：用于过滤MATCH的结果，使用and、or等关键字 DELETE删除：用于删除节点和关系，有关系要先删除关系 REMOVE删除：用于删除节点和关系的属性、标签 1234567//删除属性MATCH (n:role {name:\"fox\"}) remove n.age return n//创建节点CREATE (m:role:person {name:\"fox666\"})//删除标签match (m:role:person {name:\"fox666\"}) remove m:person return m SET子句：向现有节点或关系添加新属性，更新属性值（使用%属性名.%属性值=%设置值） 1MATCH (n:role {name:\"fox\"}) set n.age=32 return n ORDER BY排序：后加排序参考，默认升序，可以加DESC子句降序排序（在后面加上即可） UNION子句： 123456MATCH (n:role) RETURN n.name as nameUNIONMATCH (m:person) RETURN m.name as nameMATCH (n:role) RETURN n.name as nameUNION allMATCH (m:person) RETURN m.name as name UNION：公共行组合并返回到一组结果中，名称必须匹配（列名称应该相同，列的数据类型应该相同——可以使用 as 子句进行重命名）不重复 UNION ALL：重复、名称必须匹配 LIMIT和SKIP子句：返回前几行，跳过前几行 NULL值：未定义值 IN操作符：用于提供值的集合——使用中括号 12match (n:`西游`) where n.name in['孙悟空','唐僧'] returnid(n),n.name,n.tail,n.label INDEX索引：提供属性上的索引，以提高应用程序的性能 ——为具有相同标签名称的所有节点的属性创建索引 1234// 创建索引create index on :`西游` (name)// 删除索引drop index on :`西游` (name) UNIQUE约束：创建唯一约束，不可以有相同的属性避免重复 1234//创建唯一约束create constraint on (n:xiyou) assert n.name is unique//删除唯一约束drop constraint on (n:xiyou) assert n.name is unique DISTINCT关键字：去重 用法：return distinct(n.name) 其他命令可以自己在网站看下（待续） 常用函数 字符串函数：upper、lower、replace、substring 聚合：count、max、min、sum、avg 关系函数：startnode、endnode、id、type neo4j-admin 都要先关闭服务！ 数据库备份： 123456cd %NEO4J_HOME%/binneo4j install-service//关闭neo4jneo4j stop//备份neo4j-admin dump --database=graph.db --to=/neo4j/backup/graph_backup.dump 数据库恢复： 12345//数据导入neo4j-admin load --from=/neo4j/backup/graph_backup.dump --database=graph.db --force//重启服务neo4j start","tags":[{"name":"图数据库","slug":"图数据库","permalink":"https://renzehua1998.github.io/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"图数据库介绍","date":"2022-10-01T03:00:00.000Z","path":"2022/10/01/tigergraph-图数据库介绍/","text":"图数据库基本应用简介 图数据库介绍 图的概念 顶点+边：G=(V,E) 分类：（三种范式） 超图（Hyper Graph）、属性图（Property Graph）、三元组（RDF） 超图：实体通过超边相连，一条超边对应一类关系 属性图：每个实体，所有关系都有自己的属性 三元组（资源描述框架）：资源信息、属性、属性值 图数据库使用的图模型——属性图 节点（vertex）：实体/实例，用标签（label）表示其类型 边（edge）：两实体的关系，源+目标，关系类型（type）表明其类型 属性（properties）：键值对，描述节点和边的属性信息 图数据库vs.关系型数据库 1. 对比 关系型数据库 图数据库 存储模型 用二维表存储实体与关系信息 用点与边的集合存储实体与关系信息 查询模型 基于扫描行、过滤行与聚合 基于点边组成路径的遍历与中间计算 分析类型 适用于简单数据查找与描述性统计 适用于关联分析与预测性分析 实时查询 物理隔离的表建立关联较慢 基于图结构的存储，关联扩展响应极快 2. 实例 ——资金流从嫌疑账户开始，经过多个账户中转，最后如何回流到本身账户 关系型数据库：需要结合大量业务规则和算法模型来实现；很难或者无法通过SQL直接实现业务查询需求，经常涉及多度表关联操作 图数据库：过简单自然的建模与直接的图查询语句，更符合人类直觉；可快速的开发出图查询代码；可为下游模型提供优质的特征数据。 发展 发展流行趋势迅猛 学术界研究从2018年开始暴涨 工业界许多图数据库解决方案 产品分类 运营模式 企业版：性能高、稳定；采购成本高 开源社区：成本低、定制化开发；维护难度大 云服务：依托第三方云 面向场景 操作型：企业级事务应用程序 知识图谱（RDF）：RDF知识图谱 多模态图：针对相同数据运行不同类型的查询——图查询、键值对查询 分析图：完全面向批处理的计算平台，集成各种算法 产品定位 图计算系统 OLAP：侧重计算、不能实时更新，适用于实时性要求不高、数据量大场景 图数据库 OLTP：图存储计算、实时查询、更新，适用于实时性要求高、逻辑计算简单场景 架构 开发流程： 定义图模式 ——业务访谈/数据梳理 加载数据——数据抽取/转换/映射 创建查询——图规则/算法开发 测试查询——查询测试/调优 服务上线——生产上线 技术架构： 图查询的概念及应用 图查询概念 场景：多张数据表之间有多个不同的关联键，常常需要使用多张表的信息进行复杂关联。 特点：会用到多次、甚至未知次数的表联接，甚至可能有环路问题。 问题：增加了数据分析人员的SQL代码开发难度以及对规则逻辑的理解难度，还会大量消耗数据库的计算资源。 图优势：用图查询去访问图数据库中的数据，不论是可视化探索还是代码开发，都更符合人类的直觉，减少了开发难度和逻辑复杂度，并且响应速度大大加快。 关系数据库：两步表关联；图数据库：给出一条路径即可 本质：在图数据库中，给定搜索的规则（Rule）和模式（Pattern），去访问图数据库中的点、边信息，包括结构信息、属性信息、路径信息等等。 规则和模式：深度优先遍历、广度优先遍历、给定元路径进行搜索、给定环路结构进行搜索等等。 图查询应用 搜索个贷失联客户 场景：信贷不良资产的处置，寻找客户——借由寻找其亲属或其他关联人来找到失联人。 问题：关联人信息往往储存在数据仓库的不同表中，较为隐蔽、结构各异、难以汇总。 解决：图数据库中寻找 搜索企业交易上下游 场景：某一企业的上下游交易流水，清楚的反应了该企业以及所在产业链的现状及发展趋势，可为银行的业务决策、贷前营销、客户拓展、信用评估和风险识别预警等提供数据支持。 问题：产业链上存在着行业跨度大，多链路交错的复杂网络特性，不易从中快速有效地获得某企业上下游关联交易信息。并且，基于交易明细表的多次自关联操作耗时巨大、逻辑复杂。 解决：使用图查询，更符合人类直觉 企业股权穿透探索 场景：随着企业集团化、家族化、多元化发展，单一企业通过资本运作组建成商业帝国；各类资本系内部股权不透明，隐形股东和股权代持现象频繁发生，主要股东、控股股东、实际控制人、一致 行动人、最终受益人不明晰；企业与股东个人、企业与企业之间的关系与交互影响愈加复杂，单个客户信用风险的爆发有可能引发整个关联客群的风险。","tags":[{"name":"图数据库","slug":"图数据库","permalink":"https://renzehua1998.github.io/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"图数据库初探","date":"2022-10-01T02:00:00.000Z","path":"2022/10/01/图数据库初探/","text":"图数据库基本类别简介 参考文档1 参考文档2 NoSQL数据库 出现原因：关系型数据库不再适用——数据建模中的一些缺陷和问题，以及在大数据量和多服务器之上进行水平伸缩的限制 分类： 键-值存储库（Key-Value-stores）; BigTable实现（BigTable-implementations）; 文档库（Document-stores）; 图形数据库（Graph Database）; 图数据库从最近十年的表现来看已经成为关注度最高，也是发展趋势最明显的数据库类型 图数据库的优势 一个场景：好友推荐 关系型数据库设计多次甚至无限次表格关联操作，复杂度难以想象。将其转换为图模型，使用深度优先、广度优先、迪杰斯特拉等算法可以很快地找到对应内容。 常见图数据库 图数据库排名 Neo4j 历史悠久且长期处于图数据库领域的主力地位，其功能强大，性能也不错，单节点的服务器可承载上亿级的节点和关系。社区版最多支持 320 亿个节点、320 亿个关系和 640 亿个属性。 优点：有自己的后端存储，不必如同JanusGraph等一样还要依赖另外的数据库存储。 Neo4j在每个节点中存储了每个边的指针，因而遍历时效率相当高。 缺点：企业版付费。开源的社区版本只支持单机，不支持分布式。社区版只能部署成单实例，企业版可以部署成高可用集群，从而可以解决高并发量的问题；不能做集群，单个实例故障时影响系统正常运行。社区版只支持冷备份，即需要停止服务后才能进行备份。 社区版开源、企业版闭源 JanusGraph 可扩展的图数据库，底层依赖于大数据组件，对分布式支持的非常好，也都是完全的开源免费，存储数据模型也都是专为图数据而设计。 优点：和大数据生态结合的非常好，可以很好地和Spark结合做一些大型的图计算。所以可以很好的和spark的大数据平台进行结合，并且能够支持实时图遍历和分析查询。 缺点：依赖太多，想要搭建一套完整的JanusGraph，需要同时搭建维护好几套系统，维护成本非常大。稳定性也不太好。并且三方的一些工具也存在一些问题，所以要用肯定要基于底层（读写）进行性能优化。 开源 HugeGraph 百度基于JanusGraph开源了HugeGraph，增加了很多特性，提高了易用性及性能，增加了一些图分析算法。 优点：可以与Spark GraphX进行链接，借助Spark GraphX图分析算法对HugeGraph的数据进行分析挖掘。HugeGraph还针对图数据库的高频应用做了特定性能优化，并且为用户提供更为高效的使用体验。 缺点：基于JanusGraph开源，存在和JanusGraph同样的问题，维护成本高。 开源 Dgraph 基于 golang 开发的开源的分布式图数据库。诞生时间不长, 发展却很迅速，从设计之初就考虑了分布式和扩展性，所以对分布式支持的非常好。 优点：不依赖与任何第三方系统，会自动组成集群，运维部署非常简单。维护成本低很多。和 JanusGraph 性能差不多，但复杂查询下，Dgraph 性能远高于 JanusGraph。同时写入性能也整体高于 JanusGraph。 缺点：还不支持多重边、一个集群只支持一个图、与大数据生态兼容不足，这些都需要靠后期不断完善。 开源 TigerGraph TigerGraph是一个目前业界先进的企业级图数据库。系统完全闭源。部分查询算法开源。分为开发版和企业版。开发版免费，但功能受限，比如单点只能构建一个图。企业面收费，支持大规模集群，顶点表数量不受限制。 优点：TigerGraph可以通过GSQL实现类存储过程的算法封装，而且已经实现了很多图算法，但是语法结构要比Neo4j复杂的多。 缺点：付费图数据库。Neo4j按照cpu收费，TigerGraph按照数据容量（G）来收费，费用较贵。 完全闭源，开发版免费，企业版很贵 对比表格","tags":[{"name":"图数据库","slug":"图数据库","permalink":"https://renzehua1998.github.io/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"网信柏鹭杯WP","date":"2022-09-15T04:00:00.000Z","path":"2022/09/15/飞飞战队/","text":"研二网信柏鹭杯比赛WP（菜） 网信柏鹭杯WP BY 飞飞战队 加解密 crypto1 混合编码 题目密码： 14d7a637a5a444d794d7a6730597a63344d6a51334e4463794e574d7a5a5463774d6a63304f5452694d6a457a4d44597a4e7a417a4e5449324e445579596a59324d324d304d5451304d7a4133597a4d334d7a51324d6a5a6d4e3251324e4451784d3259794e4463334e4455324f4449794e4755253344 观察密码结构，发现数字为0-9，字母为a-f，猜测是16进制hex编码 解码结果为： 1MzczZDMyMzg0Yzc4MjQ3NDcyNWMzZTcwMjc0OTRiMjEzMDYzNzAzNTI2NDUyYjY2M2M0MTQ0MzA3YzM3MzQ2MjZmN2Q2NDQxM2YyNDc3NDU2ODIyNGU%3D 结尾出现了%3D，这在url编码中代表=，这让我想起了base64 先用url解码将最后的%3D换成=，再用base64解码： 1373d32384c782474725c3e7027494b213063703526452b663c4144307c3734626f7d64413f24774568224e 又是16进制hex编码的结构，再次使用hex进行解码： 17=28Lx$tr\\&gt;p'IK!0cp5&amp;E+f&lt;AD0|74bo}dA?$wEh\"N 全过程如下： 这又是一串乱码，观察到7=28的ASCII码值为：55、61、50、56 而flag的标准格式：flag{--内容}前4个字符flag的ASCII码值为：102、108、97、103 不难发现它们相差47，于是进行编码： 12345orig = '7=28Lx$tr\\\\&gt;p\\'IK!0cp5&amp;E+f&lt;AD0|74bo}dA?$wEh\\\"N'val = ''for ch in orig: val += chr((128 + ord(ch) + 47) % 128)print(val) 结果为： 1flag{(S$\" m VxzP_\u0013 dUtZ\u0016kps_,fc\u0012\u001f-\u0014pnS't\u0018Q} 存在乱码字符，进一步观察发现，所有密文ASCII值+47大于127的字符，转换前的字符ASCII值应当减47，并不是一味地加47，于是修改编码： 12345678orig = '7=28Lx$tr\\\\&gt;p\\'IK!0cp5&amp;E+f&lt;AD0|74bo}dA?$wEh\\\"N'val = ''for ch in orig: if ord(ch) + 47 &gt; 127: val += chr(ord(ch) - 47) else: val += chr(ord(ch) + 47)print(val) 得到falg： 1flag{ISEC-mAVxzP_4AdUtZ7kps_Mfc3@N5pnSHt9Q} crypto2 RSA 题目： 1234567891011121314151617181920from Crypto.Util.number import isPrime, getStrongPrimefrom gmpy2 import next_primefrom secret import flag2p = getStrongPrime(1024)q = next_prime(p ^ ((1&lt;&lt;1024)-1))n = p * qe = 65537 # Encryptionm = int(flag2.encode('hex'),16)assert m &lt; nc = pow(m, e, n) print('n = {}'.format(hex(n)))#n = 0x31e22a7a2c5ec946692357dc51014a80530afeb46f419831fcbd896aa1d5cee2d0c69123b3017067afdb3d82b2be3535aebdf11da0fa2b4873233bae6af8a1c2a9344b6f64ade1c6c48a2828130c352053e1729b850774589e8947c8c0a472a8dc90caa542da5cec7f5fa7581747dcb558300437c30b016f769d4a85af8584f311dfb2f9e87fa7d16eaccb0303ecba491619ec7dda72e4037d96c607e666eced582d6eb2c232689fce1c08a54b80cf6d39ef1f2b467d970998c6d54d1779979c89a3b301cd1435bde8787d1141c912cf32b56610fba9205c6e86fefc490c8b2e06f5ed9f775f5b0fe945fa9fca3fc217b4c9dcd4b26676f576d0273b79417b81print('c = {}'.format(hex(c)))#c = 0x118dd8ab5df8685c5db5b1242896df41e8e9016f5f16276b6d311b29f0e5f9315530574b51c6e7c82d0c88ab92787d639443b921a452c850db580256ccfd55ee52ea9732821525da1d21351acb230a799ecaa1802c6f24487176c9cae537c3188e083552a84a2aebdd55c4014b41846768d7608970c1e52d9a68e550ef8bb6016adb6f8e0672e1c8198a5442799a5b8142e8d0fadb6e6146a062ef906bd58c46f31bf65263b6142b1976773289dee408ae233b6c0c534dd5092bd7f331c3457971278d335923edc044ba88852680ee39d1cc84a66dc81b70039e2435892b11f310b490c872448f7a8dc718759b2052b0911f758102a59c54dea061a8a3ff6879 RSA密码题，直接使用爆破的方法： 1234567891011121314from Crypto.Util.number import *import gmpy2n = 0x31e22a7a2c5ec946692357dc51014a80530afeb46f419831fcbd896aa1d5cee2d0c69123b3017067afdb3d82b2be3535aebdf11da0fa2b4873233bae6af8a1c2a9344b6f64ade1c6c48a2828130c352053e1729b850774589e8947c8c0a472a8dc90caa542da5cec7f5fa7581747dcb558300437c30b016f769d4a85af8584f311dfb2f9e87fa7d16eaccb0303ecba491619ec7dda72e4037d96c607e666eced582d6eb2c232689fce1c08a54b80cf6d39ef1f2b467d970998c6d54d1779979c89a3b301cd1435bde8787d1141c912cf32b56610fba9205c6e86fefc490c8b2e06f5ed9f775f5b0fe945fa9fca3fc217b4c9dcd4b26676f576d0273b79417b81c = 0x118dd8ab5df8685c5db5b1242896df41e8e9016f5f16276b6d311b29f0e5f9315530574b51c6e7c82d0c88ab92787d639443b921a452c850db580256ccfd55ee52ea9732821525da1d21351acb230a799ecaa1802c6f24487176c9cae537c3188e083552a84a2aebdd55c4014b41846768d7608970c1e52d9a68e550ef8bb6016adb6f8e0672e1c8198a5442799a5b8142e8d0fadb6e6146a062ef906bd58c46f31bf65263b6142b1976773289dee408ae233b6c0c534dd5092bd7f331c3457971278d335923edc044ba88852680ee39d1cc84a66dc81b70039e2435892b11f310b490c872448f7a8dc718759b2052b0911f758102a59c54dea061a8a3ff6879e=65537for r in range(100000): t1=(1&lt;&lt;1024)-1+r t2,s=gmpy2.iroot(t1**2-4*n,2) if s: p=(t1+t2)//2 q=n//p d=gmpy2.invert(e,(p-1)*(q-1)) print(long_to_bytes(pow(c,d,n))) break 得到flag： 1flag{ISEC-OyGdWk_E3gTcPtWUn_OaqD@d76xHyse1} 杂项 第一题 题目： 1Ak_TZh+&amp;:.]v)W.*@DSiR5\\W#fR,q2G+&lt;,]vin4Q\\XX}?&lt;UrJw;aG3^u[|m'AxJ@?Y1ksf0;mN 通过观察发现密码结构比较像base92，于是尝试破解： 结果为： 1ZmxhZ3tJU0VDLVdlbGM0ODkyM0JES2ZiZjN1M2ptbHZqZjNiMkNVT1gyfQ== 结尾带=，自然而然想到base64编码，尝试求解： 得到flag： 1flag{ISEC-Welc48923BDKfbf3u3jmlvjf3b2CUOX2}","tags":[{"name":"Python","slug":"Python","permalink":"https://renzehua1998.github.io/tags/Python/"},{"name":"CTF","slug":"CTF","permalink":"https://renzehua1998.github.io/tags/CTF/"},{"name":"密码学","slug":"密码学","permalink":"https://renzehua1998.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"计算机网络习题部分解答","date":"2022-09-09T08:00:00.000Z","path":"2022/09/09/计算机网络自顶向下/习题部分解答/","text":"计算机网络自顶向下书籍中科大B站课程笔记 习题部分解答 第一章 复习题 R1 没有区别，都是端系统。 R9 调制解调器30-50kbps，HFC30M下行、2M上行，DSL24M下行、2.5M上行，FTTH20M R11 #### R12 电路交换优点：为端到端预留资源保持带宽。FDM需要设备进行载波生成、频率搬移，更复杂去。 R13 三个以上超过负载，就会等待。 #### R18 传播速率和传输速率的区别。 R19 最小值500k 4M/500k=64s 注意：k=1000，K=1024，1B=8b 100k，4M/100k=320s R23 应用层：实现应用 传输层：多路复用可靠性、拥塞控制 网络层：端到端通信、路由转发 数据链路层：相邻两点传输 物理层：物理介质上传输加载还原数字信号。 R25 路由器：网络层、链路层、物理层；链路层交换机：链路+物理；主机：所有五个层次。 习题 P2 #### P3 线路交换更合适，因为产生传输比较稳定，用线路交换可以有性能保证。 不用，直接就可以实现传输。 P6 刚刚离开发送方 在路上 已经到接收方了 #### P14 传输排队 转换一下，令L/R=x x越接近1，t越接近无穷大 P22 丢包概率p，不丢概率1-p，n跳不丢概率： 一次成功概率，两次，n次，算加权平均求极限。 最终算得 #### P25 最大值就是上面的这个值。 在链路上的单向传输数据量（链路容量是它的两倍） #### P27 只占1% P31 分组交换比报文交换效率要高。 b.c.d. 15ms第一个分组到达 更大限度利用传输资源。 第二章 复习题 P1 错，四个请求 对，同一个服务器下 错，非持续TCP连接只能传输一个请求和一个响应报文 错，服务器产生并发送该响应报文的日期和时间 错，有可能有空的——条件式请求，对象在服务器端未改变，头部代码304，此时报文体是空的 R6 常见难题 P10 每次连接先3次握手各自200bit，最后传输内容100kbit，都占用1/10带宽 R=150bps L=100kbit L'=200bit 非持久、并行10个 t1=200/150 t2=100k/150 ti=3*t1+t2=3*200/150+100k/150 tii = 3*t1'+t2'=3*200/150/10+100k/150/10 t=ti+tii=7377s 最终T=t+8tp（传播延迟忽略） 持久 t1=200/150 t2=100k/150 t = 2t1+t1+t2+10(t1+t2)+24tp=7351+24tp 没有太大差别，因为资源太少了。 P22 F=15Gb 服务器上载Us=30Mbps 客户端下载di=2Mbps，N=10、100、1000下客户端上载300k、700k、2Mbps C/S模式 带入不同的N，N小的时候，瓶颈在客户端，N很大的情况下非常慢，瓶颈在服务器，NF/us很大，等待时间线性增加。 N 10 100 1000 300k 7680 51200 512000 700k 7680 51200 512000 2M 7680 51200 512000 P2P模式 N 10 100 1000 300k 7680 25600 46454 700k 7680 15300 21041.4 2M 7680 7680 7680 N小的时候，受限于客户端，所以仍然是7680。P在起作用，随着各个peer节点上载能力的增加，下载时间减少很明显，在2M时增加N时间也不会变。 习题 P9 L=850kbit R=15Mbps 16个/秒 响应平均时间3秒，hit=0.4，内网平均传播延迟t'=10ms 没有缓存 流量强度 有缓存 流量强度 平均速度更快、远程服务器压力更小 P23 Us dn N F dmin=min{di} Us/N≤dmin 服务器是瓶颈——下载时间NF/Us 服务器向每个客户端提供的带宽都是Us/N即可满足 Us/N≥dmin 客户端是瓶颈——下载时间F/dmin 服务器向每个客户端分配的带宽都是dmin，总共Ndmin（服务器没有全部出力） 两种情况都有，去最大值——最差的情况，即为最小分发时间 P24 忽略F/dmin Us ≤ (us+u1+...+uN)/N 服务器是瓶颈——下载时间F/Us 按比例把Us、F按照上载能力u1，u2……非等间隔进行划分，节点把自己收到的数据均分到所有其他节点，带宽和服务器提供给它的相同即可满足——可以推出每个节点上载能力完全可以满足 Us ≥ (us+u1+...+uN)/N 客户端是瓶颈——下载时间NF/ (us+u1+...+uN) 服务器把文件非等间隔分成N+1份，向客户端提供的服务带宽为ui/N-1，发送对应的第i块和N+1块 Ri=ui/N-1，RN+1=(Us-U/N-1)/N——刚好服务器带宽占满了Us。每个客户端以ui/N-1向其他节点发送第i块。 两种情况都有，取最大值——最差的情况，即为最小分发时间 第三章 复习题 R3 源端口y，目的端口x R7 会被描述成相同的套接字，UDP socket只绑定自己的端口+IP。socket API里面有receive from字段可以判断不同的源IP、源端口。 R9 区分新旧、在接收方进行排序 R10 PDU发送过程中可能丢掉，启动超时重发进程 R14 没有数据捎带也要发送确认，错 会变化，根据上层应用层是否取完而变化，错 不会超过空闲buffer，更不会超过整个buffer，对 序号为m+TCP报文中字节数，确认是以字节为单位的，错 TCP段头有一个receive window，对 指数移动加权平均，以前的值可能小于1秒，不一定大于等于，也可能小于1秒，错 不一定能收到，可能是ACK 38，错 R15 110-90=20 ACK 90 TCP累计确认 R17 TCP公平性，每一个R/2.大致的公平性，往返延迟少，抢到的带宽多，和UDP没有可比性。 R18 当前拥塞窗口的一半ssth=cwnd/2 cwnd=ssth+3（三个冗余ACK）ssth=cwnd/2 cwnd=1（超时） 习题 P1 Telnet服务器使用的端口是23 源x，目的23 源y，目的23 源23，目的x 源23，目的y 可以，用不同IP区分即可 不可以，IP相同时必须用端口号区分 P3 简版checksum计算 求和、进位回滚，再取反码。 接收方加和与校验位相加直接判断是否全1——更快更方便 1bit可以，2bit不行 P8 ——状态机，多了超时重传机制 超时所带来的重复问题已经被2.2序号机制搞定，参照2.2即可 P15 传播延迟15ms Ttrans=L/R=1500*8/10^9=12us 假设处理时间为0 效率=nTtrans/(Ttrans+30ms)&gt;0.9 ——n=2251 P23 GBN n ——2^n - 1 SR n —— 2^(n-1) 使用反证法证明 P24 对，接收方ACK滞留了，超时重发，确认到达之后发送窗口前移，又收到旧的ACK 对，接收方ACK滞留了，超时重发，确认到达之后发送窗口前移，又收到旧的ACK 对，退化成了停止等待协议（比特交替协议） 对，退化成了停止等待协议（比特交替协议） P27 序列号207，源端口302，目的端口80 确认号207，源端口80，目的端口302 确认号127，在请求127及以后的报文 画图即可 P32 EstimatedRTT=(1-α)·EstimatedRTT+α·SampleRTT DEV=β|SRTT-ERTT|+(1-β)DEV RTO=ERTT+4DEV 迭代计算即可 算出迭代公式ERTT=x(1-x)^0SRTT1+x(1-x)^1SRTT2+x(1-x)^2SRTT3+...+(1-x)^(n-1)SRTTn 最后一项忽略，求极限 P40 慢启动：1-6，23-26 拥塞避免：6-15，16-22 3个冗余ACK，cwnd降到一半+3 超时，cwnd降为1 32MSS 42的一半，21MSS 29的一半，14MSS（下取整） 累加算一下，什么时候把70号放进去——第七轮 窗口本来为8，ssthreh=4，cwnd=4+3=7 窗口本来是42，ssthreh=21，cwnd=1（Tahoe3个冗余ACK以后也慢启动），19-16=3：1、2、4——cwnd=4 17：1；18：2；19：4；20：8；21：16；22：21（不能大于21）——再线性增加，加起来发送了52个分组 P45 窗口按照锯齿形增长，吞吐量=3/4 * W/RTT 按照每次+1线性增加计算，得到总共预计发送的分组数N为分母，丢失率用1除以它 用丢失率算窗口，忽略窗口的一次项，反推出窗口 代入吞吐量公式，得到速率公式 P53 根据上一题得到的吞吐量和丢失率对应公式 L=2.14×10^-12——此时丢失极大可能是出错造成的，丢失是由拥塞造成的假设不成立了：不使用与高吞吐的情况、也不适合于无线通信的场景。我们的拥塞控制机制需要相应地改变。 第四章 复习题 R2 R3 R10 内存 总线 互联网络 fabric——并行转发 R11 输入：进入很快交换结构交换慢，队列满了就会丢失。（头端阻塞） 输出：交换机构的到达速度比传输速率快，队列满了也会丢失。 ——交换速度n倍于输入限速消除分组消失。 R17 IP数据报内有个字段upper layer，决定了交给上层的协议实体类型。 R30 版本号-版本号 服务类型-流量类型 数据报长度-载荷长度 协议-下一个首部（next head） TTL-跳限制（hop limmit） R33 传统方式只匹配目的IP，最长字段匹配，动作只有转发。 SDN方式匹配字段很多，动作也很多：组播、单播、泛洪、block、修改…… 习题 P5 11100000 00 —— 0 11100000 01000000 —— 1 11100000 —— 2 11100001 0 —— 2 其他 —— 3 3、2、3 P6 00000000-00111111 —— 0——64 01000000-01011111 —— 1——32 01100000-01111111 —— 2——32 10000000-10111111 —— 2——64 11000000-11111111 —— 3——64 0：64；1：32；2：64+32=96；3：64 P10 11100000 00 (224.0/10)—— 0 11100000 01000000 (224.64/16)—— 1 11100000 (224/8)—— 2 11100001 0 (225.0/9)—— 2 其他 —— 3 P14 MTU=700B：最大传输单元；分组大小=2400B 头部20字节：分成20和2380； 每次传输20+680，20+680…… 2380/680=4 标识号422，偏移分别为0、85、170、255（8字节-64bit为单位），标志分别为1、1、1、0 P15 MTU=1500B，总大小5MB=5×10^6B IP头部20B、TCP头部20B，后面1460B N=5×10^6B/1460向上取整3425 若MB按2^20算，3592 P16 192.168.1.1、192.168.1.2、192.168.1.3，路由器192.168.1.4 NAT转换表为 第五章 复习题 R1 路由算法在每个路由器中运行，受限于每个路由器的资源和能力。 每个路由器都作为一个整体独立地工作，既有数据平面也有控制平面。——垂直集成 R4 LS：全局、集中式、一次性计算 DV：局部、分布式、迭代收敛 R7 AS内不关心策略只关心性能，自治区之间要进行控制（政策性、经济型） AS内不用考虑规模，AS间要考虑 AS内要考虑性能，AS间不考虑 R8 错误，在自治区内进行泛洪——LS算法，所有节点都要获得链路状态信息 习题 P3 搞清楚源节点是什么（x），给出源节点到所有节点的最短路径，生成最小生成树。 P5 给定z节点判断其距离矢量的变化 P7 Dx(w)=2，Dx(y)=5，Dx(u)=7 c(x,w)增到6以上，c(x,y)减到1以下 c(x,w)增到6及以下，c(x,y)减到1及以上 P14 eBGP iBGP eBGP iBGP P15 I1，因为I1距离1c更近 I2，都需要两大跳（AS-PATH相同），而距离最近的网关1b（NEXT-HOP），I2更近 I1，经过1c需要两大跳而1b需要三大跳 第六章 复习题 R2 不是多余的，IP协议不是可靠的。逐跳可靠不等于整个链路可靠，IP数据报可能会被丢弃。同时不同的IP数据报经过不同的路径，其延迟可能不同，到达接收方可能会乱序。 R6 i=5，窗口=2^5=32——概率1/32 t=K*512位时 R=10Mbps，位时=1/R，代入求得延时=204.8us R11 查询时事先不知道IP和mac的对应关系，应答以后就知道了源mac和源IP。——注意仅涉及同一子网。 R12 不可以：全球任何一个网卡有唯一一个mac地址 映射表定期保存、删除 习题 补充 P2 行列综合即可判断哪一位出错 同一行两列出错，可以判断两列有错，但无法定位 对偶出错，无法检测、无法定位 P8 代入 代入 P15 不用经过路由器，在一个子网内部，源：E IP 端口；目的：F IP 端口。 不会，因为不在一个子网，查询连接路由器R1的mac地址。源：E IP 端口；目的：B IP R1端口. S1收到会向所有其他端口转发广播，R1不会转发——ARP广播不跨子网 响应时向A发送单播即可，因为请求里面携带了A的mac地址。 S1会进行全端口转发——它的作用就是全端口转发，在一个碰撞域内 P17 P21 IP始终是源：A；目标：F mac地址： 源：A；目标：R2 源：R2；目标：R1 源：R1；目标：F P26 核心思想：交换表自学习不断累积——软状态关系，可以定期删除增加 R16 两两相连，各自出一个端口，连完以后就都在一块了，总共（N-1）*2 P31 路由器的MAC帧，根据路由选择协议对其中的IP数据报进行转发…… P28 物理上一个、逻辑上两个：一个mac两个IP 每次发IP数据报都要封装为以太网帧，发送到上层路由器解封装后查路由表，再封装成以太网帧下发到对应VLAN ——VLAN把同一交换机的不同端口捆绑为不同的虚拟局域网。 第八章 复习题 R1 可能，密文取一块就是机密但不完整，未加密的完整报文就是完整而不机密。通常公开密钥下完整性和源端可认证性捆绑。 R3 R13 计算更快、保证反向计算困难 R14 CA私钥对证书散列（报文摘要）进行加密 R16 防止重放攻击 习题 P8 n=5*11=55 z=4*10=40 e=3，e&lt;n，且与z没有公因数 d=27 m=8，m^e=512，密文c=m^e mod n = 17 P17 先用自己的私钥解出对称式密钥Ks，解出明文m和数字签名，明文m算报文摘要，通过发送方公钥解报文摘要，一样的话就说明通过了机密性校验、完整性校验和身份校验。","tags":[{"name":"计网","slug":"计网","permalink":"https://renzehua1998.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"计算机网络第八章","date":"2022-09-09T06:00:00.000Z","path":"2022/09/09/计算机网络自顶向下/第八章/","text":"计算机网络自顶向下书籍中科大B站课程笔记 第八章 网络安全 是什么？网络安全原理——私密性、认证、报文完整性、密钥分发 怎么实现？安全实践——防火墙、各层次安全性 8.1 什么是网络安全？ 什么是网络安全？——保证网络安全是完全的 机密性：加密解密，其他人不知道发的是什么 可认证性：确认对方身份 报文完整性：传输过程中没有改变 访问控制和服务的可用性：服务对于用户可接入、可用-availability 经典模型： Bob, Alice (lovers!) 需要安全的通信 Trudy (intruder) 可以截获，删除和增加报文——窃听、插入、伪装、劫持、拒绝服务 ——对等方包括：真人、交易、银行、DNS服务器间、路由器之间（各层） 12345graph TB A[网络安全]--&gt;B[机密性] A--&gt;C[可认证性] A--&gt;D[报文完整性] A--&gt;E[访问控制和服务的可用性] 8.2 加密原理 术语： plaintext明文 key密钥 ciphertext密文 分类：对称密钥密码学、公开（非对称）密钥密码学——根据加密解密密钥是否一样。 对称密钥加密学 ——共享一个对称式的密钥（映射关系） 示例：替换密码：将一个事情换成另外一个事情 没有计算机之前是可以的，26！种可能计算机可以很快破解。 可以使用启发式信息进行搜索——字频词频 问题：密钥分发（如何达成一致） 对称密钥加密算法： DES（标准） 美国加密标准 56位key，64bit成组加密 不太安全，可以暴力破解 更安全：3重加密、分组成串技术：当前明文+之前密文异或后加密 DES操作方法：初始替换（乱秩）、16轮使用56位中的不同key进行加密运算、最终替换（乱秩） AES 加密强度可选：key位数可以不同，128bit成组，128、192、256bit key 使用1秒钟破解 DES, 需要花149万亿年破解AES 块密码（成组加密） 64bit分为8个8bit，分别采用不同的映射关系，再打乱，可以多轮循环 密码块链 避免了明文相同密文也相同的情况，加入历史密文 当前明文+之前密文异或后加密 打破64bit64bit映射关系，增加破解难度 公开密钥密码学 ——对称式加密第一次如何达成一致？ 分成公钥和私钥，公钥包含在证书内部，把公钥分发给对方，发送方使用公钥加密，接收方通过私钥进行解密即可。 公开密钥加密算法： ——公钥加密的可以使用私钥还原、通过公钥无法推出私钥 经典算法：RSA 选择密钥 选择2个很大的质数 p, q n = pq, z = (p-1)(q-1) 找一个和z互素（互质）的数e 选择 d 使得ed-1 正好能够被z整除——ed mod z = 1 公钥(n,e). 私钥 (n,d)。得到两个数对 加密,解密 得到 (n,e) 和 (n,d) 加密：c = m^e mod n 解密：m = c^d mod n ——加密解密算法运行过程是一样的、加密代价很大-对称加密1000倍、破解很难 为什么？数论中的某个定理 另一个重要特性：用于数字签名（先用私钥再用公钥） 破解密钥两种方式： 加密算法已知，求密钥 加密算法和密钥均不知道 不同攻击方式： 唯密文攻击：硬算 已知明文攻击：部分明文和密文的对应关系 选择明文攻击：有相同的加密方法 1234567891011graph TB A[加密原理]--&gt;B[对称密钥密码学] B--&gt;B1[DES] B--&gt;B2[AES] B--&gt;B3[块密码] B--&gt;B4[密码块链] A--&gt;C[公开密钥密码学] C--&gt;C1[RSA] C1--&gt;C11[选择密钥] C1--&gt;C12[加密解密] C1--&gt;C13[核心原理] 8.3 认证 ——表明自己的身份，双方是等价的 ap1.0直接表明身份？——不行，可以被伪造 ap2.0根据IP地址？——不行，可以伪造地址 ap3.0传送密码？——不行，记录并回放（重放攻击）playback attack ap3.1加密自己的密码？——不行，加密密码也可以重放 ap4.0对称加密，双方都有对称式key，发送nonce-R挑战，返回加密之后的R ap5.0公开密钥加密，发送方使用私钥加密，接收方使用公钥解密，认证对方的身份。 ap5.0安全漏洞：中间攻击 bob拿到了Trudy的公钥——根本原因 怎样拿到对方的公钥 怎样验证对方的身份 ——遗留问题：密钥分发、可靠地获得其他实体真实的公钥 8.4 报文完整性 数字签名：可验证性（接收），不可伪造性（发送），不可抵赖性（第三方）——谁签署、签署了什么 怎么签？——用自己的私钥对需要签名的报文进行加密，对方使用公钥进行解密 存在的问题：太长，计算代价比较大——报文摘要 报文摘要：对m使用散列函数H，获得固定长度的报文摘要 H(m). 散列函数——多对一映射、固定长度、正向计算容易反向计算困难。 某些报文生成算法也有问题：很容易找到另一个报文和原报文有同样的报文摘要 散列函数算法：MD5-128bit；SHA-1-160bit；SHA-256-256bit。 12345678graph TB A[网络安全]--&gt;B[认证] B--&gt;B1[ap1.0-ap5.0] B--&gt;B2[中间攻击] A--&gt;C[报文完整性] C--&gt;C1[数字签名] C--&gt;C2[报文摘要] C--&gt;C3[散列函数算法] 8.5 密钥分发和证书 可信赖中介——对称KDC，非对称CA 对称密钥分发：trusted key distribution center (KDC) 公共密钥可信：certification authority (CA) 和KDC和CA建立的可信连接都是带外的（默认已经建立的） KDC：KDC服务器生成A、B通信用的对称式keyR1，使用各自的key加密，同时给A发被keyB加密过的A，R1对，A和B通信时B能够用此密钥解密，由此A、B进行可靠通信。 CA：CA用自己的私钥签署B和B公钥的捆绑关系——证书。A用CA的公钥解密出这个对应关系，获得B的可靠公钥。 证书：串号、证书拥有者信息，包括算法和密钥值本身、证书发行者 信息、有效日期、颁发者签名 根证书：自己给自己签发的证书，是未被签名的公钥证书或自签名的证书。操作系统中自带、自己下载等等。 信任树：信任了根，通过根CA颁发其他实体证书，逐步形成一个树状结构。 1234567graph TB A1[密钥分发]--&gt;B[对称密钥分发] B--&gt;B1[KDC] A2--&gt;C[公共密钥可信] C--&gt;C1[CA] C--&gt;C2[证数] C--&gt;C3[信任树] 8.6 各个层次的安全性 应用层：安全电子邮件 机密性：用对方公钥加密，代价很大 ——生成对称式密钥加密报文，把对称式key通过公钥发送给对方。 可认证性和报文完整性：发送方使用私钥加密报文摘要，接收方通过公钥解密报文摘要并做对比 三者结合：加密的报文摘要放到报文内，再用对称式加密，再用对方公钥加密对称密钥 一个有名的标准（例子）：PGP 传输层：SSL ——Secure sockets layer，SSL实际上是在应用层实现的 在TCP和应用层之间加入的一层，安全套接字层 常见：https 三个阶段： 握手：连接、通过CA签署的证书认证身份、传输密钥 密钥导出：采用共享的MS产生4个keys 数据传输：使用对称密钥进行加密 网络层：IPsec ——传输层下、网络层上。主要有 认证头部 (AH)协议：不提供私密性 封装安全载荷 encapsulation security payload (ESP) 协议：三种安全性都有 都要建立安全关联SA：是单向的，类似于网络层面的握手。由三元组确定：安全协议 (AH or ESP)、源 IP地址、 32-bit连接ID AH：在IP头部和数据之间插入自己的头部 AH 头部包括： 连接ID 认证数据 数据类型：TCP, UDP, ICMP ESP 协议：在IP头部和数据之间插入自己的头部，尾部插入ESP尾部和可认证尾部——还包括了私密性 链路层：WEP ——每一个链路层分组都要被加密 输入向量+对称式配置好的key 得到需要的key 和要传输内容做异或得到密文。 无线主机之间传输加密的分组。 123456789graph TB A[各层安全性]--&gt;B[应用层] B--&gt;B1[PGP] A--&gt;C[传输层] C--&gt;C1[SSL] A--&gt;D[网络层] D--&gt;D1[IPsec] A--&gt;E[链路层] E--&gt;E1[WEP] 8.7 访问控制：防火墙 ——将组织内部网络和互联网络隔离开来，按照规则允许某些分组通过（进出），阻塞对应的分组：隔离 为什么需要？ 阻止拒绝服务攻击Dos/DDos 组织非法、非授权访问 认证后的允许访问 两种类型： 网络级别：分组过滤器——有状态，无状态 应用级别：应用程序网关 分组过滤器 ——匹配规则（字段） 源IP地址,目标IP地址 TCP/UDP源和目标端口 ICMP报文类别 TCP SYN 和ACK bits ——无状态例子： 阻塞掉进出UDP流 以及telnet 连接 阻止外部向内TCP、允许内部向外TCP DMZ区：非军事区，允许外部设备连入（两道防火墙） ACL（Access Control Lists）访问控制表来控制匹配规则和动作 ——有状态分组过滤 连接建立以后才允许发送流量：连接状态表check conxion字段，有连接状态才允许 ——状态维护 应用程序网关 ——不仅仅是网络层的设备 根据应用数据的内容来过滤进出的数据报——检查应用层数据 允许内部用户登录到外部服务器，但不是直接登录。加入一个中继网关服务器，内外网应用层内部数据深度检查。 不同的应用要做不同的配置，相对比较麻烦。 防火墙和应用程序网关的局限性： 无法对抗IP欺骗（修改字段内容） 需要多个应用程序网关，很麻烦 客户端需要知道连接代理的方法 对UDP要么全过要么全不过 安全：不方便；方便：不安全。 8.8 攻击和对策 IDS 入侵检测系统 深入到分组内部的数据——防火墙只看头部 设置IDS探针，截取网络中的流量 不止检测单个分组，还进行关联分析：序列模式匹配 ——也会有误判和漏报，multiple IDSs: 在不同的地点进行不同类型的检查 Internet 安全威胁 映射nmap 踩点（mapping）发现在网络上实现了哪些服务 使用ping来判断哪些主机在网络上有地址 端口扫描：试图顺序地在每一个端口上建立TCP连接 对策：（防火墙、IDS） 记录进入到网络中的通信流量 发现可疑的行为 嗅探 广播式介质 混杂模式的NIC获取所有的信道上的分组（对网络流量进行监测） 可获取所有未加密的数据 对策： 周期性地检查是否有网卡运行于混杂模式（ARP协议做的事） 每一个主机一个独立的网段 IP Spoofing欺骗 有应用进程直接产生 “raw” IP分组, 而且可以在IP源地址部分直接放置任何地址 接收方无法判断真伪 对策： 入口过滤：具有非法源地址的分组不进行转发 拒绝服务DOS（Denial of service） 产生的大量分组淹没了接收端 DDos：多个相互协作的源站淹没了接收端——分布式拒绝服务 对策： 到达主机前过滤掉这些泛洪的分组 回溯到源主机 123456789graph TB A[安全设施]--&gt;B[防火墙] B--&gt;B1[分组过滤器] B--&gt;B2[应用程序网关] A--&gt;C[IDS] A2[安全威胁]--&gt;D[映射nmap] A2--&gt;E[嗅探] A2--&gt;F[IP欺骗] A2--&gt;G[拒绝服务] 总结 原理：加密、完整性、密钥分发、认证中心（两种中介） 实现：PGP、SSL、IPsec、WEP（加密、认证、完整性校验） 安全性：防火墙、IDS；各种攻击行为与防范机制","tags":[{"name":"计网","slug":"计网","permalink":"https://renzehua1998.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"计算机网络第七章","date":"2022-09-09T04:00:00.000Z","path":"2022/09/09/计算机网络自顶向下/第七章/","text":"计算机网络自顶向下书籍中科大B站课程笔记 第七章 未来网络前沿技术 ——不是自顶向下书内的第七章，是中科大课程补充内容：未来网络前沿技术 软件定义网络 ——software defined networking 背景 网络发展的背景和现状：巨大成功、改造传统行业的重任 当前属于第二代互联网，90年代后发展起来 面临的主要问题： 可扩展性 可控性 安全性 实时性 能耗问题 国际上布局了很多未来网络的项目：中国CENI、美国GENI、欧盟FIRE——处于战国时期 为什么要有SDN 现有网络僵化、不灵活、封闭、臃肿——创新壁垒 借鉴当前计算行业的开放性： 分离出操作系统：开源、竞争 应用进行解耦 硬件进行简化 实施 开放硬件接口 有1个良好、可扩展的操作系统 定义良好的API，允许开发不同的应用 OpenFlow 分离数据平面、控制平面 控制器和客户端之间命令下发控制、上传 流表的配置下发 流表 规则：可以屏蔽掉不需要字段 行动：转发、转送、修改、扩展…… 匹配次数统计 应用实例 交换 流交换 防火墙 数据命名网络 ——named data networking NDN 与当前互联网区别 当前互联网以主机节点为中心，NDN以信息为中心 目前网络中数据二八分布，在应用层提出了CDN、P2P等方案——能不能还给网络层：网络层内部资源存储能力 数据命名：基于名字进行路由转发 为每个数据包加安全：消除对传输安全的依赖 连接的路由器有状态：按兴趣、按条 IP模型路由的问题： 中间节点不可见 中间节点不可选 无法衡量成功与否 存储不可缺少但也不可见 NDN细节 NDN模型： ——打破了端到端的模式 路由器可以储存资源，如果有的话直接获取，没有再次进行转发查询 包描述“什么”而不是“谁” 本地对端通信 上行性能可测 不会有环路 NDN报文： ——兴趣报、数据报两种 有name没有地址 消费者：interest；生产者：data data沿interest原路返回 NDN数据命名： ——分级命名，使用“/”划分，类似于url，可以进一步扩展 优点： 描述数据、场景关系 命名聚合便于管理 TLV基本格式 ——type、length、value 嵌套结构，value可以带多个子TLV结构 type length变长编码 name： interest： data： NDN路由器 数据结构 待定兴趣表：存储interest请求，保证原路返回，进行请求聚合 转发信息表：名字和端口映射 内容存储：本地数据库 转发过程 兴趣包： 请求内容有直接返回 之前请求过，聚合兴趣 转发兴趣包 数据包： 查看请求表，没有请求过不发 匹配后缓存到本地 原路返回给消费者 移动优先网络 ——mobile first networking 背景 ——现有网络对于移动终端支持比较弱 IP具有地址、身份双重性，但是接入点变化IP会改变 导致网络层无法识别用户、应用层重传效率低下 实施 基本思路 ——名字与地址分离 GUID：全局唯一名字表示，提供一个GUID和IP的映射——类似DNS 协议栈 逐跳块传输协议 存储感知路由 GUID与NA映射 分层命名 应用层描述符捆绑GUID、GUID捆绑IP地址（NA） 动态解析GUID-&gt;NA 分布式实现 存储感知抗毁路由 路由器存储某些IP报文应对可能的中断 一旦更换网络，无缝自适应 依赖于身份、地址的动态绑定 网络实验设施 原因 ——需要有一个真实环境、不能在真实场景下直接使用 CNEI 我国自主开发的未来网络架构实验平台 总结","tags":[{"name":"计网","slug":"计网","permalink":"https://renzehua1998.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"计算机网络第六章","date":"2022-09-07T06:00:00.000Z","path":"2022/09/07/计算机网络自顶向下/第六章/","text":"计算机网络自顶向下书籍中科大B站课程笔记 第六章 链路层和局域网 ——广域网也有链路层，但是相对来说比较简单，所以重点放在局域网 ——由一个节点如何到达另外一个相邻节点：点到点传输 目标： 原理：检错和纠错、共享广播信道（多点接入）、链路层寻址、LAN、可靠数据传输（Rdt、流量控制-讲过了） 实现：PPP、802.3、802.11 网络节点的连接方式： 点到点连接：广域网（物理限制、带宽延迟大-碰撞损失极大）——不用考虑寻址、访问控制 多点连接（共享介质、交换机AP）：局域网——多点访问控制（MAC）、寻址 6.1 引论和服务 术语规范： 节点nodes：主机和路由器 链路links：连接个相邻节点通信信道（有线无线） 帧frame：链路层的PDU ——数据链路层负责从一个节点通过链路将（帧中的）数据报发送到相邻的物理节点 上下文：（类比与一个人乘坐不同的交通工具） 数据报（分组）在不同的链路上以不同的链路协议传送 不同的链路协议提供不同的服务 链路层服务： 成帧、链路接入：打包、获得信道使用权——使用“MAC”（物理）地址来标示源和目的 相邻两点间完成可靠数据传输：有些有，有些没有（本身可靠就不用、本身不可靠就必须进行差错控制） 流量控制、错误检测、差错纠正、半双工和全双工 在哪里实现？ ——每台主机上的网卡（网络适配器、网络接口卡、NIC）：链路层+物理层。硬件、软件和固件的综合体 适配器通信：同时可以发可以接 发送方：封装、差错控制、发出去 接收方：监听、接收、检错、解封装 12345678910graph TB A[引论和服务] A--&gt;B[术语规范] B--&gt;B1[节点] B--&gt;B2[链接] B--&gt;B3[帧] A--&gt;C[链路层服务] C--&gt;C1[成帧 接入] C--&gt;C2[可靠数据传输] C--&gt;C3[流量控制 差错控制] 6.2 差错检测和纠正 EDC——差错控制编码，存在残存错误；D——被保护的数据内容 校验方法 奇偶校验：一维、二维（可以定位出错位置）：对偶情况也可能检测不到。 校验和：1的补码和，循环相加 CRC（循环冗余校验）： CRC： 模2运算——加法不进位、减法不借位（其实就是按位异或） 位串的两种表示—— 生成多项式G——r次方的一个多项式表示一个比特序列：r+1位 生成r位冗余位，使得数据位+冗余位刚好能被生成多项式整除。 两边再异或R，等价于： 。——两边同除G，得到的余数就是 R 计算R：D左移R位除以生成多项式得到余数（不足R位补0）即为EDC，接收方判断能否整除即可。 CRC性能分析：（理论分析不要求掌握） 能够检查出所有的1bit错误 能够检查出所有的双bits的错误 能够检查出所有长度 =r或者&lt;r 位的错误 长度为 r+1的突发错误，检查不出的概率是： 长度大于r+1的突发错误，检查不出的概率： 123456789101112graph TB A[差错检测纠正] A--&gt;B[奇偶校验] B--&gt;B1[一维] B--&gt;B2[二维] A--&gt;C[CRC循环冗余校验] C--&gt;C1[模2运算] C--&gt;C2[生成多项式] C--&gt;C3[计算方法] C--&gt;C4[性能分析] A--&gt;D[校验和] D--&gt;D1[循环进位] 6.3 多点访问协议 概述 两种类型链路：点对点、多点连接 多路访问协议存在的问题：2个或更多站点同时传送: 冲突（collision） 介质访问控制协议：MAC-算法角度（MAP-协议角度） 分布式算法-决定节点什么时候可以发送 共享控制的通信必须用借助信道本身传输 理想MAC协议特性： 一个节点占用所有带宽 M个节点占用R/M带宽 完全分布式，没有统一协调节点 简单易行 分类： 信道划分：分路复用 随机访问：允许冲突，可以解决冲突 依次轮流：有中心节点控制、令牌 信道划分MAC协议 略（通信知识） TDMA：时分多路 FDMA：频分多路 CDMA：码分多路——第三代移动通信技术（过时了） 随机存取协议 有数据要发送时，全部带宽发送 多节点同时传输，冲突检测恢复 随机MAC协议： 时隙ALOHA ALOHA CSMA：CSMA/CD, CSMA/CA 重点！——载波侦听、多路访问 时隙ALOHA 每个时隙可发送一帧，每个节点都可以检测到是否产生了冲突，每一个随后的时隙以概率p重传帧直到成功。延迟没有上限，无法保证最长时间。 优点：简单、全速率传播、完全分布式 缺点：存在空闲时隙、冲突浪费时隙、检测冲突时间小于完全发完时间、需要同步 效率分析：一个节点成功传输概率是，任何一个节点的成功概率是。求导求极值，f(p*)=37.5%——信道利用率37% 纯ALOHA 有帧马上传输，碰撞就不发，其他和时隙ALOHA一样 效率分析：任何一个节点的成功概率是，f(p*)=17.5%——信道利用率17%，更差了。 CSMA(载波侦听多路访问)——发之前听一听有没有人在发 ——冲突仍然有可能发生，两个节点可能侦听不到正在进行的传输（信道延迟造成的延迟）。延迟越大，冲突发生的概率越大。 CSMA/CD(冲突检测) ——事前侦听，边说边听（先听后发，边听边发） 冲突发生时则传输终止，减少对信道的浪费 有线局域网中容易实现，通过检测信号强度判断是否冲突 以太网CSMA/CD算法： 将数据报生成帧 侦听信道CS——闲，直接发；忙，等待闲再发 发送过程中不断检测冲突CD——没有冲突，成功；有冲突，停止之后重发 检测到冲突后，发送一个Jam信号。强化冲突：让所有站点都知道冲突，所有监测到冲突节点都发送。 放弃，适配器进入指数退避状态——二进制指数退避算法，窗口每次加倍，碰撞概率减半，等待时间变大。在第m次失败后，适配器随机选择一个，，，，中K，等待K*512位时，然后转到步骤2。对载荷自适应，载荷越大，碰撞概率高，动态加倍等待时间，取一个可用的平均等待时间，动态分布式自适应算法。 高负载：重传窗口时间大，减少冲突，但等待时间长 低负载：使得各站点等待时间少，但冲突概率大 比ALOHA更好的性能，而且简单，廉价，分布式 无线局域网 CSMA/CA（冲突避免） WLAN两种模式：有基础设施、自组织，我们探讨前一种模式 基础设施：AP（access point 接入点-基站）、无线链路、（移动主机节点-非基础设施） ——无限介质有衰减、干扰、噪声，无法使用原来的冲突检测方式。 此情景下的冲突：2+ 站点（AP或者站点）在同一个时刻发送。 802.11协议CSMA/CA算法： 发送前侦听信道（CSMA） 不做冲突检测，因为收到自己的电磁波信号远大于对方冲突信号。 且冲突也可能成功，不冲突也不一定成功。 例子：存在隐藏站点，暴露在两个传播范围的终端冲突也可以成功。 发送方： 侦听信道持续一段时间空闲，直接发。确认帧的等待空闲要比数据帧小（确认帧优先级高） 侦听信道忙，随机选一个值，信道空闲时每次减一，到0时发送帧，等待ACK。没收到ACK继续重复2。 接收方： 如果帧正确，则在SIFS后发送ACK 为什么空闲还要等？——避免前一个发完以后所有要发送的设备同时发，造成冲突，减小信道利用率（事前避免） ——无法完全避免冲突：相互隐藏、非常近的随机值 发送方“预约”信道（可选项） 发送方发送RTS（预约帧） BS（AP）发送CTS广播，告诉其他所有设备信道被预约 线缆接入网络 ——特殊的random方式（下发存在集中控制，上行随机预约） 每个用户通过cable modem接入网络 分为上行、下行，分多个信道，由CMTS管理 下行(广播)信道,FDM，互联网占一个（不存在竞争，用户根据地址接收），其余是广播、电视 上行信道,FDM，进一步TDM分成微时隙：一部分是竞争式（预约）、一部分是分配式。 上行预约、下行发布预约结果，没预约上的话重新预约即可（类似于抢票）。或者之间分配好用就行。 预约产生碰撞，都无法使用，通过下行反映，二进制指数退避方法处理。 轮流MAC协议 对比信道划分、随机存取：信道划分低负载时利用率低，随机存取高负载时利用率低（反复碰撞） ——Taking Turns 低负载也很好，高负载也很好，但是太复杂很少使用。有集中式、分布式两种。 轮询：主节点邀请从节点依次传送 问题： 单点故障问题 轮询消耗带宽 等待轮询消耗时间 令牌传递：控制令牌( token)循环从一个节点到下一个节点传递，有数据就把令牌变成数据帧，接收方收到后再发出去（可能发给多个设备），最终回到发送方——令牌报文：特殊的帧；分类：令牌环、令牌总线。 问题： 令牌消耗带宽 令牌循环延迟 单点故障——令牌丢了，复杂点生成令牌方式 123456789101112131415161718192021222324252627graph LR A[多点访问协议] A--&gt;B[信道划分] B--&gt;B1[时分] B--&gt;B2[频分] B--&gt;B3[波分] B--&gt;B4[码分] A--&gt;C[随机存取] C--&gt;C1[时隙ALOHA] C1--&gt;C11[分时隙 概率p] C--&gt;C2[纯ALOHA] C2--&gt;C21[无时隙 概率p] C--&gt;C3[CSMA] C3--&gt;C31[CSMA/CD] C31--&gt;C311[先听后发 边听边发] C31--&gt;C312[Jam信号放大冲突] C31--&gt;C313[二进制指数退避] C3--&gt;C32[CSMA/CA] C32--&gt;C321[先听后发 发时不听] C32--&gt;C322[存在应答 随机回退] C32--&gt;C323[提前预约] C--&gt;C4[线缆接入网络] C4--&gt;C41[上行预约 下行发布] C4--&gt;C42[二进制指数退避] A--&gt;D[依次轮流] D--&gt;D1[轮询] D--&gt;D2[令牌传递] 6.4 LANs 编址和ARP协议 MAC 地址和ARP ——编址，IPv4 32位（40多亿个），按照子网来分层路由；MAC地址48位，在网络内部区分不同的节点。 ——ARP协议，把IP地址转换成对应发送设备MAC地址，在物理网络内部找到对应设备进行转发。网络层一条对应可能有链路层的多条。使得帧可以穿过各个网段。 为什么网络地址和mac地址分离 IP地址和MAC地址的作用不同：IP地址分层、MAC地址是一个平面 分离的好处：网卡坏了可以之间换网卡，IP地址不变；支持网络层其他协议：IPX等 捆绑的问题：生产网卡时不知道用在哪个网段，无法设置；每次都要重载地址且仅支持一种协议；下层会影响到上层的转发操作。 LAN 地址和ARP 每个设备都有一个唯一地址 48位全1表示广播地址：FF-FF-FF-FF-FF-FF IEEE管理和分配，厂商购买不同的号码段 MAC：身份证号；IP：通讯地址号 MAC平面地址 ➜ 支持移动；IP地址有层次 ➜ 不能移动（高级计算机网络设计移动相关） ARP: Address Resolution Protocol ——已知IP地址，如何获得MAC地址？ 每个IP节点维护一个ARP表：&lt; IP address; MAC address; TTL&gt; 不在ARP表中，发送查询包：FF-FF-FF-FF-FF-FF 目标主机收到返回自己的IP和MAC，存入ARP表 一般设置20分钟，即插即用，无需网络管理员的干预（透明） 举例：路由到其他LAN：分组传输过程中，源IP目标IP都不变，源MAC目标MAC每次都会改变。 以太网 ——98%以上占有率最主流、使用最广、廉价、简单、带宽很宽。 主机-网卡-收发器电缆-收发器-同轴电缆（两端匹配终结器-防止回声）——任何主机都可以往同轴电缆注入信号。 物理拓扑 总线型：连载一个长线上——可靠性差 星型：一个端口收，所有端口发（hub 或者 switch）——逻辑上还是总线型， hub（集线器）级联的所有设备同在一个碰撞域内。 switch（交换机）可以同时发多个——解决了CSMA-CD高负载时的可靠性问题。 以太帧结构 前导码：7B 10101010 + 1B 10101011，同步时钟频率 目标MAC地址、源MAC地址：6字节48bit 类型：上层网络层协议 载荷部分 CRC：一边发一边生成在接收方校验 无连接、不可靠的服务 无连接：不握手 不可靠：不确认（无ACK、NAK）-本身出错率很低 二进制退避的CSMA/CD 802.3 以太网标准：链路和物理层 帧格式一样，物理层标准和介质不同、速率不同 100BASE指基带传输，蓝色代表同轴电缆、红色代表光纤 以太网CSMA/CD：（上一节讲过了） 先听后发（载波侦听）、边听边发、冲突随机等待重发 强化冲突Jam信号 二进制指数退避算法 无时隙 碰撞窗口最大1024，10Mbps最坏50ms 效率问题计算：低负载很好、高负载也很好（交换机引入的好处） 10BaseT and 100BaseT 数字代表几bps Base代表基带传输 T代表双绞线-横截面积小减少串扰 节点连接到HUB上，在一个碰撞域 节点和HUB间的最大距离是100 m Hubs：集线器——无缓存、同一碰撞域、一收多发 往下就开始讲物理层了 Manchester 编码 使用跳变方向代表不同的0，1——向下跳变代表1，向上跳变代表0 可以很容易地把时钟和bit序列一起传输 10Mbps链路使用20M带宽——占用更大的带宽，效率50% 100BaseT 4b5b编码，取16种跳变组合，保证至少4个bit有跳变，4bit用5bit来表示，100M成为125M，增加不多。 千兆以太网，使用8b10b编码。有共享模式-CSMA/CD、交换模式-直连点对点链路，很少发生冲突，效率很高 802.11 WLAN IEEE 802.11 Wireless LAN：a、b、g、n——都采用CSMA/CA、都有基站模式和自组织网络模式。MAC和帧格式相同、物理层信道和速率不同。 体系结构 无线主机与基站通信：base station接入access point 基础设施模式下的基本服务集Basic Service Set (BSS)包括： 无线主机 接入点(AP): 基站 自组织模式下只有无线主机 信道与关联 802.11b信道分为11个相互不 同的但是部分重叠的频段 每次选择11个中的一个——邻居AP之间可能干扰 主机通信之前和AP建立associate 扫描信道：主动、被动 选择关联AP 认证：口令、RADIUS等 DHCP动态配置IP地址和子网掩码 被动/主动扫描 主动：（1）H1广播探测请求帧（2）AP发送响应（3）H1向AP发送请求关联帧（4）AP向H1发送响应关联帧 被动：（1）AP发送信标帧（2）H1发送请求帧（3）AP发送响应关联帧 802.11 帧：地址 主机或者AP的MAC地址：接收方 发送该帧的主机或者AP的MAC地址 AP连接的路由器接口的MAC地址 只在自组织模式中使用 ——其余：帧控制（协议控制、帧类型等等）、预约传输时间的持续期、帧序号、载荷、校验等 子网中运行802.11，往上可能是802.3（快、带宽大） 网络交换设备switches Hub：集线器：物理星型、逻辑总线型，同一个碰撞域（一个网段）内，不可以接不同速率以太网，不可以同时发送，可以级联。——盒中总线 交换机：存储转发，可以决定往哪个端口发（每一个端口可以认为是一个网段）。并发的主机可以很多、可以级联、即插即用（透明）。也需要排队，每个端口也是进行CSMA/CD进行控制。 多路同时传输：主机有一个专用和直接到交换机的连接（没有冲突、碰撞） 转发表：MAC地址-端口号-时间戳 自学习转发表：根据从不同端口收到的帧的源MAC直接建立联系，不知道的话进行泛洪，向所有端口转发即可进行传送。 过滤／转发：进入端口设备MAC记录、匹配目标MAC——出入端口相同，不转；出入端口不同，转发；没找到目标MAC，泛洪。 交换机级联：效率更高，而hub级联会使得效率降低。发送过后，路径被学习，下一次直接单播转发即可。 网络连接：通过各级交换机连接，再接网关路由器，接入ISP接入互联网。 交换机和路由器对比： 层次不同：链路层、网络层 都有转发表：交换表-生成树算法、路由表-路由选择算法——是否即插即用、效率不同 VLANS ——虚拟局域网（略） 把一些MAC地址对应的设备放到一个虚拟局域网内 在交换机处做一些设置即可完成功能——多个虚拟交换机 12345678910111213141516171819202122graph LR A[LANs] A--&gt;B[编址和ARP] B--&gt;B1[为什么IP和MAC地址分离] B--&gt;B2[ARP协议] A--&gt;C[以太网] C--&gt;C1[拓扑:星型 总线型] C--&gt;C2[以太帧结构] C--&gt;C3[无连接 不可靠] C--&gt;C4[802.3 以太网标准:链路和物理层] C--&gt;C5[Manchester 编码] A--&gt;D[WLAN] D--&gt;D1[体系结构] D1--&gt;D11[主机] D1--&gt;D12[基站] D--&gt;D2[信道与关联] D--&gt;D3[被动/主动扫描] D--&gt;D4[帧结构:地址] A--&gt;E[交换设备] E--&gt;E1[集线器hub] E--&gt;E2[交换机switch] E--&gt;E3[交换机和路由器对比] 6.5 链路虚拟化：MPLS ——多协议标记交换，按照标签交换分组 本科略讲，不考 基于标签的转发表 基于虚电路表 6.6 数据中心网络 ——和一般局域网需求不一样、特性也不一样 数据中心（DC）服务器和存储设备之间存在高带宽、高可靠、低延迟的连接。 负载均衡器：对外不可见 复杂的交换阵列：增加冗余度-可靠性、吞吐量 6.7 a day in the life of web request ——按时间轴来讲web浏览器怎么和web服务器打交道：综述 在校园启动一台笔记本电脑，访问一个网站。 DHCP动态获取IP地址 用户电脑使用DHCP 请求被封装在UDP中，封装在IP, 封装在 802.3 以太网帧中 FFFFFFFFFFFF广播 以太网帧中解封装IP分组，解封装UDP，解封装DHCP DHCP服务器发送ACK：IP、DNS、网关、掩码 封装应答帧，LAN转发到用户电脑 用户接收，ACK应答 ARP DNS查询被创建，封装在UDP段中，封装在IP数据报中，封装在以太网的帧中. 将帧传递给路由器 用户电脑ARP查询广播，路由器ARP应答，给出对应端口MAC地址 客户端获得MAC地址用于发送DNS请求 DNS 包含DNS的IP数据报到达第一跳路由器 路由（路由表被RIP，OSPF，IS-IS 和/或BGP协议创建）到DNS服务器 DNS服务器解封装 回复给客户端对应url的IP TCP连接建立 web浏览器调用TCP socket 三次握手：SYN段、SYNACK段 建立TCP连接 HTTP请求、应答 发送HTTP请求到TCP socket 打包到IP数据报中，路由到web服务器 web服务器发送HTTP应答 携带应答HTTP的IP数据报最终路由到客户端，经过端口发送给web浏览器。 123456graph LR A[举例:笔记本电脑访问web服务] B((DHCP))--&gt;C((ARP)) C--&gt;D((DNS)) D--&gt;E((TCP)) E--&gt;F((HTTP)) 总结 对于LAN中，不碰撞=成功的条件是：一个帧在以太网中持续时间≥2τ（最长往返延迟），冲突检测机制可以确保发送成功。——发送时检测到冲突最长时间为2τ。 检错纠错：CRC 多路访问：MAC 链路层编址：ARP协议 实现协议：WLAN——802.11；LAN——以太网 其他协议：PPP协议——point to point protocol。点到点连接常用协议。","tags":[{"name":"计网","slug":"计网","permalink":"https://renzehua1998.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"计算机网络第五章","date":"2022-09-07T04:00:00.000Z","path":"2022/09/07/计算机网络自顶向下/第五章/","text":"计算机网络自顶向下书籍中科大B站课程笔记 第五章 网络层：控制平面 网络层控制平面的工作原理 传统路由选择算法 SDN 控制器 ICMP 网络管理（略） 协议：OSPF, BGP；OpenFlow, ODL 和ONOS控制器, ICMP, SNMP 内部网关协议：RIP、OSPF；外部网关协议：BGP 5.1 导论 数据平面、控制平面 2种构建网络控制平面功能的方法：传统、SDN SDN：控制器与本地控制代理（CAs） 交互（上一章讲过） 5.2 路由选择算法 简介 两类：链路状态（LS）、距离矢量（DV） 路由选择算法(routing algorithm)：网络层软件的一部分,完成路由功能 路由：按照某种指标(传输延迟,所经过的站点数目等)找到一条从源节点到目标节点的较好路径。（较好：某种指标较小——跳数、延迟、费用、队列长度等等，体现了使用者偏好） 以网络为单位进行路由：路由信息传输、计算和匹配的代价低。计算网络到其他网络如何走。 可以认为是子网到子网的路由，子网出口和最终子网下发路径没有悬念。子网路由进一步可以聚集。——找到路由器之间（子网之间）的最佳路径。 网络的图抽象： 输入： 网络拓扑（节点-路由器、边-链路） 边权重-代价 源节点 输出：源到任意节点的最优路径（汇集树） ——汇集树（最小生成树）：此节点到所有其它节点的最优路径形成的树。 路由选择算法的原则：正确性、简单性、健壮性（带宽、拓扑）、稳定性、公平性、最优性（次优性-某项指标最优） 路由算法分类： 全局：有完整的拓扑和边的代价的信息——LS算法 分布式：周边邻居信息（局部信息）——DV算法 静态-非自适应、动态-自适应（大部分是动态的）：适应网络拓扑变化、适应通信量的变化 link state （LS） ——即迪杰斯特拉算法 工作过程： 获得整个网络拓扑, 网络中所有链路代价等信息 用LS路由算法,计算本站点到其它站点的最优路径 （分组转发-数据平面） 链路状态路由选择（LS） 生成链路状态分组（自己邻居的可达情况）、泛洪、Dijkstra算法（独立、迭代） 发现相邻节点，向所有线路发送HELLO分组，发送HELLO应答 测量到相邻节点的代价(延迟,开销)——回送一个ECHO分组 组装一个分组，描述相邻节点的情况——链路状态分组 将分组通过扩散的方法发到所有其它路由器——泛洪 避免广播风暴：设置TTL（年龄字段）、记录转发情况（顺序号） 保证收到，未收到确认信号就一直重复发送。——可靠泛洪 通过Dijkstra算法找出最短路径 经典LS算法实现协议：OSPF、IS-IS Dijkstra算法： 准备： c(i,j)链路代价、D(v)当前路径代价、p(v)路径中的前序节点（倒着的指针）、N’当前已经知道最优路径的的节点集合（永久节点） 节点标记：每一个节点使用(D(v),p(v))标记 2类节点：临时、永久 算法过程： 初始化，源节点为永久节点、标记源节点的邻居节点的前序节点 临时节点中找到一个节点代价最小的临时节点，变为永久节点 对临时节点中的邻居进行重新标记 开始新循环直到所有节点都成为永久节点 可以在图上直接做，也可以参考列表的方式进行标记。——复杂度O(n^2)，有O(nlogn)的实现 讨论：可能会造成震荡。最快路径都去选择，下一周期就会拥塞 distance vector （DV） ——距离矢量路由选择 即Bellman Ford算法 每个节点维护一张路由表：目标、代价、下一跳邻居。 相邻两邻居定期交换距离矢量 根据获得的路由信息,更新路由表 迭代式算法，需要多步迭代才能获得较稳定的结果。 相邻节点间代价通过真实定期测量获得：跳数(hops), 延迟(delay),队列长度 定期与相邻节点交换距离矢量路由表(DV) 实测+交换得到的距离矢量，取最小代价路径，选定下一节点。 具体例子：注意自己到自己不要再从邻居计算！ 特性：好消息传的快 坏消息传的慢 Bellman-Ford 方程(动态规划)： ——不停地迭代最终会收敛到真实情况 每个节点维护自己的距离矢量 定时测量到所有邻居的代价 收到并维护一个它邻居的距离矢量集 核心思路： 定时将自己的距离矢量估计值传送给邻居，让对方算 x从邻居收到DV时，自己运算，更新它自己的距离矢量 ——最终收敛于实际的最小代价值：分布式、异步迭代算法 异步迭代：本地链路代价变化了、邻居距离矢量变化导致迭代计算 分布式：每个节点只是在自己的DV改变之后向邻居通告 DV的无穷计算问题： 好消息传的快：好消息的传播以每一个交换周期前进一个路由器 的速度进行 坏消息传的慢：断线会形成环路，每次迭代代价+1，无限次之后, 到A的距离变成INF,不可达 减少环路方法：水平分裂——可达信息来源邻居，对它表达自己到对应节点的可达信息为INF。坏消息以一次交换一个节点的速度传播。（有环状链路的网络中就无能为力了） 例子：时空图，每次更新自己的距离矢量，三节点网络经过三次迭代收敛到真实状态。 LS 和 DV 算法的比较 消息复杂度：DV传输的少，更优 收敛时间：LS更短，更优 健壮性：路由器故障时LS更健壮——错误信息影响较小 ——2种路由选择算法都有其优缺点，而且在互联网上都有应用 123456789101112131415graph TB A[路由选择算法] A--&gt;B[简介] B--&gt;B1[路由概念] B--&gt;B2[图抽象] B--&gt;B3[算法分类] A--&gt;C[LS链路状态] C--&gt;C1[工作过程] C--&gt;C2[Dijkstra] A--&gt;D[DV距离矢量] D--&gt;D1[Bellman-Ford方程] D--&gt;D2[无穷计算] C--&gt;E D--&gt;E E((二者对比)) 5.3 因特网中自治系统内部的路由选择 ——内部网关协议，有RIP（DV）和OSPF（LS） RIP ——Routing Information Protocol 路由信息协议 每条链路cost=1，max = 15 hops，16代表不可达 DV每隔30秒和邻居交换DV，通告 每个通告包括：最多25个目标子网 通告： 定期30s或请求就发 最多25个：适用于小网络 ——代价小，比较简单 链路失效和恢复： 如果180秒没有收到通告信息--&gt;邻居或者链路失效 新的通告报文会传递给邻居 毒性逆转——水平分裂，达到16即可认为不可达 进程处理： 以应用进程的方式实现 通告报文通过UDP报文传送 网络层的协议使用了传输层的服务，以应用层实体的方式实现 OSPF ——Open Shortest Path First 开放最短路径优先（标准可公开获得） OSPF通告信息中携带：自己是谁、TTL、每一个邻居路由器一个表项 通告信息会传遍AS全部（通过泛洪） IS-IS路由协议：几乎和OSPF一样 “高级” 特性： 安全: 所有的OSPF报文都是经过认证的，不允许伪造 允许有多个代价相同的路径存在（负载均衡） 不同的TOS有多重代价矩阵（多种指标的最优路径） Multicast OSPF (MOSPF) ——多播 在大型网络中支持层次性OSPF 层次化的OSPF路由：只在自己的范围内进行泛洪，跨小区域的分组路由借由内部路由器（internal routers）、区域边界路由器（area boundary router）、骨干路由器（backbone router）传输，要路由到其他自治区域还要借助主边界路由器（boundary router）进行传输。 123456789graph TB A[AS内部路由选择算法] A--&gt;B[RIP] B--&gt;B1[通告] B--&gt;B2[链路失效和恢复] B--&gt;B3[进程处理] A--&gt;C[OSPF] C--&gt;C1[高级特性] C--&gt;C2[层次化] 5.4 ISP之间的路由选择: BGP ——自治区域之间进行路由 层次路由 自治区域AS（一个平面的路由）：每次交换信息所有路由器地位一样，维护所有路由器的可达信息。——巨型网络代价太大。 平面路由的问题： 规模巨大的网络中，路由信息的存储、传输和计算代价巨大 管理问题：按照自己的方式管理网络，隐藏自己网络的细节 层次路由：“autonomous systems” （AS） 将互联网分成一个个AS(路由器区域) 一个AS用AS Number （ASN)唯一标示 一个ISP可能包括1个 或者多个AS 每个区域内采用自己的路由协议算法 自治区域之间运行AS间路由协议 优点： 解决了规模问题：AS内部规模可控、每次在总体增加一个节点，扩展性强。 解决了管理问题：各个AS运行不同的内部网关协议、不透露自己的细节。 BGP 互联网AS间路由：BGP ——BGP (Border Gateway Protocol)：边界网关协议-将互联网各个AS粘在一起的胶水 两种方法： eBGP（相邻的ASes那里获得子网可达信息） iBGP（将可达信息传遍到AS内部的所有路由器） ——基于改进的距离矢量算法：不仅包含代价、也包含详细路径（可以避免环路，保证收敛速度） 网关路由器同时运行eBGP和iBGP协议，通过eBGP向其他网关路由器通告自己的子网可达信息，转发其他的子网可达信息，信息包含在TCP分组当中，使用内部网关协议进行路由。（红色的虚线不是物理链路，只是TCP虚拟逻辑链接） BGP基础 BGP 会话：两个BGP路由器（peers）开机就建立半永久TCP连接，交换BGP报文，通告向不同目标子网前缀的“路径”——“路径矢量”协议，包含每一步到达子网X的跳数序列。 路径的属性&amp; BGP路由： 属性：AS-PATH、NEXT-HOP（本AS中从哪个网关送走） 路由：自治区之间更加强调策略——哪些转发哪些屏蔽，是否接受是否转发等等。 路径通告： 基本过程：eBGP从其他AS接受通告，iBGP通告给自己AS内部的路由器，连接其他AS的路由器转发通告，加码（加入本AS的跳） 多条可达信息通告时，保留更优的可达路径——对路径打分（基于策略-政治策略、经济策略） BGP报文：OPEN、UPDATE、KEEPALIVE、NOTIFICATION——非常复杂，本科了解即可 BGP OSPF, 转发表表项：内部普通路由器通过iBGP学习到了子网X，如何选择网关到达对应子网路由器。根据内部网关协议选择最优路径，内外结合匹配。——路由表项是由AS内和AS间的路由共同决定的。 BGP 路径选择： 本地偏好值属性 最短AS-PATH（跳数） 最近的NEXT-HOP路由器：热土豆路由——尽快送出去，不操心域间代价 附加的判据（随机、BGP标示等） 通过路径通告执行策略：每个ISP感知到的网络和真实不一致（没有收益的路径不去通告）；多宿桩网络，接入多个ISP，一般不会通告自己的ISP可达信息帮助不同ISP传递信息。 为什么内部外部那么不同？ 策略：AS内无需策略，尽可能快；AS外控制通信路径 规模：AS内不用太考虑，因为可以细分AS；AS外必须考虑规模 性能：AS内性能第一；AS外会有政治、经济等考虑因素 1234567891011graph TB A[ISP间路由选择算法] A--&gt;B[层次路由] B--&gt;B1[AS概念] B--&gt;B2[平面路由问题] B--&gt;B3[层次路由优点] A--&gt;C[BGP] C--&gt;C1[BGP基础了解] C--&gt;C2[使用原因] C--&gt;D((eBGP)) C--&gt;E((iBGP)) 5.5 SDN控制平面 复习 传统方式 vs SDN方式——水平集成：南向接口、网络操作系统（网络控制器）、本地控制代理、流表 管理更加容易、可编程（集中式）——可以实现各种功能、未来的功能。 传统方式无法设置路径、负载均衡、不同流量采取不同的路由方式。 ——基于流表的匹配+行动模式。 SDN 架构：（上一章讲过） 数据平面交换机 SDN控制器 控制应用 SDN控制器 SDN控制器里的元件： 通信层：南向接口（OpenFlow SNMP） 网络范围的状态管理层：分布式数据库 网络控制应用的界面层：抽象API（北向接口） OpenFlow 协议： 控制器和分组交换机交互协议 TCP 交换、加密可选 3种OpenFlow报文类型：控制器&gt;交换机、异步（交换机&gt;控制器）、对称 控制器-交换机 特性：状态查询 配置：设置参数 修改状态：增删查改流表 packet-out：没匹配到的分组下发转发方案 交换机-控制器 分组进入：没匹配到的分组发给控制器让控制器决定 流移除：在交换机上删除流表项 端口状态：通告控制器端口的变化 ——网络管理员编程app，自动生成对应流表下发给分组交换机。 例子： 南向接口上报 控制器更改信息库，通告应用程序 北向接口被调用（之前注册过） 应用程序重新运行路由选择 下发路由信息到控制器自动计算流表 控制器更新分组交换机的流表 SDN控制器类型：（了解即可） OpenDaylight (ODL) 控制器：北向接口叫REST API——控制应用可以在控制器内也可以在控制器外 ONOS 控制器——控制应用和控制器分离 SDN面临的挑战： 可靠性（SDN控制器失效会宕机） 性能可扩展性：性能跟不上会成为瓶颈 可信性：安全性，怎样认证 特殊应用场景：实时性，超高可靠性、超高安全性 互联网络范围内的扩展性（全网） 12345678graph TB A[SDN控制平面] A--&gt;B[复习] A--&gt;C[SDN控制器] C--&gt;C1[元件] C--&gt;C2[OpenFlow协议] C--&gt;C3[控制器类型] C--&gt;C4[挑战] 5.6 ICMP: 因特网控制报文协议 由主机、路由器、网关用于传达网络层控制信息：错误报告、Echo 请求和回复（ping） 处在网络层，运行在IP协议上（侵入传输层） ICMP 报文：类型、编码、第一个导致该ICMP报文IP数据报的头8B 例：ICMP做跟踪路由（发送测试包到不可达端口，中途路由器发送type11 code0回复，三次取平均计算RTT；目标主机发送type3 code3，收到停止） 5.7 网络管理和SNMP ——自治系统（autonomous systems AS）的管理 5大功能： 性能管理 故障管理 配置管理 账户管理 安全管理 网络管理架构： 管理实体 被管设备（被管对象）数据被收集在Management Information Base (MIB) SNMP协议： 请求/响应模式 陷阱模式 报文类型（略） 总结 控制平面功能实现：传统、SDN 传统路由选择算法：DV、LS 协议：內部（RIP、OSPF）、外部（BGP） SDN方式的实现","tags":[{"name":"计网","slug":"计网","permalink":"https://renzehua1998.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"计算机网络第四章","date":"2022-09-03T04:00:00.000Z","path":"2022/09/03/计算机网络自顶向下/第四章/","text":"计算机网络自顶向下书籍中科大B站课程笔记 第四章 网络层：数据平面 前几章在网络边缘，进入网络核心部分。 导论（数据平面、控制平面） 路由器结构组成 IP协议（格式、分片重组、地址转换、IPv4、IPv6） SDN情况下数据平面（流表匹配） 4.1 导论 ——数据平面、控制平面 服务模型 转发和路由——分别是数据平面和控制平面，分为传统方式和SDN方式（四种） 路由器工作原理 通用转发 ——协议实例与实现 功能概述 网络层服务： 主机对之间传送段（封装的传输层TCP段UDP数据报） 封装、解封装 协议存在于每个主机和路由器，路由器检查所有IP数据报头部 关键功能： 转发：输入接口转发到输出接口（局部功能） 路由：选择路径到达目标主机（全局功能）——算法、协议 数据平面、控制平面： 数据平面：转发（依靠路由表）——本地。传统：地址+转发表；SDN：多个字段+流表。 控制平面：路由（生成路由表）——全局。传统：路由器中实现；SDN：远程的服务器实现。 传统方式仅依靠IP地址，SDN方式匹配流表依靠一系列字段（MAC、配置信息等），SDN除了转发还可以阻止（block）、泛洪、修改等。SDN厂家的网络控制服务器通过南翔接口算出来流表分配给每个主机。 传统方式和SDN方式： 传统方式：路由器 分布式计算路由表（Per-router），两个平面紧耦合。——很难改运行逻辑。 SDN方式：分组交换机通过南向接口收到网络服务器的集中控制，两个平面分开。——很好改、可编程。 SDN：软件定义网络（software defined network） 服务模型 指标： 单个数据报：可靠性、延迟。 数据报流：保序性、带宽、延迟差（jitter）。 下下页具体模型（这些指标为特定值时表示某种模型） best effort（尽力而为）：全部无法保证——IP CBR（恒定速率）——下面都是ATM VBR（变化速率） ABR（可用比特率） UBR（不指名比特率） 连接建立 某些架构中有连接（和传输层面向连接区别——连接还体现在交换路径上），如ATM等。 IP无连接建立的功能。 网络层和传输层连接服务区别： 网络层: 在2个主机之间，涉及到路径上的一些路由器 传输层: 在2个进程之间，很可能只体现在端系统上 1234567891011graph TB A[导论] A--&gt;B[功能概述] B--&gt;B1[数据/控制平面] B--&gt;B2[传统/SDN方式] A--&gt;C[服务模型] C--&gt;C1[各种指标] C--&gt;C2[具体模型] A--&gt;D[连接建立] D--&gt;D1[ATM网络] D--&gt;D2[和传输层区别] 4.2 路由器组成 结构概况 路由：路由处理器（运行路由实体软件）产生路由表 转发：输入端口、输出端口、交换机（根据路由表局部转发）——真实路由器端口既可以输入也可以输出 每个路由器设备涉及三层的数据：物理层、数据链路层、网络层。最多拆分到网络层。 输入端口 物理层：物理信号转换成数字信号； 数据链路层：检测帧头帧尾，检测是否出错，提取目标mac，一致则收取，把帧交给网络层实体； 网络层实体排队，根据路由表，排到队头根据目标IP转发到对应主机。（SDN则查流表，执行对应操作） 为转发地址空间进行划分，不同地址空间转发到不同的端口。采用最长地址前缀匹配的目标地址表项。 一般使用TCAMs( ternary content addressable memories)硬件实现，在IP匹配时也总使用。 可以在一个时钟周期内检索出地址，不管表空间有多大 Cisco Catalyst系列路由器在TCAM中可以存储多达约为1百万条路由表项 交换结构 ——switch fabric 存在队列缓冲的原因：存在头部阻塞（Head-of-the-Line (HOL) blocking）如多入一出，匹配输入输出速率瞬时不一致性。 局部交换速率要n倍于发送速率（n为输入输出端口个数） 三种典型交换结构： 基于memory（内存）：第一代，拷贝到系统内存头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口。——经过两次系统总线，收到内存带宽限制，一次只能转发一个分组。 基于bus（总线）：此总线不是系统总线，而是switch fabric。——收到总线带宽限制，一次处理一个分组，对于企业网、接入网速度完全够。 基于crossbar（互联网络）：Banyan（榕树）网络，crossbar(纵横)和其它的互联网络（不同于互联网！）。每次把不同两根线之间短路即可随时接通。可以把分组切开，通过网络时间固定，便于调度。——克服总线带宽限制，对于骨干网来说常使用。 输出端口 物理层：把链路层的数据变成物理信号打出去； 链路层：帧封装，加帧头帧尾，校验等等功能； 网络层：排队，排到队头转发，交给链路层网卡。 存在缓存队列原因：交换结构速度和输出端口瞬时速度不一致。溢出则会被抛弃掉。 存在调度规则，不一定先来的先发（保证对某些应用服务质量的支持）。 缓存建议规则（自己看）：拇指规则等。 调度机制： FIFO (first in first out)先到先出 丢弃策略： tail drop：丢弃刚到达的分组 priority：根据优先权丢失/移除分组 random：随机地丢弃/移除 优先权调度：多类，不同类别有不同的优先权。先传高优先级的队列中的分组 Round Robin (RR)：循环所有类，公平轮换。 Weighted Fair Queuing (WFQ)：每种分组享用不同权重的优先级占比。 1234567891011121314graph TB A[路由器组成] A--&gt;B[结构概况] B--&gt;B1[三层数据操作] A--&gt;C[输入端口] C--&gt;C1[最长地址前缀匹配] C--&gt;C2[缓存排队] A--&gt;D[交换结构] D--&gt;D1[内存] D--&gt;D2[总线] D--&gt;D3[互联网络] A--&gt;E[输出端口] E--&gt;E1[缓存排队] E--&gt;E2[调度机制] 4.3 IP: Internet Protocol ——互联网的网络层：路由协议、ICMP 协议（信令协议：报错、测试网络是否通畅-ping）、IP 协议 IP协议实现数据平面的转发功能：• 地址约定 • 数据报格式 • 分组处理的约定 IP 数据报格式 头部：无选项20字节（有可选项，可变长） 协议版本号（IPv4 0100） 头部长度（以一当四，即最后乘4字节） 数据类型（载荷类型，基本废弃了） 数据报总长 16位分组的id标识、标志位、偏移量（用于分片重组）——第二行 TTL（存活倒计时）、上层协议的标识、头部校验和（不校验数据） 32位源IP、32位目的IP 可选内容（Options）：一般没有，有的话可以记录自己的路径 内容（载荷）：上层协议传输的数据 分片和重组 网络链路有MTU (最大传输单元)，不同链路层协议的最大承载量不同。 大的IP数据报在网络上被分片，需要在接收端重新拼接起来。（8字节切分）。 路由器转发的时候不去组合，只管转发，不同片可能经过不同的路径。 有某一片（Fragment）没到，所有片全部丢弃。 分片的方法： 相同的ID，表示属于同一个分组 不同的偏移量，表明这一片在分组中的未知 最后一个分片fragflag标记为0，表示后面没有分片了（传完了） IPv4地址 ——IP地址：标识网络设备（主机、路由器）的接口。32位标示，对主机或者路由器的接口编址。 路由器IP地址一般有两个或两个以上IP地址、主机可以只有一个IP地址。 有线以太网网口链接到以太网络、物理上可以使用交换机连接、无线WiFi接口被WiFi基站连接——同一子网下一跳可达，服务由链路层提供。 子网的定义： 设备和接口断开，构成了一个个网络的孤岛。 可以分为纯子网、非纯子网（纯子网组成的） 子网的特点： 前缀一样（高位部分相同）、 无需路由器介入（交换机在IP层面看起来就是一跳）——一跳可达 例子，几个子网？ 局域网一般多点连接（通过交换机）、长途连接一般只有两点。 一共有6个子网（路由器之间算长途连接，一个子网就两点） IP 地址分类： 单播地址：点对点 A类：第一位为0，7bit代表网络号，24bit代表主机号 网络数：128-2=126个，全0，全1不使用； 主机数：2^24-2个. B类：前两位10，14bit代表网络号，16bit代表主机号 网络数：2^14-2个； 主机数：2^16-2个. C类：前三位110，21bit代表网络号，8bit代表主机号 网络数：2^21-2个； 主机数：2^8-2个. 组播地址：发给属于组内的主机可以接收到 D类：前四位1110，28bit代表组播地址号 E类：前5 为11110，27bit预留将来使用 广播一般不用在互联网，只用在局域网通信。 以子网为单位散播子网可达信息，便于组织，一般通过对不同子网进行聚集进一步简化组织查找。 特殊IP地址： 主机号全为0---本网络 网络号全为0---本网络上的某个主机 32位全为0--本主机 主机部分:全为1--广播地址，这个网络的所有主机 32位全为1--本网络广播地址 只有主机部分全1--远程网络广播地址 127开头：回路地址--到IP层会反转朝上。 内网(专用)IP地址： ——永远不会被当做公用地址来分配，路由器也不会转发这些IP的分组。 Class A 10.0.0.0-10.255.255.255 MASK 255.0.0.0 Class B 172.16.0.0-172.31.255.255 MASK 255.255.0.0 Class C 192.168.0.0-192.168.255.255 MASK 255.255.255.0 无类域间路由：CIDR ——按需分配，不完全按照字节进行划分网络号和主机号，根据需求在任意未知切分。 a.b.c.d/x, 其中 x 是地址中子网号的长度 子网掩码：32位，1代表网络号，0代表主机号 路由的时候，和子网掩码进行与操作即可提取出子网号。 转发表表项：目标子网号、子网掩码、下一条、接口。 转发算法：目标地址与子网掩码、匹配目标子网号、将分组转发到不同的接口、发送到下一跳。最后一个路由器解析主机号，转发到对应的主机。——都没有找到,则使用默认表项转发数据报 如何获得一个IP地址： 一、主机：配置四项信息 在主机里面配置：IP地址、子网掩码、默认网关、local-nameserver。 DHCP（动态主机配置协议）：自动获取四个信息。允许主机在加入网络的时候，动态地从服务器那里获得IP地址等信息。plug-and-play 刚开始源地址0.0.0.0表示本机，目标地址255.255.255.255广播。可能有多个DHCP所以还需要第二次握手确认。——运行在UDP之上 主机广播寻找DHCP服务器 DHCP 服务器响应 主机请求IP地址 DHCP服务器发送地址、子网掩码等四项信息 自己看一下两次交互的过程 二、子网：从ISP获得地址块中分配一个小地址块 ——进一步把主机号做拆分，可以嵌套地划分子网。 层次编址: 路由聚集 子网路由器向主网路由器发布通告，表明该路由器就是该子网前缀的下一条。 主网路由器向自己的ISP发布路由通告，综合多个路由信息向外发布 层次编址: 特殊路由信息 聚集的时候支持有空洞的大概聚集，匹配时可能有多个表项与IP匹配，采用最长前缀匹配。 聚集可以有效减少路由通告的数量，节约资源与计算代价。 不同子网掩码也可以使用同一个路由器进行聚集，如公司收购的情况，通告加入不同表项即可。 三、ISP：向ICANN机构申请 网络地址转换：NAT ——内部有内网地址，在互联网共享一个外网地址，记录每台设备的分组对应于外网的端口即可。 动机：1.省钱（IP不够用），2.可以方便更改内部IP，3.可以更改ISP，而不用改内网IP，4.外部看不到内网情况。 实现: 外出数据包：替换源地址和端口号为NAT IP地址 和新的端口号，目标IP和端口不变 记住每个转换替换对 进入数据包：替换目标IP地址和端口号，采用存 储在NAT表中的mapping表项，用（源IP，端口） 存在的问题：外部主动连接内部会找不到对应主机和端口，需要进行内网穿透。 争议： 违反分层原则（网络层更改了传输层内容） 违反端到端原则，网络核心设备具备了复杂性 地址短缺问题可以被IPv6 解决 NAT 穿越问题： 静态配置映射 UPnP协议、IGD协议：动态查询、增加、删除映射表项。 中继：中继在2个连接之间桥接 IPv6 动机： IPv4用完、分组切片重组负担很大、每次头部变化需要重新校验、头部格式改变帮助QoS IPv5是实验室版本，被废弃了。 IPv6不允许分片，128位地址，40 字节头部。分组太大了发送错误报告让源主机自己切分。 头部字段： 版本号 优先级 流标签（对同一个流的数据做同样的处理） 载荷长度 Next header-上层协议 hop limit-跳数限制 源、目的IP 移除了Checksum、在头部之外, 被 “Next Header” 字段标示、ICMPv6: ICMP的新版本 从IPv4到IPv6的平移： 迁移：逐步升级，不能设置flag day。 设置同时支持两种协议的路由器进行转换。 隧道Tunneling：在IPv4路由器之间传输的IPv4数据报中携带IPv6数据报 ——至少还需要20年以上 12345678910111213141516171819graph LR A[IP] A--&gt;B[数据报格式] B--&gt;B1[16位分组的id标识 标志位 偏移量] A--&gt;C[分片和重组] C--&gt;C1[分片原因] C--&gt;C2[分片重组方法] A--&gt;D[IPv4] D--&gt;D1[子网定义] D--&gt;D2[IP地址分类-特殊规定] D--&gt;D3[无类域间路由-子网掩码] D--&gt;D4[如何获得IP] D4--&gt;D41[主机] D4--&gt;D42[子网] D4--&gt;D43[ISP] A--&gt;E[NAT] E--&gt;E1[动机 实现 争议] A--&gt;F[IPv6] F--&gt;F1[动机 数据报格式 向IPv6迁移] 4.4 通用转发和SDN 网络层功能：转发、路由（控制平面数据平面相互配合）——传统方法：垂直集成、分布式实现、每个路由器都包含数据平面和控制平面。 使用原因 传统方法特点：他种类繁多网络设备更改很难，控制平面分布式实现，行为僵化、升级管理很难。 垂直集成：硬件、操作系统、协议都私有 每台设备包含所有层面的功能：控制功能分布式实现 控制逻辑固化：按照固定方式工作 传统方法问题： 昂贵 无法改变工作逻辑 管理困难 更新困难 ——2005年开始重新思考网络控制平面的处理方式： 集中：远程的控制器集中实现控制逻辑 远程：数据平面和控制平面的分离 SDN：逻辑上集中的控制平面 远程计算流标，通过南向接口发送到每台分组交换设备，增加匹配规则和对应的操作。 可以随时更改升级 可以让多个分组交换机厂商参与竞争——更好的生态 可以在网络操作系统上运行网络应用 主要思路： 网络设备数据平面和控制平面分离 数据平面-分组交换机：动作有转发、丢弃、拷贝、泛洪、阻塞 控制平面-控制器+网络应用 分离的优势： 水平集成控制平面的开放实现创造出好的产业生态 集中式实现控制逻辑，网络管理容易 基于流表的匹配+行动的工作方式允许“可编程的”分组交换机 ——类比: 主框架到PC的演变，水平集成带来业界的繁荣。 传统方法流量工程的问题： 自主选择路径，只能通过改变链路代价来实现，非常困难且无法按自己需求实现 两路分拆负载均衡，无法完成，只能完全更换新路由算法 不同流量走不同路由，无法完成，只能基于目标进行转发 SDN特点： 分组交换机通过流表进行动作（常见协议OpenFlow） 控制平面和数据平面分离 控制平面功能在数据交换设备之外实现 可编程控制应用：控制器之上以网络应用形式实现各种网络功能 SDN 架构： 数据平面交换机： 基于南向API（例如OpenFlow），SDN控制器访问基于流的交换机 使用流表进行匹配控制，流表被控制器计算和安装 采用硬件实现通用转发功能，快速简单 定义了和控制器的协议 SDN控制器 维护网络状态信息 通过上面的北向API和网络控制应用交互 通过下面的南向API和网络交换机交互 逻辑上集中，物理上可以分布式实现 控制应用 控制的大脑： 采用下层提供的服务实现网络功能：路由、接入控制、防火墙、负载均衡 非绑定：可以适配不同公司的设备，生态更健康。 通用转发和SDN过程：查看分组条目属性、匹配流表表项（头部、计数、操作等等）、执行对应操作 OpenFlow 数据平面抽象： 流: 由分组（帧）头部字段所定义（广义的分组） 通用转发：简单的分组处理规则 模式：字段属性 行动：丢弃、转发、修改等 优先权：优先选择那个匹配上的表项 计数器：匹配上后就+1，有#bytes级别和#packets级别 流表的表项结构： Rule（规则、模式）：十几个字段 Action（行动）：各种操作 Stats（状态、计数）：基于包、基于字节 OpenFlow 抽象： match+action（匹配+行动模式）: 统一化各种网络设备提供的功能 路由器：基于目标的转发 防火墙：基于目标端口、基于源IP等禁止 交换机：来自对应mac地址的分组进行转发 NAT：匹配IP地址和端口号进行重写 各种操作……实现各种各样的功能 例子：精确控制两台主机交互数据的路径，在每台分组交换机的流表中进行配置。 12345678910111213graph TB A[通用转发和SDN] A--&gt;B[使用原因] B--&gt;B1[传统方法问题] B--&gt;B2[SDN特点] A--&gt;C[SDN] C--&gt;C1[水平集成优势] C--&gt;C2[SDN架构] A--&gt;D[OpenFlow] D--&gt;D1[数据平面抽象] D1--&gt;D11[流 通用转发 表项结构] D--&gt;D2[OpenFlow抽象] D2--&gt;D21[match+action] 总结：路由表、流表怎么来？——控制平面（下一章）","tags":[{"name":"计网","slug":"计网","permalink":"https://renzehua1998.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"计算机网络第三章","date":"2022-09-01T04:00:00.000Z","path":"2022/09/01/计算机网络自顶向下/第三章/","text":"计算机网络自顶向下书籍中科大B站课程笔记 第三章 传输层 传输层的原理。 多路复用/解复用、 可靠数据传输（RDT-经典核心内容）、 流量控制、 拥塞控制（原因、表现、检测、控制）。 传输层协议。 UDP TCP TCP拥塞控制 3.1 概述和传输层服务 传输服务和协议： 进程之间以报文（message）为单位的逻辑的通信。 发送方拆分为报文段，接收方再去掉头、重组。不表示报文界限（字节流的服务）。 有多种协议可选：Internet——TCP、UDP。 传输层 vs. 网络层： 网络层：主机之间；传输层：进程之间。 不可靠 -&gt; 可靠是可以加强的；不安全 -&gt; 也是可以加强的；但是延迟和带宽这些品质是不可以加强的。 最重要的品质加强：复用/解复用，源端做复用、目标端解复用。（通信的双方互为源和目的）。 Internet传输层协议： 可靠的、保序TCP：多路复用/解复用、拥塞控制、流量控制、建立连接。——字节流 不可靠、不保序UDP：多路复用/解复用、无额外更多的服务。——数据报 二者都不能保证带宽和延迟。 123456789graph TB A[传输层概述] A--&gt;B[协议] B--&gt;B1[TCP] B--&gt;B2[UDP] A--&gt;D[进程间通信] A--&gt;C[与网络层对比] C--&gt;C1[主机与进程] C--&gt;C2[复用/解复用] 3.2 多路复用与解复用 通过端口号来实现多路复用、解复用。TCP socket一个整数包含四元组、UDP socket一个整数包含二元组。 TCP往下交两个东西：socket、数据内容。源端根据socket提交端口、IP信息，目标端收到后根据端口、IP查询socket向上传递，交给正确的应用进程。 UDP要多交一个东西：目标端口+IP。源端根据信息传送，目标端根据目标端口+IP信息找到对应socket找到进程。 复用：从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装。 解复用：根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)。 无连接多路复用例子：UDP中socket只与本机IP端口相关，即接收方只根据目标端口和IP查找socket即可。 面向连接的解复用例子：四元组有一个不一样就会定位给不同的socket，发送到不同的应用进程（同一进程的不同线程）。 12345678graph TB A[多路复用/解复用] A--&gt;B[TCP/四元组] B--&gt;B1[复用] B--&gt;B2[解复用] A--&gt;C[UDP/二元组] C--&gt;C1[复用] C--&gt;C2[解复用] 3.3 无连接传输：UDP 概述 概述：仅增加了复用、解复用的功能。没有加入其他新功能。可能有丢失和乱序、无连接。 常见应用：流媒体、DNS、SNMP（简单网管协议）。 一般常见：流媒体、事务型应用（一次往返解决）。 UDP上可行可靠传输：应用层增加可靠性、特定差错恢复。 协议 协议：UDP数据报格式： 8字节头部——2字节源端口号、2字节目的端口号、数据长度（包括头部）、校验和EDC。 报文部分——校验和出错后全部丢掉。 必要性：不用连接、简单、载荷占比大（头部小）、没有流量拥塞控制。 校验和：校验范围（D）的和，判断是否出现了差错。没有通过校验一定错，通过校验不一定错（残存错误）。 发送方做差错控制编码，接收方做差错控制解码。——存在保护范围：数据、头部、部分其他内容。按照16bit的单位分开、每16bit全部加起来作为一个校验和。 要注意的部分：除EDC的部分进位回滚（进位的1加到末尾），最后结果求反码（按位取反）；接收端加出来全1即通过校验。 12345678graph TB A[无连接传输: UDP] A--&gt;B[概述] B--&gt;B1[功能:复用/解复用] B--&gt;B2[常见应用] A--&gt;C[协议] C--&gt;C1[校验和-进位回滚] C--&gt;C2[残存错误] 3.4 可靠数据传输的原理 问题描述 （一般化的）可靠数据传输（RDT）：可能是数据链路层、应用层等等。下一层是不可靠数据传输（UDT）。 是网络Top 10问题之一。 rdt_send()和deliver_data()是本层和上层接口的原语；udt_send()和rdt_rcv()是本层和下层接口的原语。——针对本层来说。 假设：渐增式地开发、双向传输的是两个单向传输的结合、有限状态机 (FSM) 来描述发送方和接收方。 学习方法：先假设底层完全可靠，逐步增加底层的不可靠性，本层逐步添加机制，直到完成本层全部功能。 虽然数据通信是单向的，但是需要双向的信息交换。 有限状态机：通过图形的方式表示实体的状态、连接边的分子代表发生的事件、分母代表采取的动作。迁移到哪个状态取决于发生了什么事件。 可靠传输的需求：不出错、不丢失。 停等协议 （停止等待协议stop and wait）。 Rdt1.0（非停等） ——在可靠信道上的可靠数据传输 下层的信道完全可靠： 发送方：接收上层、封装、发送下层。 接收方：接收下层、解封装、交给上层。 Rdt2.x Rdt2.0——具有比特差错的信道（出错） 下层信道可能会产生反转出错： 确认(ACK)、否定确认( NAK)：发送方收到NAK后，发送方重传分组。 采用差错控制编码进行差错检测（EDC的用处）：差错控制编码、缓存-&gt;检错-&gt;反馈-&gt;相应的动作。 状态有所增加： 发送方：接收上层、封装、发送下层-&gt;等待对方反馈（NAK始终发旧的，ACK返回初始状态） 接收方：接收下层、没出错、解封装、交给上层、发送ACK；接收下层、出错了、发送NAK。 Rdt2.1——带序号控制 rdt2.0存在的致命问题：ACK/NAK可能出错、丢失。——序号（发送方在每个分组中加入序号） ACK/NAK出错的情况下，重新发送上一个分组，有可能形成重复，接收方收到重复直接丢掉发送ACK即可。 仅需要0和1两个序号，发送方四个状态、接收方两个状态。——一次只发送一个未经确认的分组。 状态都加倍了，因为有了0和1的分别。接收方收到不同于当前状态的分组（没错）时、丢掉再发ACK。 接收方不知道ACK/NAK是否被正确地收到，根据收到下一个分组的情况判断有没有收到。 Rdt2.2——无NAK的协议（只使用ACK，对它做编号）。 使用上一个分组的正向确认代替当前分组的反向确认（为一次发送多个数据单位做好准备）。 确认信息减少一半，协议处理简单。双方出错都能继续回到同步状态。 状态转移图和2.1基本相同，仅使用ACK0代替了NAK1，ACK1代替了NAK0。 Rdt3.0 ——具有比特差错和分组丢失的信道（超时重传：比正常往返稍微长一点） 动机：分组可能丢失，接收方没有收到，互相等待陷入死锁。——需要机制来打破。 超时时间设置不一定相同，数据链路层一般比较确定，传输层根据概率分布动态设置。 延时比较长的情况下重传可能造成数据重复，但是没有关系。 状态转移图也是四个状态，不同的是发送分组后启动定时器，超时重传；收到不同于当前的ACK继续等待，直到超时重传（和立即重传效果一样）。 一个数据传输的例子（超时设置的不好：过早地超时）：这种情况效率并不高，正常情况下50%或更低——一半 的分组和确认是重复的。 Rdt3.0已经是完备的协议了，可以对抗复杂的情况（出错、丢失）。 存在的缺点：在信道容量比较大的情况下，性能很差。 1 Gbps的链路（R），15 ms端-端传播延时（t），RTT=30ms，分组大小为1kB（L） 传输延迟8us，利用率0.027%，有效带宽270kbps。 瓶颈在协议本身——虽然能实现，但是太慢太慢，利用率非常低。 流水线协议 （流水线协议pipeline）。 允许发送方在未得到对方确认的情况下一次发送多个分组，最大限度地利用线路资源。增加序号的范围，有缓冲区进行控制。 最经典的流水线协议（管道化协议）。两种分类——回退N步(GBN go back N)、选择重传(SR selective repeat)。 缓冲区目的：发送方（选择重传）、接收方（速度匹配）。 滑动窗口协议 先看一般性协议滑动窗口协议（SW slide window）。 对于滑动窗口：SW=1，RW=1，停等；SW&gt;1，RW=1，退回N步；SW&gt;1，RW&gt;1，选择重传。 发送缓冲区：发送方同时能够发送多少未经确认的分组（没有确认需要缓存）。链路利用率不能够超100% 发送窗口：发送缓冲区的子集，存放已发送未确认的分组。发送窗口最大值小于等于发送缓冲区大小。 相对表示：分组不动、窗口向前滑动。 前沿滑动：发送出去一个分组，前沿往向前滑动；后沿滑动：收到确认后沿向前滑动（不能超过前沿）。 接收窗口：（等同于接收缓冲区）——接收方愿意接收多少分组。 RW=1，始终给出正确到来分组顺序到来最高序号的确认。回退N步——累积确认 RW&gt;1，收到接收窗口低序号最边缘的分组，才可以向前滑动。高序号到来可以缓存选择重传——非累积确认 窗口互动： 正常情况：同步向前滑动、传输过程不失序。发送方发送，前沿前滑；接收窗口接收、前滑、确认；发送后沿前滑。 异常GBN互动方式：最后分组乱序（丢失）到达。后面到来的分组抛弃掉，发送累积确认，发送方超时重新发送全部分组。 异常SR互动方式：分组乱序（丢失）到达，前面分组的确认始终没来，触发超时机制，只发送前方未经确认的分组，后面收到的不再重发。（每个分组提供一个定时器）。 GBN、SR相同点：一次能够可发送多个未经确认的分组；区别：乱序或丢失是否需要全部重发、累计确认vs非累计确认、是否为每个分组添加一个定时器。 GBN协议 发送方有限状态机： 初始化窗口=0 next=base。 新来分组在缓冲区范围之内，可以发送，base=next时，重设定时器。 超时了，窗口内全部重发。 收到确认信号，后沿向前滑动，base=next时，重设定时器。。 接收方有限状态机： 初始化进入到等待状态，用一个变量维护等待接收位置。 来到分组通过校验，序号和当前等待序号相同，解封装上交，发送确认，接收窗口向前滑动。 乱序分组之间丢弃，仅提供最高顺序分组的确认。 SR协议 非累积确认，仅对未确认分组进行重传。 主要区别： 发送方：每个分组设置定时器，重传超时的对应分组、收到最低确认，直接移到最低未确认处。 接收方：乱序数据缓存，低分组到来后同一上交，忽略超过范围的分组。 GBN简单，但是需要回退N步，出错回退代价大。SR复杂要维护多个缓冲区和定时器，回退代价小。 分组编号比特数为n时（序号空间大小），GBN协议最大窗口大小为2^n-1，SR协议最大窗口大小为2^(n-1) 1234567891011121314graph TB A[可靠数据传输的原理] A--&gt;B[停等协议] B--&gt;B1[rdt1.0] B--&gt;B2[rdt2.0-2.2] B2--&gt;B21[确认信号] B2--&gt;B22[序号控制] B2--&gt;B23[信号复用] B--&gt;B3[rdt3.0] B3--&gt;B31[重传] A--&gt;C[流水线协议] C--&gt;C0[滑动窗口] C0--&gt;C1[GBN协议] C0--&gt;C2[SR协议] 3.5 面向连接的传输：TCP 概述 点到点数据通信、可靠的字节流（不维护边界）、流水线-管道化（按MSS大小分成报文段）、发送接收缓存、全双工（同时双向）、面向连接（握手）、有流量控制拥塞控制。 MSS：最大报文段。因为以太网MTU-最大载荷单元有限（一般是1500字节） 报文段结构 head 源*端口号**（各16bit） 以字节为单位的序号（PDU第一个字节在整个字节流中的偏移量，32bit）初始序号不是从0开始的（防止冲突） 确认号：此处ACK表示对当前号及以后的分组的期待（例ACK 555表示收到了554及以前的-累积确认） 首部长度、保留位、标志位（RSF：建立TCP连接用） 接收窗口：用于流量控制。 校验和：进位回滚、反码。 紧急指针一般不用、可选项。 body 序号, 确认号 接收方没有规定如何处理乱序报文段（可删除可缓存） 标志位A置1，ACK确认号才有用 例子telne（回显），Seq和ACK的关系。ACK为希望对方下一个Seq的值，Seq为对方上一个ACK的值。 往返延时（RTT）和超时 需求： 合理的超时设置（有效保证利用率、不会造成太多重发） 一般设置起来是适应式的测量和计算——根据当前网络延迟情况。 设置原理：在短时间内延迟分布比较集中，需要动态自适应地设置——定期测量往返延迟。 方法： 对几个最近的测量值SampleRTT求平均EstimatedRTT——指数加权移动平均：α = 0.125 DevRTT——当前SampleRTT和EstimatedRTT的偏差的指数加权移动平均：β = 0.25 往返延迟均值+4倍方差：EstimatedRTT+4DevRTT 可靠数据传输 ——某些方面像GBN某些方面像SR。 不可靠基础上实现了rdt：管道化、累积确认、单个重传定时器、可以乱序 两种方式触发重传：超时、快速重传（连续收到三个冗余ACK） 简化的TCP发送方——忽略流量控制、重复确认：初始化，初始序号默认、有数据要发（前沿滑动、若无定时设置定时器）、超时到时仅重发最老的分组（再设置定时器）、收到ACK，重设base（后沿滑动），还有未确认字节重启定时器，没有未确认字节时关闭定时器。 伪代码展示此功能实现。 示例1Seq=92，发送了8字节，ACK=100丢了，超时重发92，继续ACK100。（顺序到来的最后一个字节给ACK） 示例2连续发92/8，100/20，92的ACK100超时，重发92/8，收到ACK120，直接移动base到119，超时设置长的话就避免了重发。 产生TCP ACK的建议：隐忍不发（提高效率）、攒够两个立即发确认、乱序到来赶快请求前面丢的段、部分补齐了缺失，赶快发送剩余缺失的ACK。 快速重传：未超时就收到这个段的三个冗余请求——在定时器过时之前重发报文段（算法表示）。 流量控制 缓冲区TCP往里面写，app从当中读取 通过接收窗口告诉发送方空闲尺寸，用于让发送方控制——典型默认大小为4096 字节 捎带技术：使用反向的传输携带反馈信息 RcvWindow= RcvBuffer-[LastByteRcvd - LastByteRead] 连接管理 ——连接建立和连接拆除（同意建立连接、同步、分配资源、变量置位——商量起始序号、缓冲区大小） 连接建立： 两次握手挑战：请求可能丢失、超时、乱序。 服务器响应重发的连接请求（维护了很多虚假的半连接） 重发的连接请求和连接数据都在响应完毕后到达，服务器又响应一整个虚假会话。 三次握手：分别给初始序号，给对方确认（其中两步可以复用），至少三次握手。第三次交互往往和第一次数据传递放在一起。 三次握手可以避免虚假半连接（发送请求方主动关闭）、避免重复响应（没有连接直接扔掉数据、新连接同时开启——初始序号的作用，可以筛选掉老的数据） 一些细节的状态转移图（自己看即可 左边接收方，右边发送方） 连接拆除： 两个方向单独对称式拆除——每一个方向发送一个拆除请求，再回复一个同意拆除响应。（并不完美，存在一方维持连接一方拆除的问题——最后一段不可靠就不可以让连接完美拆除——打仗通讯的例子） 一个填补方案：设置定时，超时没有数据了就真正断开了（也不完美）。 1234567891011121314graph TB A[面向连接传输: TCP] A--&gt;B[概述] B--&gt;B1[MSS最大报文段] A--&gt;C[报文段结构] C--&gt;C1[序号, 确认号] C--&gt;C2[超时设置] A--&gt;D[可靠数据传输] D--&gt;D1[快速重传] D--&gt;D2[超时重传] A--&gt;E[流量控制] A--&gt;F[连接管理] F--&gt;F1[三次握手] F--&gt;F2[四次挥手] 3.6 拥塞控制原理 拥塞：数据超过网络处理能力。表现：分组丢失率高很多、延迟很高。也是Top10的问题！ 拥塞的原因/代价 场景1：2个发送端，2个接收端。路由器无限大的缓冲。吞吐量达到R/2，接收不再增加，拥塞趋近于无限大。 场景2：一个路由器，有限的缓冲。传输层包括重传，丢失多了重传多 ，λ'变大。 2.1：发送端知道路由器缓冲区大小，λ'=λ。 2.2：发送端掌握丢失信息，比接收方带宽高一些才能保证原始速率传输。 2.3：存在重复的可能（超时导致重传），输出比输入少，最终输出接收也达不到R/2。 正反馈变坏，越拥塞越加大，最终导致更加拥塞。——加速变坏 场景3：4个发送端，多重路径，超时／重传。发生拥塞时，空闲空间被最近流量抢走，最终都无法送达（死锁）被抛弃分组的上游传输能力被浪费。 拥塞控制方法 目的：在不发生拥塞的前提下尽可能地提高传输速率。 端到端拥塞控制：端系统自己判断是否发生拥塞。TCP 网络辅助的拥塞控制：网络核心为端系统提供网络状态辅助信息。ATM 例：ATM网络 ——网络辅助拥塞控制 异步传输网络，曾经互联网的一个实现，数据交换单位叫信元（53字节，5字节头部），很小。 延迟比线路交换大，比分组交换小，延迟固定，调度较容易。最终没有广泛使用。 ABR 拥塞控制：弹性服务——无拥塞时可以超过要求带宽，拥塞后会限制带宽。 available bit rate 信元分为数据信元和资源管理信元（RM），把资源管理信元的某些位置位 资源管理信元——NI bit轻微拥塞（速率不增加）、CI bit明显拥塞（降低速率）、ER字段（网络可以为两台主机提供多大带宽） 数据信元——EFCI bit设置成了1，RM信元中CI bit就要置位。 123456789graph TB A[拥塞控制原理] A--&gt;B[原因/代价] B--&gt;B1[2设备无限缓冲] B--&gt;B2[2设备有限缓冲] B--&gt;B3[多设备有限缓冲] A--&gt;C[控制方法] C--&gt;C1[端到端: ATM] C--&gt;C2[网络辅助] 3.7 TCP 拥塞控制 ——端到端拥塞控制，减小网络核心压力 几个问题：检测拥塞（轻微拥塞、拥塞）、解决拥塞（轻微拥塞、拥塞）、不产生拥塞的情况下提高速率 拥塞感知 超时：拥塞丢弃或错误丢弃。（误动作很少，即出错丢弃情况很少）——拥塞的指示 三个冗余ACK（一共4个确认），认为当前这个段丢失了（快速重传）——轻微拥塞的指示 速率控制方法 CongWin/RTT=rate——未确认情况下可以注入多少字节/往返延迟=单位时间注入多少字节 超时，CongWin降为1MSS（一个分组大小），进入慢启动阶段（1RTT后加倍）直到加到CA——SS阶段 3个重复ack，CongWin降为原来的一半——CA阶段 SS阶段每个RTT加倍，CA每个RTT线性增加1MSS。 ——拥塞控制和流量控制联合处理SendWin=min{CongWin, RecvWin}同时满足了流量控制和拥塞控制的目的。 策略概述 ——慢启动；线性增、乘性减少；超时事件后的保守策略 慢启动 刚建立时CongWin = 1 MSS，指数性增加发送速率知道发生丢失，初始值很大，后面增加非常快。 ——每收到一个ACK时，CongWin加1。 AIMD：线性增、乘性减 丢失事件后将CongWin降为1，将CongWin/2作为阈值， 三个冗余ACK时，不降为1，而是直接变成CongWin/2， 进入慢启动阶段。下次倍增到CongWin/2，（可忽略不计） CongWin&gt;阈值时，每次加1MSS线性增加。——锯齿形 保守策略：参照表格、拥塞控制状态图 CongWin＜Threshold——指数增长 CongWin&gt;Threshold——线性增加 三个重复的ACKs——Threshold=CongWin/2，CongWin=Threshold+3，线性增加 超时事件——Threshold=CongWin/2，CongWin=1 MSS，进入SS阶段 补充 吞吐量： W：发生丢失事件时的窗口尺寸，平均窗口尺寸3/4W，平均吞吐量3/4(W/RTT) 未来：网络带宽增加需要保证更低的丢失率 公平性：多个主机对分享了瓶颈带宽 每一个会话的有效带宽为 R/K——举例，假设k=2，RTT=RTT'，按照上文方案，最终会收敛到公平位置。 UDP会对TCP连接产生更大的影响（对TCP不公平），两个主机建立多个TCP连接就会占用更多带宽，RTT小也会抢占更多带宽。 123456789101112graph TB A[TCP拥塞控制] A--&gt;B[拥塞感知] B--&gt;B1[超时] B--&gt;B2[三个冗余ACK] A--&gt;C[速率控制方法] C--&gt;C1[慢启动] C--&gt;C2[AIMD] C--&gt;C3[保守策略] A--&gt;D[补充] D--&gt;D1[吞吐量] D--&gt;D2[公平性] 总结 传输层提供的服务：为应用进程提供逻辑通信——主机进程之间 TCP/UDP 多路复用和解复用 ：TCP四元组、UDP二元组 UDP协议：多路复用解复用 UDP报文格式 检错机制：校验和 可靠数据传输：Rdt1.0-3.0-效率不高——流水线协议-GBN/SR TCP协议：报文段格式、可靠传输机制、重传，快速重传、流量控制、三次握手四次挥手（对称拆除） 拥塞控制原理：原因、代价、方式（端到端、网络辅助控制） TCP的拥塞控制：三大原则","tags":[{"name":"计网","slug":"计网","permalink":"https://renzehua1998.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"高级图论","date":"2022-08-24T04:00:00.000Z","path":"2022/08/24/高级图论/","text":"研一下高级图论课堂汇报：引文图+大作业：基于生成式超图聚类的网络告警日志归并框架。 课堂汇报课件：引文图 大作业论文：基于生成式超图聚类的网络告警日志归并框架 课堂汇报稿子： 简介 1 大家好，接下来由我为大家介绍引文图分析的相关内容。 2 论文报告主要分为四部分，引文图简介，论文中研究的引文图性质，文中提出的引文图划分方法和该领域后续的研究进展。 引文图 3 首先是引文图介绍，引文图又叫引文网络，在我们进行文献调研搜索的时候经常遇到。它是有向图，其中每个点代表一篇文章，每条边从一篇文章指向它所引用的文章。但有时按照不同的定义边可能会反向，比如说下面这个知网中的引文网络。 引文图属于社会网络的范畴但又有自己的特征：其中的边一旦添加不能随意删除，同时具有时间单向性：前面的文章不可能引用后面的文章。 引文网络在研究学科发展，计算影响因子，知识发现领域都有广泛的应用。 论文 4 我阅读的这篇文章是对引文图比较早的研究，他们在researchindex上面爬取了三个领域的论文，分别是神经网络，自动机和软件工程。分布构建各自的引文网络和联合网络。 在度分布上，引文网络属于服从幂律分布的无标度网络，也就是度数为i的节点比例和1/iy成正比，在对数坐标轴上是一条单调减的线。同时给出了入度分布参数为1.71，出度分布后半段参数为2.32。前半段不满足幂律分布，在10存在一个极值。这也很好解释，因为一般论文参考文献都有10篇以上，很少有论文引用少于10。 5 我们定义图中任意两点最短路径长度的最大值为图直径。在图直径方面，由于存在离散点，我们研究其最大连通分量的直径。在无向图上其直径为18，在三个网络极其联合网络上都满足。说明无向引文图满足小世界性，这使得网络上信息传递很快，任意两点都可以在几步内到达。 而在考虑有向图的情况下情况完全不同，对于强联通分量，两节点间有路径的概率仅为2％，其直径也在30左右，说明文章中极少存在互引的情况。 6 在连通性方面，引文网络中最大的弱连通分量占了90％以上的节点，而其中68％以上没有传入边，即未被引用。在这个分量内部58％的节点形成了双连通分量，剩余40％都是平凡双连通分量，即单节点。双连通的定义就是图中没有割点割边，任意两点见边数都大于1。 而在强连通分量上，我们与其的是里面完全没有强连通分量，但其实还是存在一些较大分量的。这是因为虽然存在时间引用限制，但是也存在同作者，同领域论文互引，同论文在不同期刊会议发表以及新版本引用那些引用过它的旧版本的情况。 7 最后作者进行了图划分的尝试，希望能够按照研究领域对论文进行划分。文中使用了递归嵌套的最小割算法，割集就是一组可以把图拆开的边，最小边割集就是其权重最小的一组割集。在全局上运行时，99％的划分都是把某一点单独拿出，不具备使用价值。作者尝试计算最不相关两篇论文的最小割，但这种情况分出来的结果高度不平衡，两个图节点数量之比达到了1:100，也没有意义。 说明了对引文网络的划分不可能用简单方法进行，必须对社区进行更精确的定义。 最新进展 8 下面是接下来的研究进展，在引文图划分方面，后面的研究者提出了社区检测的概念，拓宽了原框架。最小割方法属于基于划分的方法，并行的还有层次聚类，模块度优化等方法。模块度的概念很好地解决了这个问题，模块度可以理解为社区内权重减去社区间的权重。后面会有同学对这些算法进行详细介绍。其中最经典的是fast unfolding算法，通过迭代贪婪地最大化模块度指标得到更好的划分结果。 同时引文图的定义也得到进一步扩展，因为大家逐渐发现传统有向图难以描述共同引用的关系，所以提出了共引图，为了描述作者之间研究领域的相似性还提出了共同作者图。传统图很难表达多个节点的相同关联，所以引入了超图的概念，其中一条超边包括多个节点。 9 最后是引文网络在其他方向的研究进展。2007年有人发表了引文图相似性的研究，通过基于连接的相似性估计方法，寻找相似的文章。 2015年研究了引文图的采样与可视化呈现，通过矩阵分解的方法把用户最关心的文章摘取出来，通过可视化的方法呈现给用户。 2019年提出了引文图的连接预测，能够把互相无关引用关系但相关度强的论文对用户进行推荐。 这几个研究方向在后续都会有同学报告。 10 我的汇报到此结束，谢谢大家~","tags":[{"name":"算法","slug":"算法","permalink":"https://renzehua1998.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Python","slug":"Python","permalink":"https://renzehua1998.github.io/tags/Python/"},{"name":"图与网络","slug":"图与网络","permalink":"https://renzehua1998.github.io/tags/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"name":"Julia","slug":"Julia","permalink":"https://renzehua1998.github.io/tags/Julia/"}]},{"title":"电脑中毒处置","date":"2022-08-16T04:00:00.000Z","path":"2022/08/16/电脑中毒处置/","text":"研一暑假电脑中毒被通报了，以下是我的排查过程和反馈报告，引以为戒吧。 通报内容 安全事件名称：（10.xx.xx.xx/xx.xx.xx.xx）对应的系统存在 “后门-病毒感染”隐患 安全事件类别：系统后门 接收到整改通知时间：2022年8月15日 事件排查及发生原因 设备确认 查看电脑mac地址，与通报中设备匹配。 IP反查 使用IP反查网站，定位到通报中的控制端IP对应的域名，因为控制端端口为80，可以初步认定是HTTP服务端口。 恶意IP对应的域名为：cdr.jyxwlkj.cn 经过浏览器查询，此域名为有害网站： 浏览行为检查 因为此端口对应的是HTTP服务，所以从浏览器访问历史中查询对应域名的访问情况，果然： 发生原因 如下图所示，我在2022年8月9日进行科研工作中需要对二进制格式文件进行查看，于是准备下载Ultraedit软件。 但是没有从正规网站进行下载，点进了百度推荐的第一个链接，其域名为： http://cdr.jyxwlkj.cn/ue-ultraedit.html 下载链接为： http://cdr.jyxwlkj.cn/package/ultraedit.zip 下载的软件包含恶意木马程序，在安装完成后的8月10日，此软件中包含的木马后门进行了恶意外联并被安全部门发现。 损失及危害情况 经检查，本机电脑内数据未被加密篡改，经过查看本机网络日志，本机数据没有泄漏。实验室敏感数据平时并未存放于本机，通过服务器远程连接进行操作，所以对于敏感数据未造成泄漏。 事件处理过程及处置结果 在线沙箱测试 通过对下载的恶意文件使用在线平台进行沙箱测试，我还原了此软件进行逐步渗透并部署木马程序的过程： 1）综合评判：存在木马病毒 2）HTTP连接情况：恶意外联 全盘病毒查杀 检测到了3个安全风险，其中两个和此恶意软件有关，一个是下载的初始压缩包、一个是解压后的exe软件。另外还有一个盗版软件隐患： 已经对这些风险进行了全部处理。 电脑系统重置 为保证电脑中不存在未被发现的隐患，我在对数据进行备份的基础上对整个系统进行了重置，从根源上杀灭了可能存在的安全隐患。 总结 此事件根源上是我网络安全意识不强、存在不良上网习惯造成的。我一定吸取教训、引以为戒，从正规渠道下载正版软件，定期对设备进行检查。","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"生成式超图聚类：从块模型到模块化","date":"2022-08-14T04:00:00.000Z","path":"2022/08/14/生成式超图聚类：从块模型到模块化/","text":"Science Advances 2021 生成式超图聚类：从块模型到模块化。阅读报告 生成式超图聚类：从块模型到模块化 ——by Zehua Ren Chodrow P S, Veldt N, Benson A R. Generative hypergraph clustering: From blockmodels to modularity[J]. Science Advances, 2021, 7(28): eabh1303. SCIADV2021 31引用 0 摘要 提出了一种具有异构节点度和边权重的聚类超图的概率生成[1]模型，使用该模型的近似最大似然推断得到聚类目标——概括表示了当今流行的图模块度优化目标。推导出了一种推理算法，该算法推广了 Louvain 图社区检测方法，以及一种更快、更专业的变体，其中边预计完全位于集群内。使用合成和经验数据，证明了这种专门的方法具有高度可扩展性，并且可以检测基于图的方法失败的集群。在真实数据集上找到了可解释的高阶结构。 1 绪论 复杂数据中的大部分结构同时涉及两个以上实体之间的高阶交互和关系——图的推广：超图。 图聚类：通过将其节点划分为密切相关或相互关联的组（也称为集群或社区）来描述大型图。超图聚类方法在许多领域都有应用：并行计算、电路设计、图像分割、半监督学习、基因表达高阶网络分析、食物网、在线社交社区。 一种成熟的图聚类方法是将图建模为来自概率生成模型的样本，在这种情况下，聚类任务可以重铸为统计推理问题。但是现如今缺乏超图的生成技术，通常生成的超图只有一种尺寸的边，没有对节点之间的度异质性进行建模（2021年一篇解决得比较好）。边尺寸和节点度的异质性都是超图的重要特征。 有一种生成式超图聚类方法是通过连通分量扩展[2]（clique expansion）将超图转化为二元图[3]（dyadic graph），虽然这使得可以使用广泛的现有模型和算法用于图，但高阶结构丢失了，并且二元图的生成模型可能依赖于明显违反的独立性假设。 最近，已经为超图推广了基于流行的图模块化聚类目标的非生成方法，但它们缺乏与生成模型的关联，限制了它们的可解释性。——是我们之前使用的方法 生成聚类的另一种方法是将超图的表示为二分图[2]，将生成模型应用于二分图上。涉及一个强有力的假设：给定超边中任何两个节点的成员资格都是独立的，取决于模型参数。——八卦之类的交互通常只发生在受信任的个人之间。一个不请自来的局外人的存在可能会完全阻止互动的发生。这些交互的“全有或全无”（AON）结构严重违反了大多数二分生成模型所做的条件独立性假设。我们的场景也可能不适用 本文提出了一种基于度数校正的超图随机块模型[4]（DCHSBM）的超图聚类生成方法，该模型生成具有异构度分布和超边大小的聚类超图。概述了一种用于将该模型拟合到超图数据的近似坐标上升[5]最大似然估计方案，并说明该方案的一个阶段概括了经过充分研究的图模块化目标。为此类模块化目标派生了伴随的 Louvain 算法，这些目标在重要的特殊情况下具有高度可扩展性。实验表明能够在基于图的方法由于已知的理论限制而必然失败的情况下检测到集群。在具有适当匹配的高阶结构的数据集中，生成超图技术能够以比基于图的技术更高的速率恢复与元数据相关的集群。结果强调了将生成模型与数据集匹配的重要性，并指出了在高阶网络科学中进一步工作的一些方向。 2 材料和方法 2.1 DCHSBM模型 度数校正随机块模型 (DCSBM) 是具有社区结构和异构度数序列的图的生成模型。——将其推广到超图 设 是超图中的节点数，每个节点 被分配到 个组之一，表示节点的组分配，放在向量中。与二元 DCSBM 一样，每个节点 都分配有一个参数 来控制其度数，放在向量 中。令 表示无序节点元组的集合，因此每个 是一组表示可能超边位置的节点（遵循图中 DCSBM 的标准选择，我们允许 包含具有重复节点的节点元组） .令 表示给定元组 中节点的组标签向量，而 表示度参数向量。 我们使用亲和函数 来控制在给定节点元组 上放置超边的概率，这取决于 中节点的组分类情况。形式上，将组分配 映射到非负数。如果 很大，则在 中的节点之间形成超边的概率更高。在我们的模型中，放置在 处的超边数分布为 ，其中 表示对 中的节点进行不同排序方式的数量， 是度数参数的乘积。实现给定值 的概率为： 边生成过程的直观解释：对于 中 个可能的节点排序的任何一个，我们尝试在这个元组上放置符合泊松分布 数量的超边。最终得到无序元组 上的加权超边，其权重可以是任何非负整数。这是一个有用的建模功能，因为许多经验超图在同一组节点之间包含多个超边。即使在我们只知道是否存在超边（但不知道权重）的超图数据集中，基于泊松的模型也可以作为基于伯努利的模型在计算上的方便近似。实现给定超边集 的概率就是每个 上的概率的乘积。 2.2 度估计和亲和参数 在一般随机块模型 (SBM) 及其亲属中有许多推理方法：变分坐标上升、变分置信传播和马尔可夫链蒙特卡罗等。本文通过坐标上升执行近似最大似然推断。将DCSBM最大似然推断与图聚类中流行的模块化目标相结合。坐标上升框架，是块模型推理的期望最大化（EM）算法的近亲。EM算法构建“软”集群，每个节点在每个集群都有一个可能性，取最大可能；坐标上升法生成“硬”集群，其中每个节点恰好属于一个集群。轮廓似然方法（Profile likelihood methods）为最大似然推断提供了一个替代框架，可能是未来研究的方向。 在最大似然框架中，我们通过求解优化问题来学习节点标签的估计 、亲和函数的估计 和度参数的估计 其中 是由（整数加权）超边集合表示的给定数据集。像往常一样，使用具有相同局部最优值的对数似然更容易。对数似然是： 其中： 第一项 是对数似然取决于组分配 和亲和函数 的唯一部分。第二项取决于 ，而第三项仅取决于数据 ，并且可以出于推理目的而忽略。 在最大似然的坐标上升方法中，我们在两个阶段之间交替。在第一阶段，我们假设当前估计 并通过求解下式得到新的 和 估计： 结果对 可以被视为最大似然估计，以标签向量 的当前估计 为条件。在第二阶段，我们假设当前估计 和 并通过求解得到新的 估计： 我们在这两个阶段之间交替，直到收敛。 需要解决几个可识别性[6]问题： 首先，排列 和 中的组标签不会改变似然值。因此，我们对组标签施加任意顺序。 其次，可能的组数 原则上可以大于 中存在的组数。这种情况对应于存在统计上可能但在给定数据实现中为空的组。虽然其他处理方法是可能的，但我们选择忽略空组，将 的数量等于 估计中不同组的数量。 不可识别性（unidentifiability）的最终形式与 和 的尺度有关。对于固定的 和 ，我们可以构造 ≠ 和 ≠ 使得 （补充附录 A）。因此，为了确保可识别性，我们必须在 和 上设置一个联合标准化条件。我们选择约束 使得： 其中 并且 是节点 出现的超边的（加权）数。在此表达式及以下表达式中， 是一个指示函数，如果其所有输入都相等，则其值为 1，否则为 0。 公式（9）的用处是，当 已知或估计时，公式（7）中对 和 的条件最大似然估计采取简单、封闭的形式。 首先，对于固定标签向量 ，当使用标准化（9）时， 的最大似然估计为（见补充附录 B） 其次，以 为条件，如果 在一些无序标签元组 上取恒定值 ，则 的最大似然估计为（见补充附录 C） 总的来说，我们可以为数据中每个可能的标签元组估计一个这样的 。稍后，我们将对进行自然限制。虽然公式(10) 假设 是固定的，不必知道 来生成估计量 。然而，通过 公式(11) 生成估计量 需要我们知道或估计 。所以要记住 不是全局最优估计，而是以当前估计的组标签为条件的局部最优估计。 公式 (11) 也可以直接插入到完全似然最大化问题 (2) 中，消除与 对应的参数并产生低维轮廓似然，原则上可以直接进行优化。这种方法对于二元块模型（普通图）是成功的，为超图块模型开发的类似方法将大有研究空间。坐标上升框架的优势在于： 我们能够通过推广常见图聚类最大似然超图Louvain算法，以开发快速启发式算法来很好地解决问题 (8) 。 在我们的框架中解决问题 (7) 也可以解释为评估固定聚类向量 的轮廓似然性[7]，突出了这些方法之间的关系。 我们现在研究推断标签向量 的问题。这个问题自然地引出了超图聚类的一类模块化目标。 2.3 对称模块度 上一节的结果表明，估计的度参数 和分段常数亲和函数 可以以封闭形式有效地估计，从而提供对 的估计。这为坐标上升的第一阶段公式 (7) 提供了解决方案。我们现在讨论第二阶段公式（8）。从等式 (3)可以看出，就为了估计优化 就足够了。为此，在 上施加一些额外的结构是有帮助的。 我们通过规定 关于节点标签的排列对称来获得一类重要的目标函数。在这种情况下， 不取决于给定节点元组 中的特定标签 ，而仅取决于每个标签的重复次数。在统计上，相应的 DCHSBM 生成超图，其中所有组在统计上相同，取决于其组成节点的度数。因此，对称亲和函数将种植分区 SBM算法（planted partition SBM）灵活地推广到超图上。 定义函数 ，其中 是在 中的第 号最大分组在本次标签向量中出现的条目数，可以任意断掉连接。例如，如果 )，则 。我们称 为分区向量。对称假设意味着 是 的函数，仅通过 和它建立连接。因此，当 时，我们通过定义 来符号滥用[8]。 我们现在为 个节点的元组定义对应于可能的分区向量 的广义割（generalized cuts）和广义体积（generalized volumes）： 其中 是 中由 个节点组成的元组子集。函数 计算被 分割到指定分区 中的边数，而函数 是诱导出分区 的所有分组向量 上的体积的和积。令 为在大小为 的集合上的划分向量集，即超边的最大大小。我们在补充附录 D 中表明，对称模块化目标可以写为： 对于 个节点的元组的分区向量 ，直接计算 是 个元素的总和，当 或 很大时，这可能是不切实际的。不过，我们在补充附录 E 中表明，可以通过组合恒等式有效地评估这些总和。我们还给出了一个公式，用于在修改候选标签时更新体积项 。 目标函数 (14) 与最近提出的多路超图切割问题相似。他们根据分割函数制定超图切割目标，当边缘在两个或多个集群之间分裂时，这些函数将进行惩罚。然后，目标是最小化惩罚的总和，约束条件为为某些节点不得位于同一集群中。我们框架中的对称亲和函数（）在其术语中对应于基于签名的分割函数。表 1 列出了许多亲和函数系列中的四个。 表 1. 对称亲和函数。在整个过程中， 是分区 中的节点数， 和 是标量，、 和 是任意标量函数。 亲和函数类型 公式 全有或全无 (AON) 分组数量 (GN) 相对复数 (RP) 节点对 全有或全无(AON) 亲和函数仅区分给定边是否完全包含在单个集群中。这种亲和力函数对于可扩展计算尤其重要，我们将在下面进一步讨论。 分组数量 (GN) 亲和性仅取决于边缘中包含的不同组的数量，而与每个组中的事件节点数无关。 GN 亲和函数在应用中经常出现特殊情况。当 时，模块化目标的第一项对应于超边切割惩罚，在科学计算文献中称为“连通性-1(connectivity − 1)”、K-1 度量(the K–1 metric)或边界切割(boundary cut)。它在数据库文献中也被称为扇出(fanout)[9]。相关的外部度数总和惩罚也是 GN 亲和函数的一个特例。 相对复数 (RP) 亲和函数仅考虑边缘中表示的最大组的大小与下一个最大组的大小之间的相对差异。这种相当专业的亲和函数特别适用于分组大致平衡的情况，例如，我们在国会委员会的党派关系中发现。 节点对亲和函数计算边缘内分组不同的节点对的数量。虽然此亲和函数使用与二元图模型使用相似的信息，但在任何二元随机图和具有节点对亲和函数的 DCHSBM 之间没有立即明显的等价性。 还有更多对称的亲和函数；可用于定义亲和力的其他拆分函数见文献52的表三。 块模型和模块化度之间的关系最近在文献56中得到了关注。这种思考也适用于我们对上文公式(14)和下文公式(15)的推导。我们在一般的、无约束的亲和函数 的假设下推导出了 和 的条件最大似然估计 (10) 和 (11)。当施加额外的约束——例如对称约束——时，就不能保证这些相同的估计使可能性最大化。在二元图的情况下，用于估计 和 的公式（10）和公式（11）， 在 的对称假设下仅当 对于每个 是常数时是精确的。当组的大小不同时（这在大多数数据集中都是典型的），公式 (10) 和 (11) 是精确的条件最大似然估计的近似值。这种情况让人想起图模块化目标倾向于生成大小大致相等的分组。因此，我们在下面提出的目标函数和算法应该被理解为坐标上升最大似然推断的近似值，这仅在所有集群具有相等体积的情况下才是准确的。 2.4 AON 模块度 ——全有或全无模块度 建模和计算对AON 亲和函数特别感兴趣。对于相互作用或关系的发生在很大程度上取决于组同质性的系统，这种亲和函数是一种自然选择。 将表 1 中的 AON 亲和函数插入公式 (14)， 经过一些代数计算（补充附录 F），得到目标函数： 其中 ， 集合了不依赖于分区 的项。我们将 和 收集到向量 中。我们还定义了： 在这个表达式中， 是大小为 的超边的（加权）个数，即 。因此，切割项 计算大小为 的包含两个或多个不同簇中的节点的超边的数量。该计算是最近提出的图模块化方法的直接推广。我们通过限制 来恢复到标准的二元模块化目标函数。我们称公式(15)是 AON 超图模块度。 最近，有研究提出了超图的“严格模块化”的优化目标函数。这种严格的模块化是公式 (15)的一个特例, 通过选择 和 使得 和 ，其中 是超图中所有节点度的总和。然而，保留这些参数为我们提出的 AON 目标方程 (公式15)提供了重要的灵活性。调整 允许指定哪些超边大小被认为与聚类最相关。例如，在电子邮件通信中，一个非常大的收件人列表可能携带关于他们的社会关系的最少信息，并且可能需要降低大型超边的权重。调整 具有修改目标函数偏爱的集群大小的效果，直接概括了二元模块化中的分辨率参数。不必事先指定这些参数的值；相反，它们可以通过公式(11)自适应地进行估计。 2.5 超图最大似然鲁汶-HMLL 为了优化模块化目标函数（14）和（15），我们提出了一系列凝聚聚类算法。这些算法通过对节点标签向量 的局部更新来贪婪地改进指定的目标。这些算法的结构基于广泛使用的高性能启发式图算法： Louvain。标准启发式在两个阶段之间交替。在第一阶段，每个节点都从自己的单例集群开始。然后，每个节点 被访问并移动到相邻节点 的集群中，使目标 的增量最大化。如果没有这样的移动增加目标，那么 的标签不会改变。重复此过程，直到不存在增加目标的此类动作。在第二阶段，为每个标签形成一个“超级节点”。超级节点代表共享该标签的所有节点的集合。然后，重复第一阶段，生成更新的超级节点标签，然后在第二阶段聚合。重复该过程，直到无法再改进为止。因为第一阶段的每一步都改进了目标，所以算法以局部最优聚类向量 收敛。 这种启发式可以自然地推广到超图的上。然而，异构超边大小和一般亲和函数的结合使实现变得相当复杂。 在这里，我们提供了一种高度通用的超图最大似然 Louvain (HMLL-hypergraph maximum likelihood Louvain) 算法，用于优化对称模块化目标 (14)。对于 AON 亲和函数的重要案例，简化的目标 (15) 采用了更简单、更快的专用 Louvain 算法，我们在补充附录 G 中对此进行了描述。正如我们在后续实验中所展示的，这种专用算法具有高度可扩展性，并且可以有效地恢复由 AON 亲和函数合理建模的多元结构数据集中的真实集群。 2.6 对称HMLL 我们的对称 HMLL 算法的第一阶段对映标准图上的 Louvain：节点从单例集群开始，然后贪婪地移动到相邻的集群，直到无法再增加模块度。 普通图 Louvain 的第 2 阶段以保持结构的方式将集群之间的边简化为超节点之间的加权边。然而，在超图的情况下，简单地折叠集群和超边会丢弃有关超边大小和每个超边在集群之间划分方式的重要信息。因此，在我们算法的后续阶段，我们通过移动原始超图中的整个节点集来贪婪地改进目标，而不是贪婪地移动单个节点。这样，在先前迭代中分配给同一集群的一组节点本质上被视为超级节点（supernode）并作为一个单元移动，而不会折叠超图并丢失有关超边结构的所需信息。 我们的整个过程在算法 S1 和 S2 中进行了形式化。算法 S1 依次访问上一次迭代的集群 的每组节点 。该算法评估与将所有 移动到相邻簇时，关联的目标函数 的变化量 ，然后执行使目标具有最大正变化的移动。重复此过程，直到移动任何一组 不再能改善目标。整个对称 HMLL 方法通过算法 S2 进行总结，该算法首先将每个节点放在一个单例集群中，然后再调用算法 S1。（——S1单步，S2整体） 算法 S1 依赖于一个函数 ，该函数计算与将所有从 中的节点移动到相邻集群后相关的目标 Q 的变化。使用组合恒等式可以有效地计算目标中第二项（体积）的变化（补充附录 E，命题 1）。对第一个（割）项的变化需要对一个节点或一组节点的所有超边求和。在每个超边，我们必须评估当前分区 上的亲和性 ，以及与候选更新分区 相关联的亲和性 。这种情况与普通图 Louvain 算法的情况形成对比，在原算法中，检查给定边是否连接相同或不同集群中的节点就足够了。我们需要为每个超边存储和更新分区向量 的事实阻止了我们将节点集群折叠成一个单一的超级节点，并在简化的数据结构上递归地应用算法 S2，而这在普通图 Louvain 中很常见。 因此，虽然节点集群在算法 S1 中也作为一个单元移动，但在这种情况下，有必要在算法的所有阶段对完整的邻接数据 进行操作。这可以使算法 S2 在即使是中等大小的超图上也很慢。开发用于优化一般对称模块化目标或各种特殊情况的有效算法是未来工作的重要途径。 2.7 AON HMLL 当 是 AON 亲和函数时，可以进行相当大的简化。对于每条边，我们不需要计算完整的分区向量 ，而只需检查 是否成立。我们不是提供一般的亲和函数 ，而是提供出现在公式 (15)中的参数向量 和 。这使我们能够在相当简化的数据结构上进行计算。特别是，我们能够遵循经典的Louvain策略，将集群折叠成单个合并的超级节点，并将注意力限制在跨越多个超级节点的超边上。因为我们不需要跟踪超边跨越多个超节点的精确方式，所以我们可以忘记大部分原始邻接数据 ，而是简单地存储超图的边大小。这些简化既可以节省大量内存，又可以非常快速地评估目标更新函数。我们在补充附录 G 中提供了这些简化算法的伪代码。 补充附录G 上一节我们给出了通用对称亲和函数 （算法 1 和 2）的超图最大似然鲁汶（HMLL）的伪代码。对于 All-Or-Nothing 亲和函数的特殊情况，可以获得相当快的 Louvain 算法。特别是，可以遵循经典的二元 Louvain 的“超级节点”策略，能够在比原始邻接超边矩阵更简单的数据结构上进行计算。算法 1 描述了 AON HMLL 的外循环。整体结构与内循环算法 2 中的大致相同。在外循环的每次迭代中，我们使用函数 将初始聚类 折叠成简化的超图，这种方式仍然保留了特殊的 AON 结构。我们在简化超图上运行 Louvain 步骤，然后使用函数 将简化超图上的聚类 转换为原始超图上的聚类 。如果 和 重合，则 Louvain 步骤没有发现任何改进，我们终止。否则，我们开始一个新的迭代，首先在运行 Louvain 步骤之前将更新的聚类折叠成一个简化的超图。在构造简化表示 时，有必要仅将折叠的超图与每个边的原始大小的向量 一起存储。每个折叠节点 的度数 只是相应集群 中节点的度数之和。 Louvain 步骤本身由算法 2 给出。在每个阶段，我们检查折叠节点 并计算与将 更改为 时相应目标函数的变化，其中 ​ 是通过设置 而其他条目保持不变获得的折叠标签向量。该计算包含在子程序 中。 值得注意的是，在一般对称HMLL算法 1 中， 的计算比 快得多。公式（15）中体积项的局部变化只需要更新集群体积的幂和，由分辨率参数 和进行放缩。更新公式（15）的割项需要对与要更新的节点 相邻的每个超边的切割状态的变化求和。在 AON 设置中，只有两种可能的状态——剪切和未剪切。检查一条边是否被切割比在可能移动之前和之后计算超边的精确分区向量要容易得多。因此，此步骤在实践中比计算对称目标的切割变化要快得多。 2.8 集群数 与大多数 Louvain 风格的模块化方法一样，用户无法直接控制 HMLL 返回的集群数量。影响聚类数量的一种方法是手动设置亲和函数 或参数 和 的值（如果使用 AON 亲和性）。与其从数据中推断这些参数，不如先验地设置它们并在 上执行一轮迭代优化获得。这种方法将二元图模块度最大化中分辨率参数的常见处理推广为调整超参数，而不是从数据中估计的数字。可能需要大量的实验来获得所需的集群数量，并且可能无法检索到确切的数量。 影响集群数量的另一种方法是在社区标签上施加贝叶斯先验。在贝叶斯方法的最简单版本中，假设在对边进行采样之前，每个节点都以相等的概率独立地分配了一个 标签。实现给定标签向量 的概率为 ，它在对数似然 中生成形式为 的项。该术语接下来可能会被合并到 Louvain 实现中，结果是会强烈激励减少集群总数 的贪婪动作。然后，生成的正则化算法可以用稍微较少数量的不同簇来标记向量 。当先验地知道数据中的真实集群数量很少时，这可能很有用。我们对 AON HMLL 的实现包含了这个可选的正则化项。我们仅在下面介绍的合成可检测性实验中使用该术语。——（？没看懂） 3 结果 3.1 运行时间 二元（Dyadic）Louvain 算法以在大图中高效而闻名。在这里，我们展示了 AON HMLL 可以在合成数据上实现与图 MLL (GMLL) 相似的性能——这是标准二元 Louvain 算法的一种变体——其中我们返回产生最高二元似然的分辨率参数和分区组合。对于固定数量的节点 ，我们考虑一个类似 DCHSBM 的超图模型，包含 个集群和 个超边——超边大小 均匀分布在 2 和 4 之间。每个大小为 的边以概率 均匀地随机放置在同一集群内的任意 个节点上。否则，以 的概率，将边随机均匀地放置在任意 个节点的集合上。我们使用这个模型而不是直接的 DCHSBM 来避免在每个 元组节点上采样边的计算负担，这在 很大时是禁止的。出于性能测试的目的，我们使用真实聚类标签计算参数向量 和 （在 AON HMLL 的情况下）和分辨率参数 （在 GMLL 的情况下）的估计。我们强调这在实际应用中通常是不可能的，因为真实标签是未知的。我们做出这个选择是为了专注于在两种算法都能成功的情况下直接比较每种算法的运行时间。在后面的部分中，我们研究了 HMLL 和 GMLL 在亲和力和分辨率参数未知时恢复合成和经验数据中已知组的能力。 图 1 显示了当 、 和 时在合成超图上返回的运行时间、调整兰德指数 (ARI) 和聚类数。选择这些参数以使大小为 3 和 4 的超边很少（如果有的话）完全包含在簇内。因此，不同大小的超边提供了关于真实聚类的不同信号。在这个实验中，我们通过计算标准化团投影（normalized clique projection）——连通分量扩展为普通图来实现 GMLL，其中节点通过带权重的加权二元边连接： 我们还对 的非标准化团投影进行了实验，但没有显示这些结果，因为在这个实验中，相关的 MLL 算法始终无法恢复与种植分区相关的标签。 根据 ARI 的测量，在较小的实例上，HMLL 在恢复种植集群方面的表现优于 GMLL。对于较大的实例，恢复结果类似。尽管 GMLL 和 HMLL 在本实验中获得了相似的准确性，但它们以不同的方式实现，HMLL 倾向于生成比 GMLL 更多、更小的集群。运行时间几乎没有区别，这表明二元团投影（连通分量扩展）对于准确性和性能都不是必需的。我们观察了参数 、 和 的其他选择对结果的影响，其中 HMLL 在集群恢复方面的性能大大优于 GMLL，反之亦然；然而，在每种情况下，算法各自的运行时间往往只相差很小的常数因子。 簇内边缘放置概率为，以浅灰色显示了使用 GMLL 作为预处理步骤，然后通过 HMLL细化其输出分区获得的结果。 在这个综合实验中，两种算法的组合实现了最强的恢复结果。除了独立运行每个算法之外，我们还运行了一个两阶段算法，其中使用 GMLL 生成中间分区，然后使用 HMLL 对其进行细化。我们再次强调，这些结果是在具有预先优化的亲和力参数的合成超图上获得的，因此细化策略的有效性可能无法推广到真实数据集。在下面显示的经验数据实验中，我们没有显示细化过程的结果，因为在每种情况下，组合方法的输出分区与二元方法的输出分区基本上无法区分。这可能反映了这样一个事实，即我们没有让算法先验地学习与真实数据标签相关的亲和力参数。进一步研究混合策略的性能将具有相当大的实际意义。 3.2 超图扩展（二元投影）和可检测性阈值 非正式地，当该算法的输出标记 以高于零的概率与 相关时，该算法能够在具有固定标签 的随机图模型中检测社区。使用统计物理学的论据，文献(45) 的作者推测在图 SBM（随机块模型） 中存在一个没有算法可以成功检测社区的机制。这个猜想后来在各种特殊情况下得到了提炼和证明；参见文献 (61) 的综述。在具有两个相等大小的种植群落的二元 SBM 中，大图中可检测性的必要性限制条件是： 其中 是连接到节点的簇内边的平均数，而 是连接到节点的簇间边的平均数。如果不满足此条件，则没有算法可以可靠地检测关联图 SBM 中的社区，尽管社区在统计上是不同的。该界限限制了直接推理方法，例如贝叶斯或最大似然技术，以及基于模块化或其他图目标函数最大化的方法。最近的几篇论文考虑了均匀超图的可检测性问题。在我们的模型中，存在多种尺寸的边使分析变得复杂。在这里，我们将自己限制在一个实验证明中，即图 SBM 和我们的 DCHSBM 的可检测性机制可能存在显着差异。 图 2 显示了在一个简单的 DCHSBM 上进行的两个实验，其中有两个大小相等的社区，每个社区有 250 个节点。对亲和力 进行了调整，使得： 每个节点平均与 5 个 2 节点边和 5 个 3 节点边相关。 2 节点边的一部分 连接同一集群中的节点，而 2 节点边的一部分 连接不同集群中的节点。 3 节点边的一部分 连接同一集群中的节点，而 3 节点边的一部分 连接不同集群中的节点。 对于* ， 是大小为 i 的簇内边缘的比例。每个像素给出 20 个独立生成的大小为 n = 500 的 DCHSBM 的平均 ARI，其中每个节点平均与 5 个 2节点 边和 5 个 3节点 边发生关联。 （左）从 GMLL 获得恢复的分区 。 （右）从 AON HMLL（算法 S1）获得恢复的分区。虚线和点线给出了正文中描述的各种可检测性阈值。在每个面板中，返回的分区 是在更新 和相似性参数推断之间的 20 次交替中的最高似然分区。仅在这个实验中，我们在模块化目标中加入了一个正则化项 ，以促进生成具有更少簇的标签向量 。 这部分看不懂 仅在这个实验中，下面讨论的 GMLL 和 AON HMLL 都在似然目标中使用贝叶斯正则化项 ，以促使每个算法形成相对较少数量的集群。在左侧面板中，我们展示了使用 GMLL 的非标准化变体时返回的分区 与真实分区 的 ARI（标准化变体的结果相似）。这种选择反映了这样一个事实，即真实的簇数是已知的并且等于 2。白虚线和白点线给出了等式(18)成立的边界。白虚线给出了分类机制的可检测性阈值，其中节点更有可能与同一集群中的其他节点链接。 Louvain 作为一种聚类算法，非常适合检测分类簇，并且能够在该机制的大部分（但不是全部）中检测社区。理论阈值与 Louvain 性能之间的差距反映了 Louvain 作为一个阶段性贪心算法没有最优性保证的事实。在白点线下方还有一个不可检测的区域。基于图的 Louvain 的凝聚结构导致算法在这里完全失败。 在右侧面板中，我们展示了使用 AON HMLL 的相同实验。虚线 和 分别给出了完全忽略 3 节点边和 2 节点边的假设算法的分类可检测性阈值，而点线 和 给出了相应的不可检测阈值。 HMLL 能够检测种植分区的一系列参数值，而 GMLL 不能。其中包括某些大小的边主要位于簇间的情况，如左上角（ 小）和右下角（ 小）所示。有一个机制（中和右下），其中算法似乎受到边界 q2 的约束，这表明 HMLL 有效地忽略了该机制中的 3 节点边。然而，随着 的增加，3 节点边变得更具信息性，并且可以在 的分区（右上角）检测到某些值。还有一个广泛的机制（左上角），其中超图算法能够有效地使用 2 节点和 3 节点边来检测集群，即使 2 节点边主要在集群之间。我们还观察到 HMLL 在 2 边和 3 边都在簇间（左下）的情况下检测簇的能力非常有限。因为 HMLL 又是一种凝聚算法，所以它对诸如此类的完全不分类分区的性能充其量是不可靠的。 有趣的是，还有 和 的组合，其中 GMLL 能够检测到种植分区，而 HMLL 则不能。这可能表明二元投影所暗示的不同大小的边的汇集在某些情况下可能是有用的。我们再次注意到 GMLL 和 HMLL 都不是最优推理算法。最佳超图算法可能会显着扩展图 2 右侧面板中的可检测范围。我们将这些算法的开发及其分析视为未来研究的极有希望的途径。 3.3 经验数据上的实验 接下来，我们分析了从经验数据中得出的几个超图。 前两个是人类近距离接触交互的超图，从小学和高中的可穿戴传感器数据中获得。节点是学生或老师，超边连接彼此靠近的人群。节点标签标识每个学生所属的班级，小学数据还包括与每个班级关联的老师。 接下来，我们从美国国会法案共同提案数据中创建了两个超图，其中节点对应于国会议员，超边对应于众议院或参议院法案的发起人和所有共同发起人。 我们以委员会成员的形式从美国国会构建了另一对数据集。每条边都是国会会议中的一个委员会，每个节点又对应于众议院议员或参议员。如果相应的立法者在指定的国会会议期间是委员会成员，则节点包含在边中。包含了跨越 1993 年至 2017 年从第 103 届至第 115 届的所有国会议员。众议院和参议院成员仍然有单独的数据集。在所有国会数据集中，节点标签给出了成员的政党。 我们还使用了沃尔玛购买的超图，其中每个节点都是一个产品，超边连接了客户在一次购物之旅中共同购买的一组产品。每个节点都有一个关联的产品类别标签。 最后，我们构建了一个超图，其中节点对应于 trivago.com 上列出的酒店，每个超边对应于一组酒店，其网站被 Trivago 的用户在浏览会话中点击。该超图源自 2019 年 ACM RecSys 挑战赛发布的数据。对于每家酒店，节点标签给出了它所在的国家/地区。数据集的大小在节点数量、超边、超边大小和节点标签方面有所不同（表 2）。 表2. 研究数据集摘要。显示了节点数 、超边数 、平均度 、度数的标准差 、平均边大小 、边大小的标准差 和数据的标签数 . 数据集 contact-primary-school 242 12704 127.0 55.3 2.4 0.6 11 contact-high-school 327 7818 55.6 27.1 2.3 0.5 9 house-bills 1494 43047 274.0 282.7 9.5 7.2 2 senate-bills 293 20006 493.4 406.3 7.3 5.5 2 house-committees 1290 340 9.2 7.1 35.2 21.3 2 senate-committees 282 315 19.0 14.7 17.5 6.6 2 walmart-purchases 88860 65979 5.1 26.7 6.7 5.3 11 trivago-clicks 171495 220758 4.0 7.0 4.2 2.0 160 3.4 模型比较和高阶结构 人们经常说，高阶特征对于理解复杂网络的结构和功能很重要。但很少有人能说清哪些类型的高阶特征与哪些网络相关。生成式建模提供了一种比较不同类型的高阶结构的方法。在 DCHSBM 中，此结构由亲和函数 指定。比较每个亲和度函数的似然函数可以表明哪一个最有可能作为基础数据的高阶生成机制。我们使用表 1 中的对称亲和函数和上述节点的标签进行了比较。在这个比较中，我们可以计算亲和函数 的近似 ML（最大似然） 估计并给定它的函数形式。为了进行具体的比较，有必要指定 GN、RP 和 Pairwise 亲和度的函数形式。我们使用以下公式给出： GN 亲和力函数为超边大小和组数的每个组合分配一个单独的参数。 RP 亲和性函数为边内最大和第二大组之间的差异超过 k/4 的情况分配一个参数，其中 k 是边的大小。 Pairwise 亲和性函数将一个参数分配给不同组中的二元对的总数超过这些对的可能数量的一半的情况。 RP 偏爱两个最常见的标签在表示上大致平衡的超边； 而 AON、GN 和 Pairwise 都偏爱具有同质聚类标签的超边。 因为这些亲和函数参数的数量不同，我们通过贝叶斯信息准则[10] (BIC) 对它们进行比较，该标准会惩罚具有比数据支持的更多参数的亲和函数。在计算 BIC 时，我们排除了节点数量 的参数 ，因为此参数在每个模型中都是相同的，反而增加了一个不重要的加性常数。 AON、RP 和 Pairwise 亲和度各有 个参数。在 GN 的情况下，我们通过使用给定分区方案中不同标签的数量计算可能组的数量，来计算每个边大小 的可能参数的数量。例如，如果给定的分区仅包含三个不同的组，那么我们不会设置与包含三个以上组的边相对应的参数。移除这个限制也是合理的，在这种情况下，大小为 的边将有 个参数，而与 无关。 表 3 显示了使用这些亲和函数中的每一个的 DCHSBM 的 BIC。在所有研究数据集中，没有一个亲和函数是首选的，这表明存在不同种类的多元结构。在两个国会委员会数据集中，RP 实现了最佳 BIC，而在其他每个数据集中，促进边缘同质性的三个亲和力之一反而是首选。这三种亲和力之间也有重要的区别。在 house-bills 中，Pairwise 亲和度函数总体上实现了最低的 BIC，而在 walmart-purchas 中，Pairwise 亲和度优于除 GN 亲和度之外的所有功能。这表明仅涉及节点标签的成对比较模型这些情况下可以对数据提供相对强的生成解释。反过来，这表明二元算法在这些二元数据集上的性能至少与其多元算法一样好。正如我们将在下面看到的，在这两个数据集中，与 AON HMLL 返回的聚类相比，二元算法可以返回与真实结果更相关的聚类。 表 3. 在我们的完整研究数据集上使用 AON、GN、RP 和 Pairwise 等亲和函数运行DCHSBM 的 BIC 。表 1 中提供了每个亲和函数的定义。较低的 BIC 表示更合理的模型。在每个数据集中实现最低 BIC 的亲和函数以粗体显示。 数据集 AON GN RP Parwise contact-high-school 2.2003 2.1946 2.4330 2.2003 ×10 5 contact-primary-school 4.1954 4.1646 4.3990 4.1954 ×10 5 house-committees 2.7128 2.7128 2.7119 2.7127 ×10 5 senate-committees 9.7934 9.7934 9.7736 9.7933 ×10 4 house-bills 9.9719 9.9720 10.003 9.9670 ×10 6 senate-bills 3.1925 3.1926 3.2030 3.1925 ×10 6 walmart-purchases 1.0763 1.0753 1.0806 1.0758 ×10 6 trivago-clicks 1.6854 1.6866 2.0257 1.6960 ×10 8 3.5 在关系超图中发现类别 图 3 小学和高中数据集的聚类算法比较。对于每个数据集，我们对比了从经典图 Louvain 模块化最大化启发式获得的分区、从 GMLL 获得的分区和通过 AON HMLL 获得的分区。显示的分区是经过 20 轮迭代似然最大化后获得相应目标函数的分区。每个框记录具有推断集群和真实标签的指定组合的代理数量。底行可视化大小为 的边数 、推断的大小权重 和推断的分辨率参数 ，如公式 (15) 中定义。在最右边， 。 为了测试 AON HMLL 算法本身，我们首先研究它在小学和高中网络中的行为。表 3 中 BIC 分数的比较表明，GN 可能是对数据最具解释性的模型，但我们改为使用 AON 来利用其可观的计算优势。我们在 AON HMLL 和 AON 参数估计之间执行了 20 次交替，并返回了具有最高 DCHSBM 可能性的分区。我们将结果与两种二元方法进行比较。 Graph Louvain 算法的每个步骤在使用标准 Louvain 算法推断集群和使用的近似最大似然框架估计分辨率参数 之间交替进行。 Graph Louvain 返回最大化经典二元模块化目标的分区。我们还与 GMLL 进行了比较，后者执行相同的交替，但返回的分区使相应的种植分区 SBM 的近似对数似然最大化。 图 3 比较了每种算法的性能。 在小学数据集的情况下，我们认为基本事实分区是为每个班级准确分配一名教师的分区。 Graph Louvain 能够找到与给定班级标签具有明确相关性的学生分区，但却会将两个小学班级合并，拆分了几个高中班级（左列，前两行）。GMLL 能够完美地恢复小学生的班级标签，对三个高中生进行错误分类。我们提出的 AON HMLL 能够正确恢复两个数据集中的给定分区。 通过研究推断的亲和函数 的结构，我们可以获得对 HMLL 行为的一些定性洞察。最直观的方法是通过从公式15导出的参数 和 。图 3 的底行显示了这些参数和边缘尺寸的分布。 对边大小 的依赖性提供了为什么 GMLL 在接触小学成功但在接触高中犯了几个错误的一种解释。在标准二元投影下，k-超边生成 个2节点边，因此多次出现在二元模块化目标 。在小学数据集的情况下，估计的重要性参数 确实比较接近 （图 3，底部中间）。因此，在最佳分割处，边缘的相对权重因团投影而失真相对较小。另一方面，高中数据集的 估计值与 有很大的偏差，尤其是在 时。在这里，小边在多元模块化目标中的特征比在投影二元目标中更突出，这意味着后者在最优分区附近对前者的逼近较差。这种差异可以解释接触高中 GMLL 中的小错误。图 3 的右下图将特定尺寸分辨率参数 的推断值与 进行比较，后者是 (40) 中使用的隐含值。推断的分辨率参数 始终较大并随 增加，突出了在我们的方法中自适应估计这些参数的价值。 3.6 具有大超边的集群恢复 在图 4 中，我们研究了 AON HMLL 在我们的多个研究数据集中恢复真实社区的能力。与这两个接触网络不同，这些数据集中的每一个都包含大小高达 25 个节点的边。我们排除了众议院委员会和参议院委员会，理由是这些数据集是不相关的，这表明 AON 显然不合适。我们将 AON HMLL 与 GMLL 的两个变体进行比较。在非归一化变体中，我们通过将每个 边替换为 团块（k-clique）来获得一个二元图，从而生成总共个二进边。在归一化变体中，我们将 k-clique 中的每条边加权为 的因子。然后每个节点的归一化二元图的度等于其在原始超图中的度。在任何一种情况下，我们都会在用于估计聚类的二元 Louvain 算法和分辨率参数 的条件最大似然推断之间交替。在每次试验中，我们对 AON HMLL 和两个 GMLL 变体执行 20 次迭代，从这些变体中返回达到最高可能性的组标签和参数的组合。然后，我们通过 ARI 将聚类与真实标签进行比较。我们改变最大边缘大小 以显示每个算法如何响应逐渐变大的边缘的合并。因为极端稀疏性通常会给社区检测算法带来问题，我们展示了针对 trivago-clicks 和 walmart-purchases 的逐渐密集核心的实验。超图 的 核被定义为最大的子超图 ，使得 中的所有节点都具有至少 的度数。 图 4. 具有已知聚类的数据中超图 AON MLL（算法 S1）与二元似然 Louvain 的比较。点给出了在分区和参数估计之间进行 20 次交替后获得的最高似然分区的 ARI。最大超边尺寸 沿水平轴变化。在面板标题中， 是节点数， 是 时的边数。请注意，垂直轴限制因面板而异。 结果突出了 AON HMLL 的性能对作为数据生成机制的 AON 亲和函数的相对合理性的强烈依赖性（参见表 3）。在 trivago-clicks 中，AON 亲和函数达到了所有四个候选者中最低的 BIC。因为 AON 是一个更合理的生成机制，所以 AON HMLL 能够找到与提供的数据标签相关的分区比二元变体返回的分区更相关，这并不罕见。另一方面，在沃尔玛购买中，Pairwise 亲和力优于 AON。在这种情况下，AON HMLL 的性能要差得多，并且在 2 核中，甚至返回与提供的标签反相关的集群。随着弱连接节点被移除并且生成的数据变得更密集，HMLL 开始返回相关集群。然而，归一化的 GMLL 变体在恢复数据标签方面至少同样有效。在两个国会法案数据集中，Pairwise 亲和力在众议院实现了低于 AON 的 BIC，在参议院实现了可比的 BIC。与这一发现相呼应的是，二元法在每种情况下都优于 AON HMLL。非标准化的 GMLL 在众议院和参议院的法案中表现最好，而标准化的 GMLL 在沃尔玛采购中更受欢迎。此外，HMLL 是仅在 walmart-purchases 小的 2 核的情况下最差的算法。因此，在不知道归一化或非归一化二元表示是否更适合数据的情况下，HMLL 可能是首选算法。 在解释这些恢复结果时，重要的是要将它们与社区检测方法的一般局限性和特别是模块度最大化的局限性联系起来。没有对数据结构做出隐含假设的社区检测“最佳算法”，算法与数据集的不匹配会产生误导性结果。即使数据生成过程确实与算法假设相匹配——例如从 SBM 生成的合成数据集——最优算法也可能由于稀疏性而无法检测到种植群落 。贪婪的模块化最大化，包括这里考虑的 Louvain 变体，只能找到可能的许多局部最优值之一，其中一些可能在很大程度上彼此不相关。这些考虑意味着： （i）我们不能排除可能在三种算法中的任何一种中获得更高分数的其他局部最优值的存在，以及 （ii）算法无法恢复接近基本事实的聚类这一事实并不意味着它在其既定目标（即局部似然最大化）中“失败”了。 总体而言，我们的结果表明，当具有 AON 亲和函数的 DCHSBM 假设适用于数据时，AON HMLL 在恢复真实社区方面的表现优于二元方法。在实践中，因为我们通常无法访问基本事实标签，所以假设是否适合数据的问题应该由领域专业知识来告知。 4 讨论 我们提出了一种基于 DCHSBM 的多元数据聚类生成方法。从这个模型中，我们推导出了一个对称的、类似模块化的目标，其中包括 AON 模块化目标作为一个重要的特例。这种推导将超图模块化目标与具体的建模假设联系起来，可以根据领域专业知识进行调整。我们还制定了类似 Louvain 的算法来优化这些目标，在 AON 亲和函数的情况下具有高度可扩展性。将这种启发式嵌入到交替近似最大似然方案中，可以对节点集群和亲和性参数进行自适应估计。我们已经通过实验证明，超图算法与二元算法具有明显不同的可检测性机制。我们还对经验数据进行了实验，发现在建模假设有充分根据的数据集中，超图方法优于二元法。 我们的工作指向了许多进一步研究的方向。这些方向之一是算法。我们在 DCHSBM 中进行推理的贪心坐标上升框架有几个重要的限制。 首先，因为我们依赖于一个 NP-hard 优化步骤，所以永远无法保证似然的全局最大化。 其次，即使是精确的最大似然本身也被限制为推理范式，因为它使用的信息仅包含在似然图的一小部分中。我们的方法，作为仅当集群大小大致相等时才准确的近似值，也可能会受到估计偏差的影响。 第三，由 Louvain 风格算法体现的边缘凝聚方法在适用促进边缘内同质性的亲和函数（那三种）方面受到限制。 替代推理范式可以改善部分或全部这些限制。 在最大似然推断的框架内，直接最大化轮廓似然为坐标上升提供了一个有趣的替代方案。尽管所有最大似然方法在优化相同的目标函数方面都是等价的，但算法属性（例如运行时间和陷入不良局部最优值的倾向）可能因不同方法而异。 完全贝叶斯处理提供了另一条有希望的途径，尽管它们有时在计算可扩展性方面受到限制。 变分置信传播提供了一个有趣的折衷方案，实现了相当大的可扩展性以换取几个近似值。 最近的工作在这个方向上取得了进展，但与非均匀超图的可扩展性和行为相关的几个问题仍然存在。具有更一般的亲和力函数的可扩展推理的信念传播方法将具有特别的实际意义。 还有几个重要的理论发展方向。其中之一是 DCHSBM 中的可检测性问题。由于 DCHSBM 比二元 DCSBM 更灵活，因此该模型中的可探测性理论可能要复杂得多。另一个方向涉及扩展到此处讨论的超图模块化目标的二元模块化目标的属性。除了作为与空模型比较的作用和作为 DCSBM 似然性中的一个术语外，二元模性还表达了图上扩散过程的稳定性和定义的离散表面张力的能量图表。这些属性的扩展，或者解释它们为什么不能概括，对理论家和实践者都有帮助。 附注 1 生成vs.判别 帖子：生成方法vs判别方法+生成模型vs判别模型 生成模型：能够随机生成观测数据的模型，可以用来直接对数据建模。 与判别模型区别：生成模型，就是同时考虑了X和Y的随机性，也就是说二者都是随机变量；判别模型，就是只考虑了Y的随机性，而X并不是个随机变量，即使X存在于条件中，但是并没有p(x)这种说法。 生成模型有三个基本用处：一个是概率密度估计，一个是采样，还有就是监督学习，如朴素贝叶斯。 2 超图的两种扩展方式 clique expansion（连通分量扩展） 将超边中所有顶点都连接在一起，比如有3个顶点的超边，扩展成普通图时两两相连就会有3条边。以此类推。连接和n个顶点的超边拓展后有 个边。 同一个超边转换成的边具有跟以前边同样的权重。 star expansion（星形扩展） 在每个超边中加入一个“星星”,连接上其他的点，所以这种方式会在原来的节点上增加额外的节点，也就是有加点的操作，而法一是没有的。加上的点归入一个集合，原来的点归入另一个集合，这个拓展后的普通图是一个二部图（bipartite graph又称作二分图，是图论中的一种特殊模型。） 星图边的权重变成 对应超边 的权重除以超边的度。 论文2020ICML 代码 帖子 3 二元图-dyadic graph 图的dyad：图中两个点和它们之间的所有边构成图的一个“dyad”。 dyadic graph：直接理解就是普通图，其中边表示的是两点之间的二元关系。 介绍论文 4 随机块模型SBM 也叫做种植分区模型（planted partition model） 一种图生成模型，英文全称stochastic block model。SBM是一个传统的图生成模型，认为每个节点从属于不同的社区，每个社区之间的节点会以不同的概率相连接，由此生成一张图，这就是它基本的思想。他可以用于社区检测，图聚类，主题建模等任务。 综述论文 简介帖子 5 坐标上升法 坐标上升法(Coordinate Ascent)每次通过更新函数中的一维，通过多次的迭代以达到优化函数的目的。 博客园 CSDN 6 可识别性 定义： identifiability（可识别性），即如果一个因果量可以通过纯统计量计算得到，则该因果量为可识别的，这意味着我们可以从观测数据中求得因果效应。 一个模型是可识别的，那么其参数跟观察变量的概率分布的映射是一对一的。 在观察性研究中，借助什么样的数据可以推出可靠的因果效应呢？具体来说，假如我们对每个用户有一系列干预前的指标（pre-treatment variables） 𝑋、有干预 𝑇、有观察结果 𝑌 我们能不能推断出 T 对 Y 的因果效应？ 这个问题就是因果推断中的可识别性问题。可识别性依赖于几个假设，这些假设通常被称为causal assumption 帖子 7 轮廓似然函数 轮廓似然函数及其应用 Maximum Likelihood, Profile Likelihood, and Penalized Likelihood: A Primer 8 符号滥用 Abuse of notation 在数学中，当作者以一种在形式上并不完全正确但可能有助于简化阐述或提出正确直觉的方式使用数学符号时（同时可能最大限度地减少错误和混淆），就会出现符号滥用。 简介 9 扇入扇出 扇入：是指直接调用该模块的上级模块的个数。扇入大表示模块的复用程序高。 扇出：是指该模块直接调用的下级模块的个数。扇出大表示模块的复杂度高，需要控制和协调过多的下级模块；但扇出过小（例如总是1）也不好。 10 贝叶斯信息准则 BIC 其中k为模型参数的个数，n为样本的数量，L为似然函数。 模型评估标准：BIC值越低越好。 p和q越大时，参数越多，k越大。所以使k越小，p和q越小，保证模型越好。 L越大，使BIC的值越小，所以似然函数越大越好。","tags":[{"name":"算法","slug":"算法","permalink":"https://renzehua1998.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图与网络","slug":"图与网络","permalink":"https://renzehua1998.github.io/tags/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"name":"论文阅读","slug":"论文阅读","permalink":"https://renzehua1998.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"Julia","slug":"Julia","permalink":"https://renzehua1998.github.io/tags/Julia/"}]},{"title":"开发经验分享","date":"2022-08-11T04:00:00.000Z","path":"2022/08/11/开发经验分享/","text":"一些前端vue开发经验和git使用注意事项分享 PPT链接：slides 开发经验分享 一、基于VUE的前端开发 1. 命名、语法、注释 1.1 JS变量、函数命名规范 存在的问题：驼峰式、下划线式混用，少数变量命名随意 123456789101112modifyPatternFormRules = { threat_level:[{ required: true, message: \"请选择风险等级\", trigger: \"blur\"}], handle_info:[{ required: true, message: \"请输入标定信息\", trigger: \"blur\"}]},addPatternDialogVisible = false, // 模式添加弹窗是否可见window.onresize = function(){ a.resize(); b.resize(); c.resize(); d.resize();} 每个人对变量的命名规范都不太一样，建议在一个项目中尽量保持相同，虽不影响阅读和功能，但是整体看起来稍显凌乱。这里介绍一下我自己常用的命名规范和搜集资料时找到的好的规范以作参考： 驼峰式命名法：第一个单词首字母小写,其余每一个有意义的单词首字母大写 1var studentInfo; //命名使用英文单词，不要使用拼音 12let patternInfo // Infomation--goodlet cardSty // Style--bad //不是所有单词都能简写，要保证大家看到名字后知道所代表的含义 常量全部大写 12const PIconst NAME 方法/函数前加入操作动词 get 获取/set 设置/add 增加/remove 删除/create 创建/destory 移除； start 启动/stop 停止/open 打开/close 关闭/read 读取/write 写入； load 载入/save 保存/create 创建/destroy 销毁； begin 开始/end 结束/backup 备份/restore 恢复/detach 脱离； import 导入/export 导出/split 分割/merge 合并/inject 注入/extract 提取； 根据类型加前缀 fn：表示函数。例如：fnGetName，fnSetAge； dom：表示Dom对象，例如：domForm，domInput； 临时变量不影响阅读时可简写 作用域不大临时变量可以简写，比如：str，num，bol，obj，fun，arr； 循环变量可以简写，比如：i，j，k等。 1.2 CSS命名规范 大部分同JS变量函数命名规范，有一点需要特别注意：嵌套的元素一定要在前面写上父元素，这样不仅是为了在继承父元素减少代码量的同时便于阅读，最重要的目的是限制CSS样式的作用域，否则就会出现严重的样式混乱。 1234567891011121314151617181920#header{ padding: 10px 0 0 0; .profilepic{ display: block; position: relative; z-index: 100; } .header-menu{ height: auto; margin: 10px; ul{ text-align: center; cursor: default; } li{ display: inline-block; margin: 3px; } }} 1.3 JavaScript语法规范 JS严格区分大小写； JS中每一条语句结尾的分号可加可不加，建议还是加上分号，因为在编译的时候可能会出现一些冲突报错； JS中会忽略多个空格和换行。 注意缩进，便于后期调试也便于他人阅读。 只出现一次的dom元素引用就不要建一个变量来存了，会占用没必要的内存。 1.4 CSS和HTML语法规范 虽然在HTML5当中，标签可以不用闭合，但是为了规范，也是为了避免一些错误，还是建议标签闭合。 在HTML中正确嵌套所有元素，必须按照打开元素的顺序进行关闭。 样式太多时还是不要写在HTML里了，建一个CSS表来存放样式。 不要在CSS样式的0后面写px，不要增加代码的负担。 单引号和双引号不要混用，建议全部改为双引号。 1.5 代码和注释规范 不要太长以至于超过页面范围，需要横向进度条，善用回车换行增加代码可读性。 善用注释，对于某些常量变量方法的定义要说清楚它们的作用，尤其是每个组件中的data全局变量。 公共组件和各栏目的维护者最好需要在文件头部加上注释说明： 123456/***文件用途说明*作者姓名*联系方式*制作日期**/ 大的模块在前面使用此方法进行注释： 123//========//代码用途//======== 调试时注释掉的代码块如果确定没用要及时删除。 2. 全局和局部 2.1 CSS样式 为了减轻代码量，能复用的一定要复用，放到全局样式库里面作为全局样式，根据需要做对应修改即可。 切不可对同名样式在不同的页面分别定义不同的属性，因为CSS是层叠样式表，通过加载只要样式不冲突，新打开一个页面后是会保留之前的样式的，这就会导致某些组件在打开另一个页面回来后面目全非了。 可以通过使用scoped 属性来避免影响全局样式，这也是常见处理方式，但也需要注意一些问题： scoped定义的组件不会影响全局样式和孙子组件，却会影响其根子组件（直接子组件）样式。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。开发时需要注意。 如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响所有子组件，你可以使用 &gt;&gt;&gt; 操作符,有些像 Sass/less 之类的预处理器无法正确解析 &gt;&gt;&gt;,这种情况下你可以使用 /deep/操作符取而代之。 1234567&lt;style scoped&gt;.a &gt;&gt;&gt; .b { /* ... */ }&lt;/style&gt;&lt;style lang=\"less\" scoped&gt;.a /deep/ .b { /* ... */ }&lt;/style&gt; 2.2 系统全局设置 全局量与方法： 为便于集中修改与管理，增强复用，我们把一些全局配置内容存为系统全局量和全局方法。 系统全局量存放在src/api文件夹下，包含了配色表、模拟时间、时间相关方法、服务器IP等。 在组件源文件中使用import来引入。 全局变量是可以通函数来修改的，如当前模拟时间。 全局第三方库引入： 我们要在多个页面引入第三方库（如Echarts、D3、jQuery等）时，可以将其作为全局库引入。 在main.js中进行配置： 路由配置： 在src/router/index.js里面配置即可，需要指出的是，本template已经有了路由配置，我们直接用即可，但是在了解其原理也是很重要的。 对我个人而言，当时配置路由时踩的最多坑应该就是路由嵌套（多级路由）。 1.子级路由path不能加/，否则会找不到组件。 2.路由入口要写完整路径，否则会找不到组件。如从“时间态势分析”跳转到“整体态势复查”，必须使用/temporal/menu1。 123456789101112131415161718192021{ path: '/temporal', component: Layout, redirect: '/temporal/menu1', name: 'Temporal', meta: { title: '时间态势分析', icon: 'el-icon-time'}, children: [ { path: 'menu1', component: () =&gt; import('@/views/temporal/menu1/index'), name: 'menu1-temporal', meta: { title: '实时态势分析' }, }, { path: 'menu2', component: () =&gt; import('@/views/temporal/menu2/index'), name: 'menu2-temporal', meta: { title: '整体态势复查' }, } ]}, 1.在编程式导航中，如果提供了path,params会被忽略；需要提供name，或手写完整的带有参数的path;以下写法可取： const userId = '123'; 1.this.$router.push({name: 'user', params: {userId}}); 2.this.$router.push({name: 'user', query: {userId});//带查询参数，变成/user?userId=123 3.this.\\(router.push({path: `/user/\\){userId}`}). 2.在当前路由未改变，但参数改变时，可以在beforeRouteUpdate在响应这个变化； 3.router.replace().替换掉当前的history记录； 4.vue-router模式的是hash模式，使用URL的hash来模拟一个完整的URL，当URL改变时，页面不会重新加载； 5.路由守卫接收的三个参数中的next() function,一定要调用这个方法来resolve这个钩子，执行效果依赖next方法的调用参数。 next(),进入管道中的下一个钩子，如果全部钩子执行完，则导航的状态是confirmed; next(false),中断当前导航， 确保要调用next方法，否则钩子函数不会被resolve. 6.beforeRouterEnter,不能获取this.可以传一个回调给next来访问组件实例，next(vm=&gt;{}). 7.路由元信息，meta,可以通过$route.matched获取； 2.3 内存管理 内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。文章1 文章2 JavaScript常见内存泄漏： 意外的全局变量 12345678910// bar为我们不需要的全局变量function fn() { a = 'global variable'}fn()// foo 调用自己，this 指向了全局对象（window）function fn() { this.a = 'global variable'}fn() 使用严格模式，在 JavaScript 文件头部或者函数的顶部加上 use strict。 变量声明的时候使用var或let： 区别： 1.使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象； 2.使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升； 3.let不允许在相同作用域内，重复声明同一个变量。 建议最好使用let进行声明，可以很好地避免因变量提升造成的内存泄漏。 闭包（通过自我调用将函数内部的变量转化为全局变量） 123456function fn () { var a = \"I'm a\"; return function () { console.log(a); };} 结束后及时清理：a=null;。 将事件处理函数定义在外部，解除闭包。 没有清理的 DOM 元素引用 12345const refA = document.getElementById('refA'); document.body.removeChild(refA); // dom删除了 console.log(refA, 'refA'); // 但是还存在引用能console出整个div 没有被回收 refA = null; console.log(refA, 'refA'); // 解除引用 手动删除，refA = null; 定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。（下一条） 被遗忘的定时器或者监听回调 123456789101112131415// 定时器var serverData = loadData()setInterval(function () { var renderer = document.getElementById('renderer') if (renderer) { renderer.innerHTML = JSON.stringify(serverData) }}, 5000)// 观察者模式var btn = document.getElementById('btn')function onClick(element) { element.innerHTMl = \"I'm innerHTML\"}btn.addEventListener('click', onClick) 手动删除定时器和 dom。 removeEventListener 移除事件监听 vue 中容易出现内存泄露的几种情况： 窗口全局变量造成的内存泄露 12345678910111213export default { mounted() { window.test = { // 此处在全局window对象中引用了本页面的dom对象 name: 'home', node: document.getElementById('home'), } }, // 解决方法 destroyed () { window.test = null // 页面卸载的时候解除引用 }} 声明的全局变量在切换页面的时候没有清空 在页面卸载的时候顺便处理掉该引用： 监听在 window/body 等事件没有解绑 123456789export default { mounted () { window.addEventListener('resize', this.func) // window对象引用了home页面的方法 } // 解决方法 beforeDestroy () { window.removeEventListener('resize', this.func) }} 在页面销毁前解除引用，释放内存 绑在 EventBus 的事件没有解绑（我们没怎么用过，可以自己查阅） Echarts大量占用——重要！！！D3同理 每一个图例在没有数据的时候它会创建一个定时器去渲染气泡，页面切换后，echarts 图例是销毁了，但是这个 echarts 的实例还在内存当中，同时它的气泡渲染定时器还在运行。这就导致 Echarts 占用 CPU 高，导致浏览器卡顿，当数据量比较大时甚至浏览器崩溃。 123beforeDestroy () { this.chart.clear()} v-if 指令产生的内存泄露 v-if 绑定到 false 的值，但是实际上 dom 元素在隐藏的时候没有被真实的释放掉。 及时清除不需要的dom元素，而不是隐藏起来。 2.4 this和_this _this只是一个变量名，this代表父函数，如果在子函数还用this，this的指向就变成子函数了，_this就是用来存储指向的。 3. 函数的定义与使用 javaScript 函数通过 function 关键词进行定义，其后是函数名和括号 ()。文章 3.1 函数声明 必须有名字，会函数提升，在预解析阶段就已经创建，声明前后都可以调用 12345//定义函数名function fn(){ console.log(123);}fn() 3.2 函数表达式 一种变量赋值，函表达式可以没有名字（匿名函数）,没有函数提升。 12345678//将函数赋值给一个变量，可以是匿名函数var fn = function(){ hi: function(){ }, //方法};//调用fn()//调用方法fn.hi() 3.3 匿名函数（自调用函数） 函数表达式可以 \"自调用\"。如果表达式后面紧跟 () ，则会自动调用。 通过添加括号，来说明它是一个函数表达式： 如果需要执行匿名函数，在匿名函数后面加上一个括号即可立即执行！ 12345(function (){ //此时会输出a console.log(\"a\"); })()//以上函数实际上是一个 匿名自我调用的函数 (没有函数名)。 3.4 构造函数（面向对象） 通过 new 函数名 来实例化对象的函数叫构造函数。 123456function Person(name,age){ this.name = name this.age = age }let p1 = new Person('张三','18') 3.5 箭头函数 箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。 12345678910111213141516171819202122232425(参数1, 参数2, …, 参数N) =&gt; { 函数声明 }(参数1, 参数2, …, 参数N) =&gt; 表达式(单一)// 相当于：(参数1, 参数2, …, 参数N) =&gt;{ return 表达式; }// 没有参数的函数应该写成一对圆括号:() =&gt; {函数声明}//多个参数const fn = (a, b) =&gt; { let result = a + b; console.log(result);//3}fn(1, 2)//只有一个参数var fn2 = c =&gt; { console.log(c); //davina}fn2(‘davina‘);//没有参数let fn3 = () =&gt; { console.log(‘123‘);}fn3(); //123 4. VUE组件之间传值方式 文章1 文章2 4.1 props,emit 父传子的实现方式就是通过props属性，子组件通过props属性接收从父组件传过来的值，而父组件传值的时候使用 v-bind 将子组件中预留的变量名绑定为data里面的数据即可。 子组件通过$emit(事件名，参数)向外弹出一个自定义事件，在父组件中的属性监听事件，可以获得子组件中传出来的值。 1234567891011121314// 父组件&lt;hello-world msg=\"hello world!\" @confirm=\"handleConfirm\"&gt;&lt;hello-world&gt;// 子组件 props: { msg: { type: String, default: '' } }， methods：{ handleEmitParent(){ this.$emit('confirm', list) } } 4.2 children 通过children 来访问组件实例，进而去获取 或者 改变父子组件的值。 （仅限于父子组件之间，不推荐使用，因为不利于维护，一旦组件层次发生了变化，就需要更改其中的层次关系） 4.3 $ref 通过引用的方式获取子节点，常用于父组件中调用子组件的方法或者获取子组件的属性。 4.4 provide/inject 依赖注入，常见于插件或者组件库里。 多个组件嵌套时，顶层组件provide提供变量,后代组件都可以通过inject来注入变量。 缺陷：传递的数据不是响应式的，inject接收到数据后，provide中的数据改变，但是后代组件中的数据不会改变。所以 建议传一些常量或者方法。 4.5 EventBus 事件总线 （任意两个组件通讯） 用 去监听，用on去触发，注意需要$off来取消监听，否则可能会造成内存泄漏。 4.6 其他 、listener: 适用于多级组件嵌套，但是不做中间处理的情况。比如祖先组件向孙子组件传递数据。 $attrs 可以获取父组件传进来，但是没有用props接收的属性。 可以通过v-bind=\"$attrs\"传入内部组件。 Vuex 状态管理器： 集中式存储管理所有组件的状态。 可以解决 多个视图依赖同一个状态 或者是 来自不同视图的行为需要变更同一个状态 的问题。 localStorage/sessionStorage： 持久化存储。 5. 自己的一些开发经验 5.1 页面布局 方式推荐： 首推flex布局法 flex是Flexible Box的缩写，意为弹性布局，用来为盒模型提供最大的灵活性。 float浮动布局需要动态监控窗口，自己安排左右对齐，适应性差。 个人比较喜欢使用space-between或space-around。 margin和padding margin是指从自身边框到另一个容器边框之间的距离，即容器外距离，是隔开元素与元素的间距；而padding是指自身边框到自身内部另一个容器边框之间的距离，即可容器内距离，是盒子边框与盒子内部元素的距离。 1 (开发经验分享/1609143122797378.png).png 存在的问题： 上下margin太宽，占空间较大。 左右margin太窄，显得不好看。 dom元素过多时要合理分配上下div容器，避免出现拐弯回来的情况。 表格的每一栏按照预期的内容多少排布宽度，不要默认等宽，尽量不要让表项超出出现进度条，出现的话要把包含操作按钮的列固定。 背景不要留下大块灰底色，在子元素中将background设置为white或#FFF。 表格和背景之间再加一层白色的padding，否则很丑。 5.2 功能拆分与复用 将组件按照功能进行拆分，保留组件之间必要的通信即可，不要放到同一个vue源文件内，否则在代码维护和故障排查时都会很麻烦。一个组件内部耦合度巨大会带来内存溢出等问题。 功能性的JavaScript函数能复用尽量复用，不要图省事直接复制一份，这样会带来很多冗余代码。 同一份数据不要在多个组件中存放备份，节省内存资源。 5.3 前后端交互 每次请求数据不要太多，量大时先让后端返回名称列表，再根据列表动态请求。 能让后端完成的功能不要在前端完成，减轻web浏览器负担。 请求内容不多时，可以使用get；但是请求内容复杂、包含私密信息（如子图信息）的时候，使用post。 二、Git协同操作注意事项 文章1 文章2 文章3 1. 分支规范 常设分支：永久不删除 主干分支 master/main 开发分支 develop/dev 临时分支：用完立即删除 功能分支 feature-* 测试环境的稳定分支 release 测试阶段修复Bug bugfix-* 线上出现的紧急Bug修复 hotfix-* 2. 开发流程 2.1 一般开发流程： 从 develop 分支切出多个命名为 feature-* 分支开发新功能。 开发者完成开发，提交分支到远程仓库。 开发者发起merge请求(可在gitlab页面“New merge request”)，将新分支请求merge到 develop 分支，并提醒code reviewer进行review。 code reviewer对代码review之后，若无问题，则接受merge请求，新分支merge到 develop 分支，同时可删除新建分支；若有问题，则不能进行merge，可close该请求，同时通知开发者在新分支上进行相应调整。调整完后提交代码重复review流程。 测试时，直接从当前 develop 分支merge到 release 分支，重新构建测试环境完成转测。 测试完成后，从release分支merge到 master 分支，基于 master 分支构建生产环境完成上线。并对 master 分支打tag，tag名可为v1.0.0_2019032115(即版本号_上线时间) 2.2 生产环境Bug修复流程： 非紧急Bug或优化 ：非关键业务流程问题，仅影响用户使用体验，或出现频率较小等，为非紧急Bug，可规划到后续版本进行修复，同开发流程。 紧急Bug ： 严重影响用户使用的为紧急Bug，需立即进行修复。如关键业务流程存在问题，影响用户正常的业务行为 从 master 分支切出一个bug修复分支，完成之后需要同时merge到 master 分支与 develop 分支 如果需要测试介入验证，则可先merge到 release 分支，验证通过后再merge到 master 分支上线 3. Commit 提交规范 3.1 提交的日志格式 每次git提交日志格式为：「类型:描述」 「类型」 用于说明 commit 的类别，只允许使用下面7个标识。 feat：新功能 fix：修补bug docs：修改文档 style：格式化代码结构，没有逻辑上的代码修改 refactor：重构，即不是新增功能，也不是修改bug的代码变动，比如重命名变量 test：增加测试代码，单元测试一类的，没有生产代码的变更 chore：构建过程或辅助工具的变动（不会影响代码运行） 「描述」 是本次commit的描述，说明白本次提交都干了些啥 3.2 更新、合并规范 原则： ① 下游分支更新上游分支代码用rebase； ② 上游分支合并下游分支代码用merge； ③ 更新本分支代码用--rebase (如果本分支有多人共同使用开发的时候)； 这样可以消除自动产生的无用merge记录，有利于后续查看开发记录。 下游分支在更新上游分支代码的时候，如果使用merge,会产生一条无用的合并记录，比较影响查看历史，使用rebase则不会。 4. 使用技巧 使用命令行代替图形化界面。 提交应该尽可能的表述提交修改内容。 区分 subject 和 body 内容，使用空行隔开 subject 一般不超过 50 个字符 body 每一行的长度控制在 72 个字符 subject 结尾不需要使用句号或者点号结尾 body 用来详细解释此次提交具体做了什么 使用 .gitignore 文件来排除无用文件。 不要直接在主干分支上面进行开发。 使用 release 分支和 tag 标记进行版本管理 5. 常用命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//初始化仓库git init git init ~/git-server --bare //初始化一个本地的远程服务器//对状态的跟踪git status//添加文件内容到暂存区（同时文件被跟踪）git add//添加所有文件git add .//从暂存区提交 -m：注释git -commit -m 'first commit' // 从工作区提交git commit -a -m 'full commit'git branch &lt;branchName&gt; //创建一个分支git branch -d &lt;branchName&gt; //删除一个分支git branch -v //显示所有分支信息git checkout &lt;branchName&gt; //通过移动HEAD检出版本，可用于切换分支git checkout -b &lt;branchName&gt; //创件一个分支并切换git checkout &lt;reference&gt; //将其移动到一个引用git checkout - //恢复到上一个分支//git reset 将当前分支回退到历史某个版本git reset --mixed &lt;commit&gt; //(默认)git reset --soft&lt;commit&gt; git reset --hard &lt;commit&gt; git reflog// 保存目前的工作目录和暂存区状态，并返回到干净的工作空间git stash save \"push to stash area\" // 通过save 后面传入信息标识 放到stash区git stash list //查看收藏的记录git stash apply stash@{0} //将保存的内容重新恢复到工作目录git stash drop stash@{0} //将对应的stash记录删除git stash pop //= git stash apply + git stash dropmerge fast-forward //默认 不会显示 feature，只保留单条分支记录。git直接把HEAD指针指向合并分支的头，完成合并。属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commitgit merge --no-ff //指的是强行关闭fast-forward方式。可以保存之前的分支历史。能够更好的查看 merge历史，以及branch 状态git rebase // 修剪提交历史基线，俗称“变基”git rebase --onto master 5755487git push // 将本地历史推送到远程git remote add origin ~/git-server //添加一个远程仓库的别名git remote -v //查看远程仓库信息git fetch // 获取远程仓库的提交记录git pull // git pull = git fetch + git mergegit clone //克隆一个远程仓库作为本地仓库","tags":[{"name":"git","slug":"git","permalink":"https://renzehua1998.github.io/tags/git/"},{"name":"前端","slug":"前端","permalink":"https://renzehua1998.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"研究生社会实践记录","date":"2022-08-06T04:00:00.000Z","path":"2022/08/06/社会实践/","text":"研究生社会实践记录：延安+企业实践 延安实践：新闻稿 企业实践：浪潮","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"计算机网络第二章","date":"2022-08-03T04:00:00.000Z","path":"2022/08/03/计算机网络自顶向下/第二章/","text":"计算机网络自顶向下书籍中科大B站课程笔记 第二章 应用层 本层原理、流行应用原理和相关协议、TCP 套接字（ Socket ）编程、UDP 套接字编程 目标： 网络应用的原理：网络应用协议的概念和实现。服务模型、两种服务模式、内容分发。 网络应用的实例：流行的应用层协议。 编程-Socket API：原语。 互联网中应用层协议最多：可以自定义功能所以协议特别多。很快地设计和部署新的业务模式，鼓励创新。存在各种各样的网络应用。 创建一个新的网络应用：编程、租服务器、装环境、搭服务器、提供客户端下载。网络核心中没有应用层软件，仅在端系统部署，非常块。 2.1 应用层协议原理 体系结构 客户-服务器模式：（C/S:client/server） 服务器一直运行、IP固定；客户端可以下线、IP可变。一般仅客户端主动与服务器相互通信，间歇性连接，客户端之间不相互通信。——可扩展性差、设备增加性能断崖式下降、可靠性差：服务器坏掉直接无法服务。 对等模式：(P2P:Peer To Peer) 可以平滑扩展，但是服务能力不稳定、管理困难。 混合体模式：客户-服务器和对等体系结构。 Nasper（客户端有音乐文件，上线后向服务器发送消息，服务器告诉请求者从哪里下载文件，用户越多下载速度越快——查询是集中式、文件分发是p2p）。 集中通信 QQ 等，在线检测：集中；用户通信：P2P。 进程通信 进程：在主机上运行的应用程序。——同一主机使用操作系统管道即可。 客户端进程、服务器进程。——P2P架构每个会话也有这两种分别。 需要解决的问题： 进程标示和寻址。 传输层向应用层提供服务形式（接口）。位置：层间界面的SAP 形式：应用程序接口API。 定义协议，如何实现应用功能。 问题1：标示和寻址 主机IP、传输层协议（TCP or UDP）、端口号（进程跑在哪里）。 一个进程：用IP+port标示 端节点，一对主机进程之间的通信由2个端节点构成。 问题2：服务形式 穿过的信息： 要传输的报文（本层SDU）、谁传的、传给谁。 传输层实体封装的内容：源端口号，目标端口号，数据等。将IP地址往下交IP实体，用于封装IP数据报。 减少信息量（代表层间信息）——socket：一个整数 TCP代表四元组（源、目的IP端口）UDP代表二元组（本地的IP和端口）。 socket是本地为了便于表示使用的，不是公用的。穿过层间信息少、便于管理。 socket和端口的区别！——其实就是上一章讲的ICI。 TCP-socket 4元组：(源IP，源port，目标IP，目标port) 唯一的指定了一个会话 UDP-socket 但是传输报文时：必须要提供对方IP，port。接收报文时：传输层需要上传对方的IP，port。 也就是这两部分不在socket表示，有单独的数据结构来表示。 指定了应用所在的一个端节点（end point） 进程向套接字发送报文或从套接字接收报文——类比于门。 问题3：如何实现（编制协议） 应用层协议：报文格式，解释，时序等。可以进行传输、解析、实现时序。 应用协议仅仅是应用的一个组成部分。实体仅是涉及到层间通信的处理部分（运行中的软硬件模块），其他业务部分不是实体。 常见协议：HTTP, SMTP（公用）、Skype（私用）。 其他知识点 传输层服务的衡量指标：数据丢失率、延迟、吞吐、安全性。——常见应用对传输服务的要求 传输层提供的服务：TCP（可靠、流量控制、拥塞控制、面向连接；时间保证、最小吞吐保证和安全无法提供）、UDP（不可靠，没有各种保证、没有链接建立过程）。 UDP存在的必要性： 区分不同的进程、无需建立连接、不做可靠性的工作、能够按照设定的速度发送数据。 安全性：TCP &amp; UDP都不安全——明文传输。可以使用SSL，在TCP和应用之间，属于应用层的功能。私密性、完整性鉴别和可认证性。 123456789101112131415graph TB A[应用层协议原理]--&gt;B[体系结构] B--&gt;B1[客户-服务器] B--&gt;B2[对等] B--&gt;B3[混合体] A--&gt;C[进程通信] C--&gt;C1[标示和寻址] C--&gt;C2[服务形式] C2--&gt;C21[TCP-socket] C2--&gt;C22[UDP-socket] C--&gt;C3[如何实现] C3--&gt;C31[应用层协议] A--&gt;D[其他知识点] D--&gt;D1[服务的衡量指标] D--&gt;D2[UDP必要性] 2.2 Web and HTTP 一些术语 web：一种应用，由对象组成——支持协议：HTTP。 对象：各种网页中的资源（使用url来唯一表示）。 基本的HTML文件+引用连接（url）。各种对象通过相互引用构成了网状的信息空间。 url：统一资源定位系统。 12Prot://user:psw@www.someSchool.edu/someDept/pic.gif:port协议名 :// 用户:口令 @ 主机名 / 路径名 :端口 注：url支持匿名访问，所以用户：口令可以省略。http默认80端口，ftp默认21端口，所以url可以不指定。 HTTP概况 HTTP: 超文本传输协议。应用层Web服务的实现协议。 客户/服务器模式：客户端发送request，服务器响应response。 两类：1.0:RFC 1945/ 1.1:RFC 2068 跑在TCP协议之上： 客户发起与服务器的 TCP连接 (建立套接字)。 服务器本身有一个守候（waiting）socket，客户端发送请求后就建立另一个通信socket。 客户端拿到响应内容之后在本地渲染网页。 完成以后关闭连接。 HTTP是无状态的：服务器并不维护关于客户的任何信息。 ——支持更多用户、避免死机同步、避免维护历史信息。 HTTP连接 需要下层实体进行一次交互才能完成。 区别： 非持久HTTP：1.0版本，最多只有一个对象在 TCP连接上发送。 持久HTTP：1.1版本，多个对象可以在一个TCP连接上发送。 非持久： 每次都要重复连接建立、接收、请求、响应。 往返时间RTT（分组从客户端到服务器再回来-忽略小分组传输时间）。 总共2RTT+传输时间。 持久： 非流水线（non-popline）：收到前一个响应后 才能发出新的请求，收到一个对象花费一个RTT。 流水线：一个引用对象就立即产生一个请求，甚至可以达到仅用一个RTT。 好处：可以省掉每次建立连接的一个RTT，避免并行建立TCP连接占用资源。 HTTP请求报文 分类：请求、响应。ASCII码编码，人类可读。 组成： 请求行（GET-请求/POST-上载/HEAD-拿头，文件路径，协议版本号）。 首部行/headline（key:value格式：主机名、浏览器版本、可以设置非持久连接）。 后接回车空行。 实体行（请求报文通常没有）。 提交表单输入： Post方式：输入内容放在实体行 url方式：在url后边 ?key=value&amp;key2=value2 方法类型： HTTP/1.0：GET POST HEAD HTTP/1.1：GET POST HEAD； PUT DELETE（网页管理员使用） HTTP响应报文 组成： 状态行（协议版本号，状态码和解释）。 首部行（key:value格式：连接方式、服务器版本、上次修改日期-版本号、内容长度-tcp不维护界限、内容类型）。 回车空行。 实体行。 响应状态码： 200 OK；301 Moved Permanently；400 Bad Request；404 Not Found；505 HTTP Version Not Supported 可以在自己电脑上测试手动发送客户端请求。 cookies 含义：用户-服务器状态——4个组成部分 HTTP响应报文有一个cookie的首部行-服务器状态； HTTP请求报文有一个cookie的首部行-客户端状态； 用户端系统存储cookie文件，用于浏览器管理； 在Web站点维护一个后端数据库存各客户cookie。 例子，初始请求无cookie，维护cookie-ID，以后请求就带了这个cookie-ID。 作用： 用户验证 购物车 推荐 用户状态 问题：隐私问题。 Web缓存-cache 目标：不访问原始服务器，就满足客户的请求。 代理服务器将内容缓存下来，客户之间请求代理服务器。命中直接返回——客户端快，服务器端负载轻，网络负担也减弱。未命中继续请求原始服务器。 通常缓存是由ISP安装，既是客户端又是服务器。互联网二八定律——20%热点内容80%人访问，使得缓存成为可能。 示例：没有缓存，排队延时接近无限大。两种方式 增大带宽，更大的接入互联网速度。 安装本地缓存，在40%命中率的条件下平均响应时间甚至还减小了。 问题：远程服务器内容变了。解决方法：条件GET方法。If-modified-since 123456789101112graph TB A[web应用和HTTP协议]--&gt;B[HTTP] B--&gt;B1[连接] B1--&gt;B11[非持久] B1--&gt;B12[持久] B12--&gt;B121[流水线] B12--&gt;B122[非流水线] B--&gt;B2[请求] B--&gt;B3[响应] A--&gt;C[web应用] C--&gt;C1[cookies] C--&gt;C2[cache] 2.3 FTP* 文件传输协议（了解） 客户/服务器模式（还有管理系统、用户界面等等），端口号为21，可以unload也可以download。 可以建立连接，身份认证（口令都是明文传输），然后可以发送命令-上载下载list等等，服务器单独使用20号端口向客户端发送TCP数据连接。控制连接： 带外（ “out of band” ）传送。区别于http的“带内”。 FTP天然就是有状态的协议，而http无状态，只能靠cookie打补丁。 一些控制命令和响应，都是ASCII码明文传输。 2.4 EMail 概述 3个主要组成部分：  用户代理（客户端软件：浏览器、outlook软件等）  邮件服务器  简单邮件传输协议：SMTP 用户代理：又名 “邮件阅读器”。 过程：用户代理发给邮件服务器，邮件服务器放到队列当中，使用SMTP将其发到对应其他邮件服务器。目标服务器收到自己的用户邮箱当中，运行客户代理从自己的邮箱中拉取内容（POP3等协议）。 SMTP 服务器守候在25端口，接收端作为服务器，发送方作为客户端。 三个阶段：握手 传输报文 关闭 命令/响应报文：ASCII码，包含状态码和状态解释。 报文必须为7位ASCII码 一个发邮件的例子。为什么要放到队列里呢？1. 邮件很多要排队处理、2. 定期发送可能不是实时都有邮件。 伪造用户发邮件很容易，全部是明文传输。可以传英文，中文就不行了，文件也不能传。 建立连接后可以发很多的邮件，不用每次都重新建立连接。——持久连接 可以通过telnet命令自己尝试和邮件服务器进行交互。 总结：持久连接、7位ASCII编码、SMTP服务器使用 CRLF.CRLF结尾。 与HTTP比较： 相同：都是ASCII形式的命令 区别：HTTP拉，SMTP推；HTTP一次响应报文至多一个对象，SMTP同时把所有对象打包；HTTP有非持久连接模式。 报文格式 文本报文的标准： 首部行：To: From: Subje: （主题）CC: （抄送）、密送等等。 主体：ASCII码字符。 多媒体扩展（MIME）：base64编码 把若干个不在ASCII范围的内容编码到ASCII，同时支持解码。 访问协议 前两跳是推，最后一跳是拉。包含POP3、TMAP、HTTP。 POP3：邮局访问协议，包含身份确认。 IMAP：在POP3基础上包含远程目录维护等功能。 HTTP：web、文件上下载、收邮件。 POP3： 用户确认阶段：用户名密码。 事务处理阶段：通过命令进行操作。（下载并删除、下载并保留）会话无状态。 IMAP：保留用户状态，支持远程目录维护。 1234567891011graph TB A[EMail]--&gt;B[概述] A--&gt;C[SMTP] C--&gt;C1[明文ASCII] C--&gt;C2[持久连接] A--&gt;D[报文格式] D--&gt;D1[文本] D--&gt;D2[多媒体] A--&gt;E[访问协议] E--&gt;E1[POP3] E--&gt;E2[TMAP] 12345graph TB B0[概述] B0--&gt;B1[用户代理] B0--&gt;B2[邮件服务器] B0--&gt;B3[传输协议] 2.5 DNS 概述 功能：域名到IP地址的转换。 DNS不是给人直接用的，是给其他应用用的（web、FTP）——基础设施 必要性：IP地址用于标识、寻址，很难记。用户使用主机的域名，字符串转换为IP让网络进行寻址。 要解决的问题： 如何命名：层次化命名。 如何完成转换：分布式维护。 如何维护：增加删除的方法。 历史： ARPANET：没有层次、同时在一个平面；一台主机提供解析服务。——重名太多、很难管理。 主要思路： 分层命名。 分布式数据库。 UDP 53端口，不需要握手。 互联网的核心功能——反而是靠边缘设备来实现的。 主要目的： 主机名-IP地址的转换。name/IP translate——核心功能 主机别名（管理）到规范名字（访问）的转换。Host aliasing 邮件服务器别名和正规名字转换。Mail server aliasing 负载均衡。Load Distribution 名字空间 （问题一） 结构：层次树状结构——几百个顶级域、若干个二级域、许许多多子域，树叶是主机。 顶级域：通用、国家。.com国际公司、.edu学校；.cn中国、.us美国。域名越靠后域越高级，对主机做标识，从树叶往树根走。对域做标识，从树枝往树根走。 有13个根名字服务器——可靠、便于维护（每次从树根找总能找到） 域名：从本域往上，直到树根；使用“.”间隔；可以有主机的域名和域的域名。 域名的管理： 子域的命名由主域定义，不同主域下子域命名完全有可能不同。 域与物理网络无关：（域的划分是逻辑的） 一个域的主机可以不在一个网络 一个网络的主机不一定在一个域 名字服务器 （问题二） 一个名字服务器的问题：可靠性、扩展性、维护。 区域(zone)： 将DNS名字空间划分为互不相交的区域。 每个域有一个权威名字服务器（可以在区域外）。 一个分区的例子。上层权威域名服务器维护一个到下层权威域名服务器的指针。 TLD服务器：顶级域服务器。 区域名字服务器维护资源记录：(resource records) 子域情况 域名-IP地址（别名等）映射情况 资源记录格式（数据库设计）：域名-Domain_name、生存时间-Ttl（缓存记录为有限值-默认两天；权威记录为无限）、类别-Class（都是IN）、值-Value（IP地址或其他）、类型-Type（存储的资源的对应类型）。 Type字段： Type=A：主机+IP Type=CNAME：别名+规范名字 Type=NS：子域的域名+子域权威服务器的域名 Type=MX：邮件服务器别名+正规名字 对于主域服务器内要找子域必须有两条记录（服务器是谁-域名、服务器在哪-IP） DNS工作过程： 应用调用解析器。 解析器访问Local Name Server。（自动配或者手动配，一般在一个子网） Name Server返回响应。 上网所需四个参数：IP地址、子网掩码、default gateway（默认网关）、DNS local Name Server。 本地名字服务器（Local Name Server）：并不严格属于层次结构。 名字服务器(Name Server)名字解析过程： 在Local Name Server（域名在子网/有缓存）：直接返回。 递归查询：根服务器负担太重。 迭代查询：根（及各级域名）服务器返回是下一个NS的地址。学到以后可以缓存下来。 报文格式 查询和响应报文格式相同（不用硬记） 标识符（ID）：16位 ——重要：支持流水线的方式同时查询多个。 标志位（flags） 其他字段（略） 缓存：学到就缓存，TTL（默认2天） 维护问题 （问题三） 在上级域的名字服务器中增加两条记录，指向子域的域名（名字服务器的名字-typeNS）和域名服务器的地址（typeA）。 子域名字服务器自行维护自己下面的域名。 安全问题 ——相对来讲还比较可靠。 DDoS 攻击：对根服务器、对TLD服务器——效果一般（有缓存） 重定向攻击：中间人攻击、DNS中毒——技术上较困难 利用DNS基础设施进行DDoS：伪造IP、查询放大——效果有限 123456789101112131415161718graph LR A[DNS]--&gt;B[名字空间] B--&gt;B1[树状结构] B--&gt;B2[通用/国家] A--&gt;C[名字服务器] C--&gt;C1[资源记录格式] C1--&gt;C11[Type字段] C--&gt;C2[工作过程] C--&gt;C3[名字解析] C3--&gt;C31[直接返回] C3--&gt;C32[递归查询] C3--&gt;C33[迭代查询] A--&gt;D[维护问题] D--&gt;D1[名字服务器的域名] D--&gt;D2[名字服务器的IP] A--&gt;E[报文格式] E--&gt;E1[格式相同] E--&gt;E2[标识符作用] 2.6 P2P应用 一类应用。——C/S模式可靠性可扩展性的问题。 请求节点增加、提供服务节点也在增加。没有（或极少）一直运行的 服务器。BT-文件分发、KanKan-流媒体、Skype-VoIP（网络电话） 与C/S对比 例文件分发： 一台服务器分发文件（大小F）到N个peer dmin-客户端最小下载带宽。在客户端量很大的时候，瓶颈在于服务器。随着客户端增加下限线性提升。 最少需要上载一份拷贝F，所有客户端总体下载量NF 其他所有的peer节点都可以上载 客户端增加性能下限变化缓慢。 P2P模式的问题：可管理性不好、动态变化资源可能找不到。 几种管理方式 ppt上在后边 overlay（覆盖网）Peer节点构成的提供服务的抽象网络。 在存储文件时，有文件源数据、文件描述、哈希值（唯一确定用于查找） 非结构化：overlay是随机的、任意的 以文件共享系统为例 文件共享面临的问题：如何定位资源、如何处理上下线 集中化目录：Napster 资源管理中心化，文件分发存储分布式——单点故障、性能瓶颈、侵犯版权。 完全分布式：Gnutella 没有中心服务器，开源。用泛洪（flooding）的方式发送查询，向所有邻居进行查询，邻居再向邻居发送查询。安装好后有一个常在线设备列表，发送ping，转发ping，都回复pong，随机建立连接。退出时和邻居节点打招呼，邻居再连一条保持连接度——查询请求过多（限制范围洪泛查询）、效果不好。 混合体：KaZaA 分组员组长。组长之间的关系类似于Gnutella全分布式、组长与组员之间类似Napster中心与边缘。使用描述符匹配，返回元数据、哈希值和IP。 处理技巧：请求排队、激励优先权、并行下载 典型例子：BT（BitTorrent）——一个节点加入到一个洪流（Torrent）中，可以共享资源。把资源划分为很多小块，使用bitmap标识当前设备有没有这一部分资源。所有节点在洪流中泛洪bitmap，可以知道哪些节点拥有那些资源块。 请求块：刚加入时bitmap全是0，请求四个块（稀缺优先）。周期询问、按需请求。 发送块：服务越多性能越好——一报还一报tit-for-tat（个人利益和集体利益相捆绑）。同时只服务4个最好的（有限疏通）；每隔30秒，两个周期新选择带宽大的，第三个周期随机选一个（优化疏通）可以发现更好的伙伴（启发算法思想）。 扰动churn: peer节点可能会上线或者下线。 节点拥有文件的全部（种子）、都没有（吸血鬼）。拥有全部可以选择离开或者留下。 加入洪流的过程是带外进行的。在维护网站检索资源列表，点击torrent文件，包含了tracking server（跟踪服务器），tracking server维护当前上载下载的过程，再获取peer列表，建立连接进行上下载。 结构化（DHT）：overlay有规律（环、树等等） 哈希表、DHT方案、环形DHT、Peer波动 例如，维护一个环状网络，节点和内容id是重叠的，节点哈希值对应内容哈希值空间——知道到哪去查。 123456789graph TB Z[与C/S对比] A[几种管理方式] A--&gt;B[非结构化] B--&gt;B1[集中化目录] B--&gt;B2[完全分布式] B--&gt;B3[混合体] A--&gt;C[结构化] 2.7 CDN 内容分发网络。 web访问加速功能服务的内容分发系统——分布式应用层基础设施 网络中杀手级业务（占用大量带宽的业务：视频等等） 问题：规模性——如何同时提供大量传输、异构性——设备异构要求各不相同。 多媒体流化服务 视频可以认为是一系列图像的序列，图像是一系列像素点的序列，视频同时还包含音频。在传输的时候要经过压缩——时间空间冗余度。 压缩方式：CBR——固定码率；VBR——码率随时间动态变化。 例如：AVS、MPEG 1、MPEG 2、MPEG 4。可伸缩编码。 流化服务streaming：”边下边看“，让用户的点播延迟大大降低。 常见流化服务协议：DASH——Dynamic, Adaptive Streaming over HTTP（在HTTP上动态自适应流化播放） 服务器端： 将视频文件分割成多个块。 每个块独立存储，有不同码率。 告示文件（manifest file）包含了每一块的url、码率、解析度等等信息。 客户端： 下载告示文件（不同块可能在不同服务器中）。 周期性测量带宽，根据需求、缓冲区和延迟情况动态调节向哪里请求。 一个时刻请求一个块。——带宽够，请求最大码率，不同时刻可以切换请求源。 解决不同客户端需求和多网络服务器情形下的方案。客户端自适应决定什么时候、什么码率、请求源。 存在的问题：高并发服务器性能瓶颈、链路存在带宽瓶颈、单点故障、重复传输造成流量浪费。——CDN的出现 CDN 全网部署缓存节点，就近向用户提供服务。ICP买CDN运营商的服务，以更好地向用户提供内容加速服务。客户端经过域名解析重定向找到最近CDN节点。（中国蓝汛） 主要分类（两种）： enter deep：部署在local ISP，离用户近，非常快但是管理困难。（深入群众） bring home：部署在关键ISP节点附近，部署节点很少，离用户较远。（抢占关键少数位置） 实现：（让内容靠近用户） ICP在CDN节点中存储内容的多个拷贝 用户在告示文件获取块的位置 域名解析重定向到最近的拷贝，请求内容 特点：over the top 在互联网最顶层（应用层）实现 在网络边缘提供服务 OTT挑战：从哪个节点获取？如何切换、拥塞控制？节点如何部署？ 示例： 小示例：ICP（netcinema）、CDN（kingCDN）。包含主服务器和权威名字服务器。 Bob访问ICP获取视频url 向netcinema名字服务器请求返回重定向url 向kingCDN名字服务器请求url 在kingCDN的cache节点请求流化服务 对用户是透明的，用户察觉不到。 经典示例：网飞Netflix 包含用户注册管理服务器 制作后上载到云端（租用服务器），同时租用CDN服务 每次用户登录以后点击网页域名解析重定向 由CDN节点向用户提供服务 12345678910111213graph TB Z[流化服务] Z--&gt;Z1[服务器端] Z--&gt;Z2[客户端] A[CDN] A--&gt;B[分类] B--&gt;B1[enter deep] B--&gt;B2[bring home] A--&gt;C[实现] A--&gt;D[特点] D--&gt;D1[over the top] A--&gt;E[示例] E--&gt;E1[netflix] 2.8 TCP 套接字编程 Socket编程总述 传输层向应用层各种协议提供报文传输服务。 位置：Socket；形式：Socket API。 本章讲应用层要怎么调用socket、使用socket、关闭socket来实现传输。 分类： TCP: 可靠的、字节流的服务（保证流，不保证报文界限）。面向连接。 UDP: 不可靠（数据UDP数据报）服务。无连接。 socket：也是一个整数（两个端节点的代表-四元组）应用进程与端到端传输协议（TCP或UDP）之间的门户。 TCP服务：从一个进程向另一个进程可靠地传输字节流。 socket API是一套函数（加粗都是函数） 概述 服务器先运行 创建一个socket（什么都不是）——整数 和本地端口捆绑——welcome socket（本地IP+端口） 阻塞式等待接收用户的连接（没来就不执行） 客户端主动连接 创建客户端本地socket（隐式捆绑到本地port） 根据服务器IP+端口，与服务器进程连接，未回复就是阻塞 客户端连接请求到来时 服务器接受请求，解除阻塞。 返回一个新的socket（connection socket） 在新socket上收发，支持同时多个，使用源IP+port区分 传输完成关闭connection，welcom仍在 连接API调用有效时，客户端与服务器建立了TCP连接。 应用程序角度：TCP在客户端和服务器进程之间提供了可靠的、字节流（管道）服务 应用样例 详细流程： 客户端从键盘读取字符发给服务器、服务器读取、转大写发给客户端、客户端读取并打印。 黑色代表TCP报文交互，红色代表应用报文交互。 welcomeSocket =Socket(…) 创建欢迎socket ——服务器 bind(welcomeSocket, &amp;sad, );和本地端口捆绑——服务器 connectionSocket = accept(welcomeSocket, &amp;cad,… 等待连接建立请求，没有请求就阻塞——服务器 ClientSocket = socket(PF_INET,…)创建本地socket ——客户端 隐含了bind 和本地某个端口捆绑——客户端 connect(clientSocket, &amp;sad …) 连接请求（应答返回以后解除阻塞）——客户端 connectionSocket = accept(welcomeSocket, &amp;cad,… 收到请求返回应答，建立新的connection socket，包含客户端IP端口。——服务器 write 发送需要的资源请求——客户端 read 读取接收请求并解析——服务器 write 计算出结果发送回复——服务器 read 读取服务器返回值，输出显示——客户端 close 关闭连接，删掉connection socket——服务器 close 关闭连接，删掉client socket——客户端 两个进程可以同时守候同一个端口。socket不一样代表不同的进程。 数据结构：两个结构体 sockaddr_in：端节点 sin_family：地址族（也可以用于IPX通讯，用于标识） sin_port：端口号 sin_addr：IP地址 sin_zero[8]：对齐 hostent：域名地址转换 *h_name：主机域名（字符串指针） **h_aliases：主机一系列别名（二维） h_length：地址长度（32位等） **h_addr_list[i]：IP地址列表（域名解析函数调用） 代码： 客户端：两个参数（服务器域名argv[1]，服务器端口号argv[2]）argv[0]是应用程序本身的名字。创建结构体变量sad。端口号变成短整型（防止高低位出错）。调用解析器获取IP地址。调用connect函数建立连接（默认bind）。gets（输入）、write（发送）、read（接收）、printf（打印）、close（关闭）。 服务器：一个参数（当前应用进程守候的端口号）。两个结构体——sad本地端节点，cad客户端节点。端口变成整数。sad、cad赋值，转换成短整型。建立welcom socket。手动bind。死循环while(1)，read、write、close。listen（建立一个队列，来的连接请求进入排队，每次取一个进行服务）。也可以做成并发模式。 123456789101112graph TB A[TCP socket] A--&gt;B[详细流程] B--&gt;B1[welcome] B--&gt;B2[connection] B--&gt;B3[client] A--&gt;C[数据结构] C--&gt;C1[sockaddr_in] C--&gt;C2[hostent] A--&gt;D[代码] D--&gt;D1[客户端] D--&gt;D2[服务器] 2.9 UDP 套接字编程 没有连接、没有握手，不和对方IP端口相捆绑。每次发送必须指明对方IP端口作为报文一部分。收的时候要知道内容和对方端节点IP端口。可能乱序， 也可能丢失。——协议数据单元叫做数据报。 应用程序角度：UDP 为客户端和服务器提供不可靠的字节组的传送服务。 过程 serverSocket 创建起一个socket——服务器 bind 和本地IP+端口相捆绑。IP地址作为系统常量——服务器 recvFrom 等待客户端请求，有值解除阻塞——服务器 clientSocket 创建本地socket——客户端 默认捆绑本地端口——客户端 sendto 发送请求，指明socket值和内容——客户端 serverSocket sendTo（write） 解除阻塞，进行处理，发送内容——服务器 read 读取内容进行显示——客户端 服务器返回等待——没有连接关闭操作 close 关闭连接，删掉client socket——客户端 服务器端就一个socket，没有welcom和connection之分。 代码 客户端：两个参数-主机名+端口号。建立socket，sad变量清零赋对应的值。get获取输入、Send发送请求、read读取响应、关闭连接。 服务器：一个参数-守候端口号（转为整数）。sad赋值。和本地端口号相捆绑。死循环进行操作，接收请求、处理、进行发送。 1234567graph TB A[UDP socket] A--&gt;B[过程] B--&gt;B1[没有连接建立操作] A--&gt;C[代码] C--&gt;C1[客户端] C--&gt;C2[服务器] 2.10 小结 应用程序体系结构 1 客户-服务器 2 P2P 3 混合。 传输层服务质量：可靠性、带宽、延时、安全。 传输层服务模式：TCP、UDP。 各种流行的协议： HTTP  FTP  SMTP, POP, IMAP  DNS Socket编程 详细知识点： 应用层报文类型：请求/响应报文。 报文格式：首部、数据。 报文分类：控制报文 vs. 数据报文、带内vs. 带外 模式：集中式 vs. 分散式、无状态 vs. 维护状态 报文传输：可靠的 vs. 不可靠的 总的一条：在网络边缘处理复杂性业务。","tags":[{"name":"计网","slug":"计网","permalink":"https://renzehua1998.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"告警聚类算法框架","date":"2022-07-17T04:00:00.000Z","path":"2022/07/17/告警聚类算法框架/","text":"科研笔记：告警聚类算法框架 告警聚类算法框架 IDS告警聚类算法的一种模型框架。 1. 问题背景 对于IDS系统中每天会产生大量告警，如果一条一条处理会非常复杂，超过人工能力。我们需要把这些告警进行归并和关联分析，找到常见的模式进行批量处理。——告警聚类就是对告警进行归并的过程，是整个工作的基础。 告警 由一个固定的属性向量 组成。 在我们的场景中为：源目的IP、端口、告警厂商、告警类型、源目的设备类型、攻击结果、威胁程度等。 真实的攻击或业务行为 引发一组告警 ，所有关联告警集合由，，， 给出。 这些由同一种原因引起的系列告警，具有如下特征： 告警属性特征相同或大部分相似（同源、同目的、同类型、同威胁程度、同设备类型等）。 构成简单，一般为单中心型，或者是典型二分图，源和目的设备类型相同。 具有原子性、不可再分性，仅涉及入侵过程的一步。 对于上一步得到的原子集群的集合，与多步攻击相关的多个原子集群是的子集，所有多步攻击的集合是 。 告警聚类就是在中使用各种方法，得到一个告警聚类，使得尽可能地接近。 2. 评估指标 对于不同聚类算法得到的结果，符合我们要求的，更接近本身的原子集群集合的应该满足： 1. 告警角度 每个集群中大部分告警特征相似。 告警的轮廓系数：（与原子集群集合区分） ： 向量到同一簇内其他点不相似程度的平均值。 ： 向量到其他簇节点的平均不相似程度的最小值。 ：两条告警和的不相似程度，使用汉明距离来衡量，根据需要，不看具体IP值，而是综合考察厂商、类型、IP属性、攻击结果、威胁程度。 这里使用归一化的轮廓系数，使其区间范围同下面几个指标一致，为： 每个集群内告警的相似程度使用集群平均轮廓系数来衡量：（Silhouette） 对聚类结果的轮廓系数使用总平均轮廓系数来衡量： 越接近1说明聚类后集群内告警越相似集群间告警越不相似、越接近0说明集群内告警越不相似。 2. 拓扑角度 大部分集群都是单中心型或简单型（一对一）。 ——因为多中心型可以看作多个单中心型的复合，所以单中心型更具备原子性。 借用GAC论文中对集群告警流图拓扑类型线性化指标： 其中是集群中所有节点，是集群中所有源节点（origin），是集群中所有目的节点。 是简单型，是单中心发散型，是单中心汇聚型。 这三个指标哪个最大（最接近于1），就说明集群更倾向于哪个拓扑分类。其中不用计算，如果集群内只有一条告警，那么一定就是 每个告警集群的原子性指标为： 对聚类结果的总原子性指标为每个告警集群拓扑原子性指标的平均值： 越接近1说明聚类得到的集群原子性越好，越接近0说明原子性越差。 二分性很好：告警链很少（既是源也是目的的设备很少）。 定义聚类结果的二分性指标：（Bipartite） 其中是集群中所以节点，是集群中所有源节点（origin），是集群中所有目的节点。 越接近1说明聚类得到的集群二分性越好，越接近0说明二分性越差。 3. 设备角度 大部分集群中涉及的源和目的设备类型种类单一：如源节点都是外部IP、目的节点都是内部设备出口。 根据基尼不纯度的定义： 其中F是待求集合，是中第类出现的频率。可以看到，越接近1，不纯度越高。区间范围为。 我们的需求是节点种类越单一越好，所以需要反其道而行之，定义集合基尼纯度： 可以看到，越接近1，纯度越高。区间范围为。 定义集群的所有源节点为，所有目的节点为，设备种类为共n种。 总设备纯度： 越接近1说明聚类得到的集群设备纯度越高，越接近0说明设备纯度越低。区间范围为。 4. 总性能指标 上面几个小节总共从三个方面给出了衡量聚类效果的四种指标，分别是： 总平均轮廓系数：、总原子性指标：、总二分性指标：、总设备纯度：。 他们的区间都被归一化为，避免在优化时小数被大数淹没的情况。 这几个指标分别用来刻画：集群内告警属性相似度、集群拓扑原子属性、集群二分属性、集群中设备纯度。 所以总性能指标为： 3. 优化模型 结合上一节内容，我们给出IDS告警聚类算法的一种优化框架： 在对告警集合的所有划分集族中，找到一个划分，使得总性能指标取到最大值。 是集群中所有节点，是集群中所有源节点（origin），是集群中所有目的节点。 同时，考虑到在此定义下，每条告警是一个集群的方法总指标最优，这显然是不合理的，所以需要加入限制条件使得至少有两个以上告警被归并到同一个簇中： 所以，总优化模型描述如下： 其中 为了松弛约束，可以定义聚类率： 越接近1说明聚类得到的集群聚类率越高，告警削减效果越好，越接近0说明聚类率越低，告警削减效果越差。区间范围为。 松弛后的优化模型为：","tags":[{"name":"图与网络","slug":"图与网络","permalink":"https://renzehua1998.github.io/tags/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络第一章","date":"2022-07-16T04:00:00.000Z","path":"2022/07/16/计算机网络自顶向下/第一章/","text":"计算机网络自顶向下书籍中科大B站课程笔记 第一章 概论 目的：了解概念术语、基础工作原理（概念基础） 这一章最重要，特别详细地学习！ 什么是Internet ? 什么是协议? 网络边缘 接入网、物理媒体 网络核心：分组交换、线路交换 Internet/ISP 结构 性能：丢包、延时、吞吐量 协议层次、服务模型 历史 1.1 什么是Internet 什么是网络：具体构成的角度 节点和边构成，和大小形状无关。 计算机网络： 节点：1. 主机节点（终端服务器）■；2. 数据交换节点（路由器交换机中继器负载均衡）⚪。 边：链路 1. 接入网链路-主机接数据交换；2. 主干链路-数据交换节点之间 协议：各种规则制定的标准，可以相互配合进行工作。 Internet：互联网-网络的网络； Intranet：企业内网； 互联计算设备：主机/端系统（end system/host）；各种应用程序 通信链路：link-网线/光纤；各种支持的协议——重要指标：带宽bps 分组交换设备：转发分组-路由器交换机（switch） 互联网标准：RFC、IETF 什么是协议 协议：对等层实体在通讯过程中应当遵循的规则集合 对等层实体（网卡、相同协议、相同服务层等等）-peer 包括报文（PDU）格式、次序和动作。语法规范、时序、操作。 什么是网络：从服务角度 分布式应用（应用层以上的主机、网络服务进程） 向应用提供通信服务的基础设施（应用层以下的实体）：面向连接/无连接 12345678graph TD A[什么是Internet]--&gt;B[从构成角度] B--&gt;B1[\"节点（主机、数据交换）\"] B--&gt;B2[\"边（接入网、主干链路）\"] A--&gt;C((什么是协议)) A--&gt;D[从服务角度] D--&gt;D1[分布式应用] D--&gt;D2[基础设施] 1.2 网络边缘 网络结构（总） 网络边缘：主机、应用程序（客户端和服务器） ——提供服务应用 网络核心： 互连着的路由器、网络的网络 ——数据交换（分布式系统）基础设施 接入网、物理媒体：有线或者无线通信链路 ——边缘接入核心基础设施 通信模式 网络边缘——运行的应用程序 client/service 客户端/服务器模式：服务器主，客户端从。请求服务器硬件、计算、数据资源。客户端主动，服务器被动。服务器一直运行，客户端有需要去请求。——主，从模式。可扩展性差，请求载荷增加性能断崖式下降。 peer-peer 对等模式：每个节点即时客户端又时服务器，数据存储是分布式的，通信也是分布式的。——文件分发系统，可扩展性强。 面向连接服务 目标：在端系统之间传输数据——通信之前握手打招呼，存储栈、协议栈、资源栈做好准备。连接建立状态。 与有连接服务的区别： 通信状态在端系统之中维护，网络不知道。——面向连接的服务 通信状态在经过的各个节点都知道。——有连接的服务 典型-TCP 服务： 可靠、保序：不出错、不重复、不丢失、不乱序。——靠协议自己的努力：缓存、编号、确认、重传（占用时间空间资源） 流量控制：协调处理数据速度不同的两个设备协同工作。 拥塞控制：路径堵了以后主动降低速度。 无连接服务 目标：在端系统之间传输数据——通信前不打招呼，直接连接。 典型-UDP服务： 无连接 不可靠数据传输 无流量控制 无拥塞控制 UDP：实时多媒体应用、速度型应用。流媒体、远程会议、 DNS、 Internet电话 TCP：HTTP (Web), FTP (文件传 送), Telnet (远程登录), SMTP (email)。 1234567graph TD A[网络边缘]--&gt;B[通信模式] B--&gt;B1[\"客户端/服务器模式\"] B--&gt;B2[\"对等-端到端模式\"] A--&gt;D[服务种类] D--&gt;D1[面向连接-TCP] D--&gt;D2[无连接-UDP] 1.3 网络核心 问题：怎么实现？电路交换（预留专有线-跑腿服务）、分组交换（存储转发-发快递） 电路（线路）交换 通过信令系统分配一条独享的线路。端到端的资源被分配给从源端 到目标端的呼叫 “call”。——电话线路网络 ——性能有保障，但是会有资源浪费。 通过复用的方法把线路资源进行分配：时分多路TDM、频分多路FDM、波分多路WDM、码分多路CDM。——划分为资源片（带宽等） 练习题：计算每个资源片的速率，计算传递时间，加上建立连接时间。有时候计算对方收到的时间的话，需要加上信号传播的时间-传播延迟（物理距离/信号速度）。 对于计算机来说好多时候请求是突发的，对带宽的需求不均匀。对建立连接的实时性要求高，所以不适合使用这种方式。 分组交换 分组存储转发方式： 每一条通信时不再分成资源片piece，使用全部带宽。 主机之间传输的数据被分为一个个的组packet。 存储-转发：避免大数据传输占用带宽成为独享。 收到整个packet才转发。 延迟比线路交换大。（坏处） 按需使用，共享性。（好处） 存在排队机制，不使用的时候不占用网络资源。 举例： 速率为R bps的链路 ，一个长度为L bits 的分组 的存储转发延时： L/R 。计算需要几次存储、转发，乘这个系数。 注意：计算时不要把发送和接收都算进去，发的同时就在收。 排队延迟和丢失： 如果到达速率&gt;链路的输出速率时，分组要排队，缓存队列用完的话会被抛弃。 网络核心的关键功能：转发（局部）、路由（全局）。 转发：查路由表决定往哪传。 路由：根据当前状态计算维护路由表。 统计多路复用：其实也是划分时间片，但是划分不均匀，模式不是固定的。 二者对比 同样的网络资源，分组交换允许更多用户使用网络！——支持同时使用的用户数更多，可以用计算的方式证明。是9而不是10的原因是不能完全占满，流量强度100%的时候没有任何裕量会挂。 分组交换是“突发数据的胜利者” 适合突发式数据传输，资源共享、不用呼叫。 过度使用会造成网络拥塞：分组延时和丢失。需要拥塞控制。 提供类似电路交换的服务：仍未解决。 分组交换分类 根据网络层是否建立连接分为两种： 数据报网络：数据报携带目标主机完整地址。（寄信）——不同分组路由可以改变，可能会失序。 虚电路网络：需要进行握手，每个分组携带虚电路号。——建立以后路径保持不变，查询虚电路号存储转发即可。虚电路连接体现在中间所有经过的所有节点上。 123456789graph TB A[网络核心]--&gt;B[电路交换网络] B--&gt;B1[FDM] B--&gt;B2[TDM] B--&gt;B3[WDM] B--&gt;B4[CDM] A--&gt;C[分组交换网络] C--&gt;C1[虚电路网络] C--&gt;C2[数据报网络] 1.4 接入网和物理媒体 接入网 把边缘设备接入网络核心的网络（将端系统和边缘路由器连接）：住宅接入网络、单位接入网络；无线接入网络（局域、广域）。 重要指标：带宽bps（bits per second每秒多少位）、共享/专用。 住宅接入 住宅接入-电话公司：直接利用电话线网络拨号上网，“猫”modem/调制解调器，4kHz，调频调幅调相综合调制。带宽很窄，56Kbps及以下，无法同时打电话和上网。 digital subscriber line (DSL)-电话公司：上下行不对称-ADSL。0-4K语音通话，4K以上一块上行一块下行，在各自的频段进行调制解调。可以边打电话边上网，使用ADSL猫。上行1Mbps下行10Mbps。每个用户一个专用线路到CO（central office）。 线缆网络-电视公司：有线电视公司同轴电缆（单向只支持下行），进行双向改造支持上行，某些带宽用于传统电视，一部分上行一部分下行。——共享服务。 特点： 上游光纤，下游同轴电缆。——hybrid fiber coax（混合光纤同轴）。 非对称: 最高30Mbps的下行传输速率, 2 Mbps 上行传输速率。 各用户共享到线缆头端的接入网络：线缆和光纤网络将个家庭用户接入到 ISP 路由器。 电缆模式-电网公司：power modem，我国用的很少。 当今常见接入模式：无线路由设备-路由器、防火墙、网络地址转换、IP分配功能。然后通过连接猫接入运营商，带着WiFi设备一起，支持有线无线接入。具备路由功能、局部交换功能、无线接入功能。 企业接入 通过AP、无线接入点整合所有设备接入交换机端口，通过交换机级联，连接公司路由器接入互联网。(Ethernet-以太网) 无线接入 各无线端系统共享无线接入网络： WLAN：建筑物内部 无线广域 4G 5G：由电信运营商提供 物理媒体 发送接收节点之间传递bit的介质（光纤、电缆、开放空间传电磁波） 分类： 导引型媒体：有形的介质，信号沿着固体媒介被导引。 非导引型媒体：开放的空间传输电磁波或者光信号。 导引型媒体主要包括： 双绞线 (TP) ：两根绝缘铜导线拧合。 同轴电缆： 两根同轴的铜导线。 光纤和光缆：玻璃纤维中传播光脉冲。（在光纤中全反射-单模、多模） 非导引型媒体链路包括： 地面微波 LAN wide-area 卫星 环境影响：反射 吸收 干扰，随着距离平方反比，高速衰减。 123456789graph TB A[接入网和物理媒体]--&gt;B[接入网] B--&gt;B1[住宅接入] B--&gt;B2[企业接入] B--&gt;B3(有线接入) B--&gt;B4(无线接入) A--&gt;C[物理媒体] C--&gt;C1[导引型媒体] C--&gt;C2[无导引型媒体] 1.5 Internet结构和ISP 从演化的角度来看另一种划分方式：一个运营商的网络叫做一个ISP网络。教育网、电信网、银行服务网……通过路由器联系在一起——网络的网络。 端系统通过接入ISPs (Internet Service Providers)连接到互联网。 发展和演化是通过经济的和国家的政策来驱动的 全互联的话需要连接，代价特别大，不可扩展。 演化过程 方法：将每个接入ISP都连接到全局ISP。通过全球ISP经过上行下行可以连接起来——有利可图。 竞争：全局ISP是可行的业务，那会有竞争者，有利可图，一定会有竞争。 合作：通过ISP之间的合作可以完成业务的扩展，肯定会有互联，对等互联的结算关系。——IXP-互联网交换点（骨干流量通过此交换点）。 业务细分：将局部ISPs连接到全局ISPs。 ICP-Internet Content Providers：互联网内容服务商（提供上层业务-聊天、搜索、购物等等），可能会在全球各地部署自己的机房，构建自己的网络，一般部署在离ISP比较近的地方。——ISP费用太高成本大。 主要结构 ——松散的层次结构，互联是任意的，不稳定可以及时更换链路。 中心第一层ISP：分布广、节点有限、带宽很大。直接与其他第一层ISP相连；与大量的第二层ISP和其他客户网络相连。——Tier1 POP：point-of-presence不对等关系-上下级，低级ISP提供POP接入高级ISP从而接入互联网。 第二层ISP: 更小些的 (通常是区域性的) ISP。与一个或多个第一层ISPs，也可能与其他第二层ISP。——Tier2 第三层ISP与其他本地ISP：local ISP，接入终端。——local 一个分组在跨国传输的时候要经过许多网络。 内容提供商ICP可能会部署自己的网络,连接自己的在各地的DC（数据中心）。连接若干local ISP和各级（包括一层）ISP，提供更快的服务。 连接方式 POP: 高层ISP面向客户网络的接入点，涉及费用结算。 对等接入：2个ISP对等互接，不涉及费用结算。 IXP：多个对等ISP互联互通之处，通常不涉及费用结算。 ICP自己部署专用网络，同时和各级ISP连接。 123456789101112131415graph TB A[Internet结构]--&gt;B[演化过程] B--&gt;B1[竞争] B--&gt;B2[合作] B--&gt;B3[业务细分] B--&gt;B4[ICP] A--&gt;C[主要结构] C--&gt;C1[Tier1] C--&gt;C2[Tier2] C--&gt;C3[Local] A--&gt;D[连接方式] D--&gt;D1[POP] D--&gt;D2[对等接入] D--&gt;D3[IXP] D--&gt;D4[ICP] 1.6 分组延时、丢失和吞吐量 丢失和延时是怎样发生的：分组到达链路的速率超过了链路输出的能力，排队等待需要时间，传播需要时间、排队队伍太长被丢弃。 分组延时 分类：（一个hop花费的所有时间-一跳的时间） 节点处理延时：检错、查路由表…… 排队延时：输出链路上等待传输的时间。 传输延时：将分组发送到链路上的时间= L/R。 传播延时：d/s 物理长度/速度。 用车队作类比： 过收费站：传输延时。 在路上跑：传播延时。 信道容量：广域网打出去数据在路上，容量大；局域网还没发完对方就收到了，信道容量小。 节点延时： 排队延时取决于流量强度： R=链路带宽 (bps) L=分组长度 (bits) a=分组到达队列的平均速率。 流量强度越接近1，排队延时越接近无穷大（分组会丢失）。 延时和路由：测试往返时延-RTT(Round-Trip Time) 基于ICMP(Internet Control Message Protocol)协议。IP包的头里面有很多载荷信息，包括TTL（生存时间），过一个节点TTL减一，减到0的时候把它抛掉，并且通知源主机。测试的时候把TTL设置为1，到第一个节点的时候被删除获得通知，收获往返延时。怎么知道到达目标主机？目标端口没有应用进程，目标主机发送“目标端口不可达”报文，得到发送到目标主机的往返延时。 举例，gaia.cs.umass.edu to www.eurecom.fr。发送三次测试，返回每一挑的往返时延。7到8时延极具增加，应该是因为非常远，跨国跨大洋，延时陡增。到第17以后，探针丢失，路由器不响应。 分组丢失 链路的队列缓冲区容量有限。 当分组到达一个满的队列时，该分组将会丢失。 丢失的分组可能会被前一个节点或源端系统重传，或根本不重传。——线路可靠，上节点重传；线路不可靠，源主机重传。以太网就不可靠，链路层可靠。 吞吐量 分类：瞬间-某一时间点的速率、平均-长时间的平均值 瓶颈链路：端到端路径上，限制端到端吞吐的链路。最细的部分——木桶效应。 仅有两个设备在通信时，端到端平均吞吐：， 多个设备同时使用时，端到端吞吐：，每段都取决于当时同时使用的连接数量。 12345678910graph TB A[网络性能]--&gt;B[分组延时] B--&gt;B1[处理] B--&gt;B2[排队] B--&gt;B3[传输] B--&gt;B4[传播] A--&gt;C[分组丢失] A--&gt;D[吞吐量] D--&gt;D1[瞬间] D--&gt;D2[平均] 1.7 协议层次及服务模型 互联网是一个异常复杂的大系统：人类历史上最大的人造系统之一。需要使用模块化、分层方式来设计实现。 协议层次 示例：航线系统、异地哲学家的相互交流（说不同语言）：秘书-传递、翻译-转换、哲学家-应用层。 每层实现一个或一组功能，非常明确。层之间交换PUD（协议数据单元）。 服务是功能的子集，利用自己的功能为上层提供服务。对等层实体通过协议交换信息（通过接口访问下层服务）。 实现协议要通过下层服务，协议的目的是和对等层交换信息更好地为上层服务。越往上功能越高级，越往下功能越具体。本层能向上层提供的服务包括了下面所有层能提供的所有服务加自己所增加的新的服务。 服务和服务访问点 服务Service：低层实体向上层实体提供它们之间的通信的能力。 实体分为两类：服务用户（上层）、服务提供者（下层）。提供者向用户提供服务，提供服务的位置是访问点。 服务访问点 SAP (Services Access Point) ：上层使用下层服务的层间接口点。用于区分上层用户。IP/端口…… 提供服务的形式：原语(primitive)，如socket API的各种函数，抽象成原语，是服务真正实现的形式。 服务的类型 面向连接的服务和无连接的服务（前面讲过） 面向连接：要进行握手做好准备。建立连接，通信，拆除连接。如TCP、虚电路，传大型数据。 无连接：寄信、UDP。 服务和协议 区别：服务是垂直的关系、协议是水平关系。 联系：本层协议的实现要靠下层提供的服务来实现，本层实体通过协议为上层提供更高级的服务。 数据单元(DU) SDU：服务数据单元（上层要传的数据） ICI：接口控制信息 IDU：SDU+ICI 接口数据单元 PDU：协议数据单元（本层之间要传的数据）SDU+本层控制信息。注意IDU通过接口以后舍掉ICI。 如果SDU特别大，可能会把它拆开分别加上本层头部封装成PDU；如果SDU很小也可以多个合并成一个PDU。 一对一、一对多、多对一几类情况。 不同层PDU名字不同：应用报文、报文段、分组/IP数据报、帧…… 讨论：分层的好处 每个功能独立实现、便于采用新的技术、便于交流和讨论。 层次化解决复杂问题：把任务拆分为不同层次解决、便于引入新技术。缺点效率低。 Internet 协议栈 物理层：把数字数据转换为物理信号，在线路上传送bit，接收发来的物理信号转为数字信号。 链路层：相邻两点之间传输以帧为单位的数据。PPP, 802.11(wifi), Ethernet。 网络层：传输以分组为单位的源主机到目的主机端到端的传输。（转发、路由）IP 传输层：作进程到进程的区分，把不可靠变为可靠。以报文段为单位。TCP, UDP 应用层：实现各种各样的网络服务。FTP, SMTP, HTTP,DNS ISO/OSI 参考模型 和TCP/IP架构模型的区别：多了表示层、会话层。表示转换、会话管理。 互联网协议栈如果需要的话由应用层自己实现。 封装和解封装 “直接通信”是抽象的，并不是真正直接传过去的，通过底层才能实现。 交换机只涉及链路层、物理层（两层）。路由器涉及网络层、链路层、物理层（三层）。 封装：层层加头部信息；解封装：层次去掉头部信息还原原始PDU。 各层次的协议数据单元 应用层：报文(message) 传输层：报文段(segment)：TCP段，UDP数据报 网络层：分组(packet)/数据报（如果无连接方式：数据报datagram） 数据链路层：帧(frame) 物理层：位(bit) 12345678910111213141516graph TD X[协议层次]--&gt;X1[两个例子] X--&gt;X2[层次化好处] X--&gt;X3[协议栈] X3--&gt;X3-1[Internet] X3--&gt;X3-2[ISO/OSI] X--&gt;X4[协议数据单元] X4--&gt;X4-1[封装解封装] Y((区别联系)) A[服务模型]--&gt;B[定义] B--&gt;B1[用户和提供者] B--&gt;B2[原语] B--&gt;B3[服务访问点] A--&gt;C[类型] C--&gt;C1[面向连接] C--&gt;C2[无连接] 1.8 历史（了解） 1960以前 早期 线路交换网络：建立时间过长、资源独享浪费、可靠性不高。 1961-1972 分组交换 ARPAnet第一个分组交换网络。每个节点既是源、目的，也是数据交换节点。 NCP协议：相当于TCP/IP协议。同时包括传输层、网络层。 1972-1980 专用网络 专用网络和网络互联。各种各样的网络各种各样的标准协议。很难进行网络互联。 Cerf and Kahn 网络互联原则：覆盖方法。极简、自治、尽力而为（best effort）、服务模型、 无状态的路由器 、分布控制。——包容性。只需要在上层软件进行转换改变即可进行连接。 1980-1990 体系结构变化 1983: TCP/IP部署，标记日。将NCP转换为TCP/IP，将主机设备和数据交换设备区分开来。两种节点拆分。 变得非常容易部署应用，便于维护，便于使用。 smtp、DNS、ftp、TCP拥塞控制等协议的提出。 ISO-OSI标准需要重新构建、成本太高、协议太臃肿。——“赢者通吃” 1990-2000 商业化 NSFnet学术交流网络，刚开始是ARPAnet的访问网，后来独立出来。互联网的前身。 UNIX 中TCP/IP的免费捆绑；web应用在超文本（hypertext）、HTML标记语言的基础上于1994年发明-Netscape。 各种杀手级应用，不断部署新应用、扩展网络边界（打补丁）。 2005-现在 数百亿设备、移动终端、IoT（物联网）的时代、宽带接入快速便宜、高速无线接入、移动互联网、云服务。 123456graph LR A[1960前 早期]--&gt;B[1961-1972 分组交换] B--&gt;C[1972-1980 专用网络] C--&gt;D[1980-1990 体系结构变化] D--&gt;E[1990-2000 商业化] E--&gt;F[2005-现在] 1.9 小结 什么是互联网、什么是协议、边缘、核心、接入网（交换）、ISP架构、网络性能、层次结构服务模型、历史。 组成角度看：边缘、核心、协议。 服务角度看：通信服务基础设施，面向连接 无连接。 分层方式：应用层，传输层，网络层，数据链路层，物理层。报文，报文段，分组，帧，位。 应用交互方式：C/S模式 P2P模式。 数据交换：分组交换 线路交换。虚电路、数据报。 ISP层次结构 延迟的组成：处理、传输、传播、排队 分层体系结构：服务、协议、PDU、原语、服务访问点。","tags":[{"name":"计网","slug":"计网","permalink":"https://renzehua1998.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"计算机网络绪论","date":"2022-07-16T04:00:00.000Z","path":"2022/07/16/计算机网络自顶向下/绪论/","text":"计算机网络自顶向下书籍中科大B站课程笔记 绪论 课程主要内容 从网络结构的上到下 第一章 计算机网络和互联网 第二章 应用层 第三章 传输层 第四章 网络层：数据平面 第五章 网络层：应用平面 第六章 数据链路层和局域网（物理层和通信相关，合并） 第八章 网络安全（第七章不讲）部分选修 每章讲述内容 综述 每一章两部分： 原理（功能和提供的服务）功能是能力，服务是功能的体现。通过接口向上层提供服务。本层功能需要调用下层接口实现。——功能是什么、怎么实现这部分功能。 实例（当前互联网中应用最广泛的协议）http pop3 ftp tcp/udp ……对可靠性的要求（不出错不重复不丢失不失序）、对实时性的要求。 可靠性：存副本、超时重传、编号、收到确认，校验、排序——占用空间消耗时间。 实时性：速度型应用，一往一返即可，可能会出问题需要重新请求。 每层功能 应用层： 两个应用进程，分别跑在本地和服务器。为用户提供网络应用。 通过协议，不同厂商生产的应用程序、设备、网卡就可以相互交互。 传输层：tcp/udp 在网络层提供的端到端的服务基础上实现。进程到进程间的服务。对功能进行细分、加强。 把不可靠的服务变成可靠的服务。 网络层：IP 端到端：源主机--&gt;目的主机 的IP数据报。点到点P2P point to point（数据链路层），端到端E2E end to end。 “尽力而为”：对于有没有丢、是否出错、乱序？都没有保障。 数据链路层： 点到点：两个相邻主机的网卡之间传输。 以帧为单位。 在物理层最终实现：各种载波（传输实际信号：光、电）数字--&gt;模拟） 物理层： 相邻两点之间数字信号转换为模拟信号，在媒体media上最终实现。（网线、同轴电缆、光纤） media： 第0层，所有传输的最终实现。 关于网络层 网络层分为两层： 传统网络层分为两类： 传统（IP协议-根据路由表分发、路由协议-路由选择算法）——僵化、不可编程 SDN（软件定义网络）：数据平面-交换机，控制平面-网络操作系统。通过源目的IP、mac计算算流表，通过标准协议接口返回给数据平面。交换机做匹配，做的动作多样化：修改、洪泛、转发等等。——实现各种各样的网络功能：负载均衡、防火墙等等都可以集成到整个设备当中。只需要在操作系统中跑相应的网络应用。 选修课程 网络安全、无线移动网络（WLAN、5G）、多媒体应用（协议、需求）、网络管理（SMP协议等等）","tags":[{"name":"计网","slug":"计网","permalink":"https://renzehua1998.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"最优控制","date":"2022-07-05T04:00:00.000Z","path":"2022/07/05/最优控制/","text":"研一下最优控制汇报材料、往年题训练、考试小抄（A4） 考试小抄 往年题 2020 原题 2021 原题 课堂汇报 project：报告","tags":[{"name":"算法","slug":"算法","permalink":"https://renzehua1998.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Python","slug":"Python","permalink":"https://renzehua1998.github.io/tags/Python/"},{"name":"控制","slug":"控制","permalink":"https://renzehua1998.github.io/tags/%E6%8E%A7%E5%88%B6/"},{"name":"matlab","slug":"matlab","permalink":"https://renzehua1998.github.io/tags/matlab/"},{"name":"优化","slug":"优化","permalink":"https://renzehua1998.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"GAC：基于图的警报相关性检测分布式多步攻击","date":"2022-06-18T04:00:00.000Z","path":"2022/06/18/GAC：基于图的警报相关性检测分布式多步攻击/","text":"SIGAPP 2018 基于图的警报相关性检测分布式多步攻击 GAC：基于图的警报相关性检测分布式多步攻击 ——by Zehua Ren ACM2018 SIGAPP SAC '18: Proceedings of the 33rd Annual ACM Symposium on Applied Computing ACM2019 SIGAPP APPLIED COMPUTING REVIEW [toc] 概述 问题：大多数传统的 IDS 在关联具有不同来源的警报方面存在不足，因此许多分布式攻击仍然完全未被注意到。 贡献：提出了基于图的警报关联 (GAC)，这是一种新颖的关联算法，可以隔离攻击、识别攻击场景并从庞大的警报集中组装多阶段攻击。 优势：对误报具有鲁棒性，可以检测分布式攻击，并且随着警报数量的增加而扩展。 GAC算法简述 ——基于图的警报关联算法 通过将警报相互关联以获得更大的攻击图来简化IDS监测任务。常见的方法是根据相似的属性对警报进行分组，例如源 IP 和目标 IP，并报告常见的属性模式。 方法：GAC，一种新颖的基于图形的警报相关方法，可用于检测通用（分布式）攻击，例如 DDoS、端口扫描和蠕虫传播。（三个流程） 根据特定警报属性之间的相似性对警报进行聚类（每个集群都包含可能属同一攻击或单个攻击步骤的所有警报——原子模式）； 识别每个集群内主机之间的通信模式（一对一、一对多……——拓扑特征）； 当输入警报集中存在多步攻击时，单个攻击步骤的集群会根据集群内的通信模式相互连接（——分子模式）。 警报仅包含源和目标 IP 地址以及端口号。这降低了警报关联的复杂性并增加了对不同传感器的兼容性。额外的知识是从警报本身中挖掘出来的。 有效的功能：分离警报（准确性良好）——识别警报集群（考虑不确定性）。 75% 的集群，GAC 能以 ≥ 90% 的高确定性识别它们各自的场景 其他相关工作 告警关联大致分为三类：以集群为中心、以互连为中心、以流程为中心 以集群为中心：聚合属于同一攻击的警报 以互连为中心：主要检测多步攻击。关联的重点是不同攻击步骤的警报之间的互连。 以流程为中心：所有三个流程块都用于警报关联。算法包括用于单步和多步检测的复杂技术。 没有任何以流程为中心的相关工作，在无额外知识的情况下从集群中挖掘特征。 期刊中的相关工作对比表格： 基于图形的警报关联算法（GAC） 符号说明 告警 由一个固定的属性向量 组成，例如源和目标地址以及源和目标端口。 攻击 引发一组真正的积极警报 ，所有诱导警报集的集合由，，， 给出。 多步攻击$ j 将产生一个子集 M_j ⊆ S$。所有多步攻击的集合是 。 警报关联的任务是分析警报集 ，并根据单步和多步攻击 和 对其警报进行分组，而无需了解基本事实。 GAC步骤总述（3步） 如上所述，三步：警报聚类、上下文补充和攻击互联。 警报聚类：将警报聚类到相应的警报群集 。——子图划分 首先将警报集 A 转换为反映警报之间属性相似性的**告警相似度图$ G_{attr}。之后应用基于图的聚类算法将所有警报聚类到子集中，作为攻击步骤的候选。用C逼近S$，其中分两步 警报过滤：识别警报中的重复项和误报 攻击提取：聚类属于同一攻击的警报 上下文补充：为每个集群分配一个标签 来补充每个攻击步骤的附加含义。——标定 每个告警集群转换为一个告警流图 并不使用预定义知识（专家经验等），而是直接从警报信息和警报集群中挖掘特征。描述了每个集群内攻击者和受害者之间的恶意通信关系，以识别攻击场景。 攻击互联：将$ C 中表示单步攻击步骤的集群相互连接到多步攻击 M$。——关联 所有具有相应标签 的集群 $C_i 转换为单个攻击相似度图G_{cover}$**，以搜索集群之间的重叠 IP 地址。 对于任何两个共享 IP 地址的集群，标签 用于派生标签 描述多步攻击的类型。 期刊中的整体流程示例图： 第一步：告警聚类 将警报表示为图中的节点，并在相似警报之间添加边。——和超图很像 这就能够搜索具有相似属性的警报，然后在这些图中对警报进行聚类。 将告警建模为图 将警报集转换为加权警报相似度图 ，其中警报作为节点。在两个警报 $a_1, a_2 ∈ A 之间的边 (a_1, a_2) ∈ E使用相似度s = F_{sim} (a_1, a_2) ∈ [0, 1] $加权。 比较所有 $n 个属性 (a_0...a_{n −1})$ 。如下： 特定属性的比较函数 $h_j 得到一个[0,1]的值，c_j为权值。两个警报的相似度等于或高于最小相似度阈值 τ$才算边。为了选择合适的阈值 τ ，可以计算攻击警报之间的预期相似度。 只考虑IP、端口，此处选用最简单的相同不同，均分。 在图上对告警进行聚类 无关告警之间也可能有边，所以需要即识别 中的子图——社群发现 作者使用CPM算法（Clique Percolation Method派系过滤），它允许将一个节点分配给多个社区，可以反映聚类中的不确定性。 该算法认为社区是具有共享节点的全连通子图集合，并通过一种团过滤算法来识别网络中的社区结构。算法首先搜索所有具有k个节点的完全子图，而后建立以k-clique为节点的新图，在该图中如果两个k-clique有(k-1)个公共节点则在新图中为代表他们的节点间建立一条边。最终在新图中，每个连通子图即为一个社团。百度百科 第二步：上下文补充 这一步目标是描述每个集群的攻击场景。 中节点相互连接良好。因此，这种图结构不适合识别攻击场景。对识别出的集群 ，建立一个不太密集的警报流图 ，节点 是集群 中所有源和目标 IP 地址的集合。如果存在警报 ，源节点 作为攻击 IP，目的点 作为目标 IP，则图中两个节点 之间存在边 。边的方向表明谁攻击了谁。 使用 中的节点度数识别攻击场景。在分布式攻击场景和多步攻击中，节点可以同时成为攻击者和受害者，即考虑有向带环图和攻击链。给出了四种攻击场景： 一对一（OtO）：其他场景的特例。 一对多（OtM）：例如扫描子网。特征是相同的攻击源 IP。 多对一（MtO）：例如 DDoS 攻击。攻击特定服务时，所有相关警报可能具有相同的目标 IP 和端口。 多对多（MtM）：例如蠕虫传播。由于蠕虫通过特定应用程序进行传播，因此警报将有相同的目标端口。 设置了四个指标$ δ_{OtO}、δ_{OtM}、δ_{MtO}、δ_{MtM}$ 值在 区间，分别表示与这四种类型的匹配程度，1为完全匹配，0为完全不匹配。各个场景完全匹配（）或仅部分匹配（）之间存在线性关系。 所有节点个数，攻击（源）节点个数，受害（目的）节点个数。 最终根据确定最大相似（最匹配的标签） 第三步：攻击互联 由第一步生成的两个警报集群 ，近似真实单步攻击（原子模式），，进而关联出多步攻击 。所有识别出的集群 都被转换成一个有向标记图，我们称之为攻击相似度图 。如果两个集群属于同一个多步攻击，则 中存在一条边 。 两个集群 的标签 为攻击者和目标派生标签 Many 或 One 例如，当集群标记为 OtM 时，攻击 IP 集标记为 One，目标 IP 集标记为 Many。 比较来自两个集群的攻击者集 (simAA)、来自两个集群的目标集 (simTT)、Ci 的攻击者集与 Cj 的目标集 (simAT) 以及 Cj 的攻击者集使用 Ci (simTA) 的目标集。共四个相似度定义。 同种标签（都为One或都为Many）使用Jaccard系数 不同标签（一个One一个Many）使用重叠系数，X 是标记为 One 的集合，Y 是标记为 Many 的集合。 取其最大值 。如果 sim 超过预定义的阈值，则将带有标签 sim 的边 添加到 。遍历所有告警集合建立攻击关联图——多步告警识别。 实验简述 人工生成的有ground truth数据 ——生成输入以分析算法设计的有效性，由于是做告警关联而不是入侵检测，所以此方法是有效的。 根据表一生成告警数据：对于同一攻击的所有警报，哪些 IP 和端口是相同的，哪些可能不同并且可以随机确定。使用完整的 IP（0.0.0.0 到 255.255.255.255）和端口范围（0 到 65535） 在水平扫描 (OtM) 中，一个源针对同一目标端口上的多个主机。在 DDoS 攻击 (MtO) 中，多个源针对来自任意源端口的相同 IP 和端口组合。在蠕虫 (MtM) 传播中，每个主机以固定目标端口上的其他主机子集为目标。 通过IP映射合并多个系统，通过模糊参数 模糊警报数据，生成误报和孤立告警。添加了 个新主机和 个新警报 相似度图中警报聚类性能评估 对于告警相似度图，选择（由表1知这是保持关联的最小值），研究了决定最小社区规模的集团规模参数 k：k 不应大于来自最小攻击的警报数，即 。 我们将自己的方法与一种类似的方法进行比较，我们称之为面向属性的归纳 (AoI)。AoI 是一种在一组警报中查找属性模式以建立最小大小为 k 的集群的有效算法，类似于采用社区聚类并形成至少大小为 k 的集团的 GAC。 Klaus Julisch. 2003. Clustering intrusion detection alarms to support root cause analysis. ACM Transactions on Information and System Security (TISSEC) (2003). 评价指标：标准度量准确度 告警过滤：ground truth detected attacks准确性用于评估 DA 建模 GT 的性能。（使用） 攻击检测：准确性评估 C 建模 S 的性能。将比较分解为单独的 C 和 S 对，找出哪个原始攻击 Ci ∈ C 模型最能提醒集群 Sj ∈ S。为每个可能的组合计算准确度 ACC，并在每个攻击和集群只能映射一次的约束下推导出 Ci ∈ C 和 Sj ∈ S 之间的映射。使用贪心算法，最多只有一个未映射，定义它的相似度为0。总准确度分别是所有映射和未映射攻击或集群的平均准确度。 来自单一攻击的警报集群： 社区聚类的优势在于，即使 k 远低于最小攻击，它也可能有效。但是，k 必须足够高以过滤噪声并拆分松散耦合攻击的警报。 来自重叠攻击的警报集群： （1）GAC 比 AoI 实现了更高的准确度，（2）聚类参数 k 允许在很宽的参数范围内实现这些高精度。 警报流图上的场景识别 在人为创建的攻击的基础上评估攻击场景识别的鲁棒性，在这些攻击上我们应用模糊来模拟聚类中的误报。 GAC 中的场景识别可以完全容忍误报，即在一定程度上仍能达到 100% 的准确率。时，可以达到真阳性100%，假阳性0%。 用随机的 β ∈ [0, 1] 模糊这三种攻击，并用不同的 β 重复 10000 次。在所有重复中，平均准确率（即正确分类的比例）为 80%。 即使在最坏的情况下，大多数攻击也可以正确分类。此外，仅在具有高度不确定性的情况下才会出现误报。 真实告警数据 DShield数据集：SANS 互联网风暴中心在全球范围内运行一个基于社区的协作式互联网威胁监控系统。收集来自各种贡献者的网络事件日志，即警报。 DShield 中的每个警报都包含源和目标的 IP 和端口等。目的IP信息经过hash。 警报关联算法在有限的警报集上执行，而不是在警报流上执行。因此，我们将 24 小时的数据集分成多个块，每个块都是 GAC 单独处理的单独输入。每个块包含约5000个报警。 2 × 8 2.2 GHz 内核和 128 GB RAM 的系统上并行使用 16 个进程。使用此设置，每个块的处理平均需要 1 到 1.5 分钟。——太慢，太复杂。 参数配置：，。 过滤效果 结果：未分配告警比例很低，因为分布式攻击的性质会导致大量警报，而像高级持续威胁 (APT) 这样的有针对性的攻击只会导致很少的警报。集群数量和标准差很大，说明集群很多且相差各异。 场景识别 确定性因子 大多数值预计在 1 和 0.75 之间。这使得识别具有很高的可信度。很少检测出多对多的蠕虫，可能是因为IP被hash的缘故。 多步攻击 在几乎所有情况下，集群间的相似性都是 1 或 &lt; 0.5。任何两个簇的相似度都很少≥ 0.5 且 &lt; 1 总结 GAC，一种警报关联算法，它通过基于图的方法实现了三个构建块警报聚类、上下文补充和攻击互连。社区聚类参数 k 适用于广泛的值，特别是对于来自分布式攻击的聚类警报。分布式多步攻击方面，优于 Julisch提出的高效且强大的关联算法 Attribute-oriented Induction（AoI面向属性归纳法）。 真实攻击的互连仅产生主机之间具有高度相似性的对的一小部分。两次攻击之间的大多数相似性都很低，因此很可能表明攻击不相关。 未来计划为聚类参数 k 开发（半）自动化方法。研究如何实现不同 GAC 实例输出的相关性（不同切片的相关），适用于协作和高度分布式 IDS 中的警报关联。","tags":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://renzehua1998.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"论文阅读","slug":"论文阅读","permalink":"https://renzehua1998.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}]},{"title":"SHADEWATCHER","date":"2022-06-02T04:00:00.000Z","path":"2022/06/02/SHADEWATCHER/","text":"S&amp;P 2022 SHADEWATCHER: 使用系统审计记录的建议指导的网络威胁分析 SHADEWATCHER: 使用系统审计记录的建议指导的网络威胁分析 ——by Zehua Ren （待更新） S&amp;P 2022 CCF A [toc] 概述 网络安全中的威胁检测与信息检索中的推荐之间的结构相似性。通过将系统-实体交互的安全概念映射到用户-项目交互的推荐概念，通过预测系统实体对其交互实体的偏好来识别网络威胁。 开发了自动检测系统 SHADEWATCHER。它通过图神经网络检测审计记录中高阶信息，能够在几秒钟内查明来自近百万个系统实体交互的威胁。 Data provenance techniques：数据出处技术，以通过描述系统执行历史的出处图导航审计记录。来源数据中丰富的上下文使分析师能够对系统活动进行因果分析，以检测入侵、跟踪依赖关系和安全事件的原因。 现有检测系统 基于出处的检测器分为三类： 基于统计的检测：通过稀有性量化审计记录的可疑程度 基于规范的检测：已知攻击模式知识库匹配 基于学习的检测：对良性行为进行建模并检测与它们的偏差 主要问题： 1）大量假告警 2）依赖专家知识 3）检测信号不准确 基于统计的检测容易产生大量错误警报，统计分析只考虑出处图中的直接（因果）联系，而不是系统实体之间的微妙（语义）关系。 基于规范的检测可以通过将攻击语义定义为安全策略来保持较低的误报率，但这种启发式方法的开发既耗时又容易出错。 基于学习的检测旨在将审计记录的因果关系和语义全面纳入威胁分析。尽管检测精度很高，但当前的学习方法会产生粗粒度级别的检测信号。 研究动机 威胁行为者通常会通过分析人员认为可疑的意外系统实体交互来引发不需要的行为。可以通过确定系统实体与另一个实体交互的可能性来揭示网络威胁。这种交互的可能性可以通过利用起源图中的因果连通性来估计。这种连接性并没有捕捉到系统实体背后隐藏的语义意义：隐藏内因。 推荐系统用户和项目之间的直接连接，称为一阶连接，不足以比较不同项目之间的语义相似性。研究人员进一步考虑了项目的辅助信息捕获项目语义。其核心是辅助信息可以形成高阶连接，以链接在用户-项目交互中断开的相似项目。 我们的目标是结合系统实体的辅助信息来全面解释它们的交互。系统实体的语义可以从使用它们的上下文中揭示出来，我们利用上下文信息作为基础辅助信息来分析系统实体。此后，尽管在因果分析中被认为不相关，但具有相似上下文的系统实体将在语义上相关。 语义相似的系统实体会表现出相似的交互偏好。例如，敏感文件（例如 /etc/passwd 和 /etc/shadow）通常不与公共网络交互，否则表明数据泄露 。——威胁检测可以进一步指定为预测系统实体不“偏爱”其交互实体的可能性。与研究用户偏好的典型推荐场景相比，威胁检测针对系统实体不太喜欢的交互，因为此类交互通常是强攻击指标。 使用的方法 介绍了 SHADEWATCHER，这是第一个通过对系统实体交互的建议来分析网络威胁的系统。 SHADEWATCHER 使用上下文感知嵌入模型提取系统实体的辅助信息，该模型通过实体在运行系统中的使用来展开实体的语义。为了揭示系统实体的交互意图，SHADEWATCHER 采用了基于图神经网络的推荐模型，该模型通过递归地传播来自相邻实体的信息来利用高阶连通性。此外，SHADEWATCHER 会根据分析师对检测信号（即潜在的恶意交互）的反馈动态更新其模型。这允许 SHADEWATCHER 将错误推荐整合为额外的监督，以提高其检测能力。作为一种半监督方法，SHADEWATCHER 接受了未标记的良性系统实体交互与标记的分析师对错误警报的反馈相结合的训练。 方法优点(针对上述三种缺点)： SHADEWATCHER 不是将历史频率作为衡量怀疑程度的指标，而是推断系统实体的内在语义以发现异常交互； SHADEWATCHER 提供端到端的解决方案来检测威胁，而无需事先了解攻击； SHADEWATCHER 产生细粒度的检测信号，突出攻击的关键指标。 SHADEWATCHER 有效区分良性和恶意系统实体交互，并以高精度和召回率检测网络威胁。证明了 SHADEWATCHER 的效率足以扩展到企业环境。","tags":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://renzehua1998.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"论文阅读","slug":"论文阅读","permalink":"https://renzehua1998.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}]},{"title":"IDS数据集调研论文","date":"2022-06-01T04:00:00.000Z","path":"2022/06/01/IDS数据集调研论文/","text":"基于网络的入侵检测数据集综述 基于网络的入侵检测数据集综述（A survey of network-based intrusion detection data sets ） ——by Zehua Ren 2019 Computers &amp; Security CCF B 参考CSDN帖子：文献翻译 作者团队建立的网站：数据集存储网站(需要代理) [TOC] 概述 本文确定了 15 种不同的属性来评估单个数据集对特定评估场景的适用性。这些属性涵盖了广泛的标准，并分为五个类别，例如数据量或记录环境，以提供结构化搜索。基于这些属性，给出了现有数据集的全面概述。该概述还强调了每个数据集的特点。 本文是一个详尽的文献综述，基于网络的数据集和分析，哪些数据集满足哪些数据集属性。本文重点研究了数据集内的攻击场景，并强调了数据集之间的关系。 数据采集分类 通常，以基于数据包或基于数据流的格式捕获网络流量。捕获数据包级别的网络流量通常通过镜像网络设备上的端口来完成。基于数据包的数据包含完整的有效载荷信息。基于流的数据更聚合，通常只包含来自网络连接的元数据。 ——我们S6000系统的数据大部分是基于数据流量的，包含了源、目的、端口、协议等信息，无载荷信息。仅有少部分包含了有效载荷，这可能与使用的不同IDS设备有关。 少部分包含 基于数据包的方式 通常以pcap格式捕获，并包含有效负载。 主要协议：TCP, UDP, ICMP和IP 基于数据流的方式 主要包含关于网络连接的元信息，无负载信息。 定义五元组：源IP地址、源端口、目的IP地址、目的端口和传输协议。 完整属性：1 首次出现日期 2 持续时间 3 传输协议 4 源 IP 地址 5 源端口 6 目标 IP 地址 7 目标端口 8 传输字节数 9 传输数据包数 10 TCP 标志 ——分为单向流和双向流，我们的数据属于双向流，包含方向。但是没有每秒字节数、每个数据包的字节数、第一个数据包的 TCP 标志、有效负载熵等信息，需要在全流量里面才能看到。 其他方式获得的数据 主机的日志文件、配置信息、登录记录等等。典型的是KDD CUP 1999。这一类别的每个数据集都有自己的一组属性。 ——这种场景和我们下一步要做的比较像，加入配置日志信息后的全面分析，也更复杂。目前研究告警聚类划分暂时用不到。 数据集属性 一般概念：FAIR定义了学术数据应该实现的四个原则，即可发现性、可访问性、互操作性和可重用性。不同的数据集强调不同的属性，本文试图统一和概括文献中使用的属性。 文章将讨论的数据集属性分为五类 1. 一般信息 创建年份、公开可用性、正常用户行为、攻击流量。 正常用户行为的存在对于评估IDS是必不可少的。然而，正常用户行为的缺失并不意味着数据集不可用，而是表明它必须与其他数据集或现实世界的网络流量合并。这样的合并步骤通常称为叠加或撒盐 对于我们来说这几个属性都很重要，尽量选年份近一些的更贴近现实，保证可用。最重要的是有明确标注正常行为和攻击行为的ground truth。 2. 数据性质 元数据、格式、匿名性 这些也需要纳入考虑，选择符合我们研究场景的，或者其他场景可用测试算法可用性的。 3. 数据量 数据集大小、持续时间（应当较长以获取周期性特征） 大部分数据集都可以满足，需要考虑数据集规模，有时候需要按需求截断使用。 4. 记录环境 流量种类（真实的、模拟的或合成的）、网络类型（局域网、广域网）、网络完整性（是否包含来自一个包含多个主机、路由器等的网络环境的完整网络流量） 需要根据实际情况进行选择，最好是真实或者模拟数据，包含完整的网络流量。 5. 评估 预定义子集（是否带有用于训练和评估的预定义子集）、均衡性（数据集相对于它们的类标签是否平衡）、有无标签（yes有, yes with BG. -yes with background有但有噪声,yes (IDS)IDS生成的, indirect不一定有, and no没有） 数据集 数据集属性 Labeled-有无标签 和 Format-格式 是最具决定性的属性。 初步筛选预计可用数据集（部分之前调研过，部分待调研） 这些数据集主要包含攻击类型：DoS、端口扫描（ping-scan、SYN-Scan、Nmap 执行）、SSH 暴力破解、漏洞利用、模糊测试、通用、侦察、shellcode、垃圾邮件、蠕虫等等，包含各个方面 一些数据集的派生关系 其他数据源 作者还给了其他在线数据仓库和流量生成器，有待进一步研究，此处暂略 评估建议 一些关于选择更好数据集的建议（建议阅读原文）","tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://renzehua1998.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}]},{"title":"告警聚类与超图分析系列研究调研总览","date":"2022-05-12T04:00:00.000Z","path":"2022/05/12/readme/","text":"告警聚类与超图分析系列研究调研总览 标*的是不确定好坏或不知名期刊会议 1 ACSAC 2001 B类 276引用 K. Julisch, \"Mining alarm clusters to improve alarm handling efficiency,\" Seventeenth Annual Computer Security Applications Conference, 2001, pp. 12-21, doi: 10.1109/ACSAC.2001.991517. 之前组会讲过的一篇，很有参考价值 目前找到最早的关于告警数据聚类的论文，偏综述性质。阐述了入侵检测系统每天会触发数千个警报，从而使操作人员超负荷工作的问题。提出将警报聚类作为一种发现根本原因的方法，论述了90% 的警报可以归因于少数根本原因。证明了一般报警聚类问题是NP完全的，提出了一种近似算法：层次聚类法。 2 S&amp;P 2002 A类 1146引用 （网安四大顶会之一） Cuppens F, Miege A. Alert correlation in a cooperative intrusion detection framework[C]//Proceedings 2002 IEEE symposium on security and privacy. IEEE, 2002: 202-215. 需要继续精度 介绍了作者在 MIRADOR 项目中为设计 CRIM（入侵检测系统 (IDS) 的协作模块）所做的工作。该模块实现了管理、集群、合并和关联警报的功能。聚类和合并功能识别与同一攻击事件相对应的警报，并创建一个新警报以合并这些不同警报中包含的数据。实验表明，这些功能显着减少了警报的数量。但是也发现到获得的警报仍然过于初级，无法由安全管理员管理。因此，相关函数的目的是生成全局和综合警报。 使用相关性对告警进行了初步归并，基于显式相关（安全人员提供）、隐式相关（统计规则）。使用LAMBDA语言对告警进行了关联分析，给出了告警的归并结果。同时进行了溯因分析的探索，但仅仅针对实验中的特定场景。 3 *疑似TOIS 2003 A类? 668引用 ACM Transactions on Information and System Security Klaus Julisch. 2003. Clustering intrusion detection alarms to support root cause analysis. ACM Trans. Inf. Syst. Secur. 6, 4 (November 2003), 443–471. https://doi.org/10.1145/950191.950192 第一篇作者两年后的另一篇，仍是基于层次聚类的告警根本原因识别。提出了一种新颖的警报聚类方法，该方法支持人类分析师识别根本原因，将相似告警归并为广义告警。此方法可以帮助减少87%的误报，大约每月需要进行一次根本原因的识别和删除。 明确了告警集群（即我们所说的告警簇）的概念：给定集群的所有警报共享相同的根本原因。但是对于确切的警报聚类问题没有给出算法解决方案。作者认为，根本原因是一个模型世界概念，它只存在于我们思维的世界中。计算机程序不知道根本原因，因此不能强制要求警报集群的所有警报必须共享相同的根本原因。 作者给出了对于根本原因聚类的近似：具有这些结构特性的警报簇最有可能是根本原因的结果。作者总结了九种可能的根本原因，属于人工手动设置规则，没有实现自动化。 下面是文中设定的九种根本原因： 4 *IASTED PDCS 2005 8引用 Bellec J H, Kechadi M T, Carthy J. A New Efficient Clustering Algorithm for Network Alarm Analysis[C]//IASTED PDCS. 2005: 638-643. 本文提出了一种通过根据警报的类型和周期性对计算机网络警报进行聚类来识别故障的通用算法。 本文考虑了时间周期属性。假设发生故障时，会周期性地触发一些警报，直到故障解决。这是用于触发警报的最常用策略。 作者介绍了分析周期性的三种经典方法： 滑动窗口：一个段不断增长，直到超过某个错误界限。该过程对新近似段中未包括的下一个数据点重复。 证明了滑动窗口算法复杂度为O(L.n)， 自上而下：递归地划分时间序列，直到满足某些停止条件。 自下而上：从两个元素的对开始，合并分段，直到满足某些停止条件。 提出了一种新方法：分数匹配（S-M）。这种方法的想法是测量两个连续警报之间的时间间隔，定期重新创建虚拟警报，然后在用户指定的时间评估虚拟警报和真实警报之间的匹配度。最高分确定最合理的警报组。我们可以最大化每个集合的大小并确认它们的周期性。该算法的复杂度为 O(n(n-L))。 本文考虑了告警的时间属性，不再局限于空间关联分析，通过对周期性的分析对海量告警进行了聚类。 5 EAAI 2006 C类 160引用 Giacinto G , Perdisci R , Roli F . Alarm Clustering for Intrusion Detection Systems in Computer Networks[C]// Machine Learning and Data Mining in Pattern Recognition; Lecture Notes in Artificial Intelligence; 3587. Department of Electrical and Electronic Engineering, University of Cagliari, Piazza D Armi - 09123 Cagliari, Italy, 2005. (另一版引用信息) 本文提出了一种执行警报聚类的新策略，该策略从多个 IDS 产生的警报中生成对攻击的统一描述。为了有效，所提出的警报集群系统考虑了 IDS 的两个特征：（i）对于给定的攻击，不同的传感器可能会产生许多警报，报告不同的攻击描述； (ii) IDS 可以针对不同类型的攻击生成某种攻击描述。告警集群模块产生的高级别告警有效地概括了攻击，大大减少了向管理员呈现的告警量。此外，这些高级别的警报可以作为基础来进行更高级的威胁分析。 一篇关于多源IDS信息融合的论文。同样引入元告警(Meta Alarm)的概念：由于某种攻击而产生的基本告警，将它们融合产生更高级别的告警消息，称为元告警。 所提出的系统由三个主要模块组成，即警报管理接口（AMI）、警报分类器和警报集群模块。 AMI 接收来自多个 IDS 的警报并将其转换为标准格式。然后，告警分类器为接收到的告警分配一个类标签，并将它们发送到告警聚类模块，在告警聚类模块中融合告警得到元告警。 考虑以下三种攻击类别： (i) portscan； (ii) webscan； (iii) 拒绝服务 (DoS)。端口扫描攻击通常通过向不同端口发送大量 TCP 或 UDP 数据包来执行，以发现服务是否绑定到某个端口。以类似的方式，通过向寻找易受攻击的 Web 应用程序的 Web 服务器（受害者）发送一系列 HTTP 查询来执行 Webscan 攻击。相反，DoS 攻击通常是通过向受害主机发送大量精心设计的数据包来尝试利用可能导致受害主机或应用程序崩溃的漏洞。 每个元警报进一步由唯一标识事件所需的许多特征来描述，例如攻击的开始和停止时间、源和目标 IP 地址、源和目标 TCP/UDP 端口等。此外，标识符报告汇总的警报日志以允许进一步检查。所提出的系统结果特别适合于聚合由那些导致 IDS 产生大量警报的攻击所产生的警报。 通过定义特征对距离、告警与元告警距离、告警与元告警相关性、告警与许多元告警距离的方法对告警进行了聚类。 本论文主要对端口扫描、网络扫描和DoS的元告警进行了分析，给出了识别这三种告警的方法。 6 *ICNSM 2010 疑似C类? 74引用 Vaarandi R, Podiņš K. Network ids alert classification with frequent itemset mining and data clustering[C]//2010 International Conference on Network and Service Management. IEEE, 2010: 451-456. 提出了一种基于频繁项集挖掘和数据聚类技术的新型无监督实时警报分类方法。方法完全自动化了知识解释和警报过滤规则构建的过程。此外，由于其无监督和自动化的性质，该方法不需要人工标记的训练数据，并且能够在没有人工干预的情况下适应环境变化。 首先将频繁项集挖掘算法应用于过去的 IDS 警报日志，以便发现描述冗余警报的模式。 之后，数据聚类技术用于为每个检测到的模式寻找细粒度的子模式。 最后，将检测到的知识解释并用于IDS警报的实时分类，以区分重要警报和不相关警报。定期重复挖掘和解释步骤以使分类知识保持最新，因此该方法能够在无需人工干预的情况下适应环境变化。 此论文使用频繁模式挖掘的方法对告警进行了无监督聚类，但是存在可解释性差、以相关代替因果等问题。 7 *IEEE Transactions on Smart Grid 2015 36引用 Yamaguchi Y, Ogawa A, Takeda A, et al. Cyber security analysis of power networks by hypergraph cut algorithms[J]. IEEE Transactions on Smart Grid, 2015, 6(5): 2189-2199. 通过超图上的最小切割问题来分析电力网络对某种不可检测的攻击（称为虚假数据注入攻击）的脆弱性，提出了一种使用超图进行网络安全分析的新方法，超图的观点使得直接找到稀疏攻击成为可能。 提出了一种通过枚举超图中的小割来枚举稀疏初等攻击的算法。 主要有以下两种方法 一是计算指定弧或节点的安全指数 二是寻找全网最稀疏的攻击。 这是找到的比较早使用超图分析网络安全性的论文。通过超图拓扑性质进行脆弱性分析，对我们的态势感知具有一定的参考价值。 8 KBS 2017 C类 173引用 Raman M R G, Somu N, Kirthivasan K, et al. An efficient intrusion detection system based on hypergraph-Genetic algorithm for parameter optimization and feature selection in support vector machine[J]. Knowledge-Based Systems, 2017, 134: 1-12. 本文提出了一种自适应且稳健的入侵检测技术，该技术使用基于超图的遗传算法 (HG-GA) 进行支持向量机 (SVM) 中的参数设置和特征选择。用在IDS系统开发中，将流量数据建模为超图，使用算法对入侵数据集进行IDS检测。HG – G A 被发现在图像处理、信任管理、元数据质量分析、股票市场分析等广泛的数据分析问题上具有可扩展性、自适应性、鲁棒性和适用性。 使用超图开发IDS系统，数据为流量，但分析方法可以为我们借鉴。 9 Neural Netrworks 2017 B类 83引用 Raman M R G, Somu N, Kirthivasan K, et al. A hypergraph and arithmetic residue-based probabilistic neural network for classification in intrusion detection systems[J]. Neural Networks, 2017, 92: 89-97. 本文提出了一种基于超图的 Helly 属性和基于算术残差的概率神经网络 (HG AR-PNN) 的新方法来解决 IDS 中的分类问题。利用 Hypergraph 的 Helly 特性来识别最优特征子集，并利用最优特征子集的算术残差来训练 PNN。实验结果证明了 HG AR-PNN 分类器在稳定性和提高检测率方面优于现有分类器对不太频繁的攻击。 提出了IDS检测的性能指标：模型稳定性、不太频繁攻击的检测率等，可以作为我们使用超图对IDS数据进行分析的指标参考。 10 *Procedia Computer Science 2017 16引用 Li H, Wang Y, Cao Y. Searching forward complete attack graph generation algorithm based on hypergraph partitioning[J]. Procedia Computer Science, 2017, 107: 27-38. 攻击图是一种有效的网络脆弱性分析方法，现有的攻击图方法不能满足大规模复杂网络动态分析的要求。本文提出了一种基于超图划分的搜索前向完全攻击图生成算法。 首先，通过超图划分保证各个计算代理的负载均衡； 第二，总结各种新的攻击模板； 第三，提出漏洞利用假设，提高攻击图生成效率，动态减少攻击图生成的重计算工作； 最后，提出从漏洞到攻击者反向生成攻击图的新思路，保证漏洞分析的完整性，减少额外的存储内存和计算资源 攻击图是现有网络漏洞分析方法中最流行、最有效的方法。从攻击者的角度来看，攻击图在综合分析网络配置和漏洞信息的基础上，列举出所有可能的攻击路径，帮助防御者直观地了解目标网络中的漏洞关系以及漏洞与网络安全配置的关系 基于漏洞利用假设通过前向搜索算法计算从扩展节点到攻击者的攻击图，改变了传统的从攻击者到扩展节点计算攻击图的想法，不需要额外的资源将攻击者的状态存储在网络节点上，提高生成攻击图的效率。 这篇文章是通过超图进行攻击图建模分析，这也是超图模型的有用之处，可以作为后续漏洞威胁检测方案的参考。 11 Computers &amp; Security 2018 B类 36引用 De Alvarenga S C, Barbon Jr S, Miani R S, et al. Process mining and hierarchical clustering to help intrusion alert visualization[J]. Computers &amp; Security, 2018, 73: 474-491. 提出了一种方法来促进对大量入侵警报的调查。该方法将过程挖掘技术应用于警报，以提取有关攻击者行为和他们采用的多阶段攻击策略的信息。这些策略以友好的高级视觉模型呈现给网络管理员。使用层次聚类技术将难以理解的大型且视觉复杂的模型聚类为更小、更简单且直观的模型。 基于加权有向图模型中的攻击策略，该模型结合了视觉特征和定量测量，可以帮助网络管理员识别多阶段攻击的步骤以及对网络的攻击频率。 论文1，3方法的延续，层次聚类技术对IDS告警的归并，同时提出了对大量IDS数据的可视化方法。 12 *EURASIP 2017 31引用 An, X., Su, J., Lü, X., &amp; Lin, F. (2018). Hypergraph clustering model-based association analysis of DDOS attacks in fog computing intrusion detection system. EURASIP Journal on Wireless Communications and Networking, 2018(1), 1-9. 雾计算入侵检测系统中基于超图聚类模型的DDOS攻击关联分析。提出了一种基于 Apriori 算法的超图聚类模型。该模型可以有效地描述遭受 DDoS 威胁的雾节点之间的关联。 在雾计算网络中使用超图模型识别DDoS攻击，比较具体，方法具有一点参考。 13 IEEE International Conference on Big Data 2019 C类 2引用 T. Wang, C. Zhang, Z. Lu, D. Du and Y. Han, \"Identifying Truly Suspicious Events and False Alarms Based on Alert Graph,\" 2019 IEEE International Conference on Big Data (Big Data), 2019, pp. 5929-5936, doi: 10.1109/BigData47090.2019.9006555. 使用图做事件识别和误报识别 提出了一种使用梯度提升树模型进行误报识别的有效模型。 首先，通过构建基于 IP 地址的关联警报图，从聚合和关联分析警报。 其次，设计了一种新的双向递归特征消除方法，结合随机森林进行特征选择。 最后，在方法中使用集成方法从提升树模型中得到更好的改进。 告警图模型对IDS告警进行分析，使用了简单的集成方法，与我们前期做得很类似。 14 FGCS 2021 C类 8引用 Jagtap S S, VS S S, Subramaniyaswamy V. A hypergraph based Kohonen map for detecting intrusions over cyber–physical systems traffic[J]. Future Generation Computer Systems, 2021, 119: 84-109. 本文提出了一种智能多级入侵检测系统来检测过程控制网络数据包中的数据异常。 （i）基于布隆过滤器的有效载荷级别检测， （ii）基于分区的 Kohonen 映射，使用通过 Hypergraph 的主成分分析和分区特性增强的 Kohonen 神经网络的深度版本来学习异常数据模式， BLOSOM——一种混合异常检测模型。 使用超图模型在CPS系统中检测异常。对于NS5000的分析有一定参考价值。 IJSSE 2021 (不知名韩国期刊) 0引用 无原文 Mekelleche F, Haffaf H, Bouamama B O. Hypergraph model for wireless sensor networks supervision design[J]. International Journal of System of Systems Engineering, 2021, 11(1): 59-88. 超图用在无线传感器网络入侵检测领域（其他领域的应用）","tags":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://renzehua1998.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"论文阅读","slug":"论文阅读","permalink":"https://renzehua1998.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}]},{"title":"英语小班实践","date":"2022-05-04T04:00:00.000Z","path":"2022/05/04/英语小班实践/","text":"研一下英语小班实践资料：peer review和presentation Review Comments Title: Design and Implementation of Big Data Analysis Method for Short-term Stock Trend Prediction Author: Shupei Li Reviewer: Zehua Ren 3121154002 Work overview This paper proposes a stock price prediction algorithm based on LSTM (Long Short Term Memory) classifier. First, the continuous data is discretized, then 14 groups of discrete data types are reduced by decision tree algorithm to eliminate useless data types, and then the reduced attributes are put into the LSTM classifier for training and prediction. In addition, non-technical indicators are added to the model to improve the accuracy of the model. Writing level Strengths The research problem is meaningful, and the proposed solution is technically correct. This paper is clear and easy to understand. The article combines the results of the experimental analysis to make the conclusion more convincing. Weakness Formatting issues: The first letter of the word after the semicolon should be lowercase. The font size of this two paragraphs is not uniform. Express problem: The paper does not list what the other properties are, which may confuse readers. Grammatical errors: There are some \"A\" in this paragraphs which is strange. Consider remove some of them and change others into lowercase. The last highlighted word might be non-technical according to context. Typography issues: Please use the IEEE two-column template and translate Chinese references into English. Formula problem: The symbol a is used in the left of equal sign but it does not appear in the right side, while there are several in the right. Consider change the superscript into a or explain in the text. Technical level Strength The discretization method used in this paper characterizes the stock price changes well. The author demonstrate the effectiveness of one-dimensional clustering discretization method using both theoretical reasoning and experimental verification. Questions There are lack of results in 14 attribute situation when non-technical indicators are added into the model. Is it a technical reason? Hope to explain in the text. How does the non-technical indicator part affect the forecast results? How do these unquantifiable factors act quantitatively on the predictive model? The Equidistance bulk chemical method is not explicitly stated in the text. Please explain it in revised manuscript. Some doubts: This method tries to fit the stock trend curve, but there are many random factors in the stock market, and this method does not seem to take the effect of randomness into account. Combining stochastic process analysis to give confidence intervals seems to be a better approach. Otherwise, the model may be overfitting, and some features of random interference may be learned and cannot make more accurate predictions. Proposed changes Add related work to illustrate the innovation of this paper in this field. Draw the overall flow chart for easy understanding. Such as: Add a comparison with other methods to demonstrate the effectiveness of this method. Consider using tables to present. The prediction effect can be displayed visually by drawing a comparison curve between the real data and the predicted data. Such as: Reference articles Decision tree ID3 algorithm Stock forecast 其他资料 论文原文：work review内容：PPT presentation：PPT","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"随机过程","date":"2022-04-18T04:00:00.000Z","path":"2022/04/18/随机过程/","text":"研一下随机过程考试题回忆版 这是换老师的第一年，题很简单都是原题，估计也就仅此一回了。","tags":[]},{"title":"机器学习","date":"2022-04-14T04:00:00.000Z","path":"2022/04/14/机器学习/","text":"研一下机器学习与人工神经网络课程汇报：基于GAN的图自动着色。 包括自然图像着色和漫画着色 前期调研：调研内容 课堂汇报：PPT 6.15答疑 考试 6月23号晚上7:30-9:30，两个小时。 占比60%-70%，每人带一份材料（一本）。 8-9道大题：概念解释、计算不会很难、计算性的推导（估计）、算法描述、原理阐述、设计（实际问题设计算法框架、流程）。 可以带计算器，不过应该用不到。 考试内容都是在讲义范围之内，好好看PPT。","tags":[{"name":"Python","slug":"Python","permalink":"https://renzehua1998.github.io/tags/Python/"},{"name":"神经网络","slug":"神经网络","permalink":"https://renzehua1998.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"系统优化大作业","date":"2021-12-31T04:00:00.000Z","path":"2021/12/31/系统优化大作业/","text":"研一上系统优化大作业，解决实际问题。 ——LR Algorithm Based on Interleaved Subgradient Method and Its Application in Multistage HFSP Abstract In order to reduce the complexity of the solution and shorten the calculation time, an improved Lagrangian relaxation algorithm combined with the interleaved subgradient method is proposed for the problem of the total weighted completion time of the multi-stage mixed flow shop. An integer programming mathematical model that comprehensively considers the finite waiting time and workpiece release time is established. An interleaved subgradient method is embedded into the Lagrangian relaxation algorithm, so that a reasonable interleaved subgradient direction can be obtained by approximately solving the Lagrangian relaxation problem. Search in this direction, gradually reducing the distance to the optimum point. The effectiveness of the proposed algorithm is verified by simulation experiments. Comparing the proposed algorithm with the traditional Lagrangian relaxation algorithm based on the subgradient method, the results show that the proposed algorithm can obtain better near-optimal performance in a shorter computing time in terms of the solution quality and computation efficiency , especially for large-scale problems. Key words: systems engineering; interleaved subgradient method; Lagrangian relaxation; multi-stage hybrid flowshop problem; total weighted completion time. Background and motivations The Hybrid Flow Shop Problem (HFSP) can generally be described as: A set of workpieces is processed through processing stages in the same processing sequence, and each stage is composed of isomorphic parallel machines, at least one processing stage with ; each workpiece is processed on at most one isomorphic machine in each stage; each machine can process at most one workpiece at any time, and each workpiece can only be processed on one machine at any time. Therefore, the problem to be solved by HFSP is to assign the workpieces to the machines and determine the scheduling of the workpieces on the machines at each processing stage, while also optimizing a given objective function[1,2]. This paper studies a kind of more complex HFSP, which is different from the general HFSP: · Workpiece has a waiting time limit between two adjacent processing stages; · Each workpiece can only be used for processing at time ; · Transport time between adjacent processing stages is not negligible. Gupta proved that the two-stage HFSP is NP-hard, even though there is only one machine for one processing stage. Therefore, the more complex HFSP studied in this paper is also NP-hard[3], which makes it particularly important to explore approximate algorithms for solving such problems. As an optimization-based approximation algorithm, the Lagrangian relaxation (LR) algorithm has the basic idea of decomposition and coordination. For the actual scheduling problem, through a reasonable design, the algorithm can obtain nearly optimal solution with quantifiable quality in a reasonable computing time[4]. The traditional LR algorithm relaxes the machine capability constraint by introducing the Lagrange multiplier vector, and then decomposes the formed relaxation problem into multiple workpiece-level sub-problems, uses dynamic programming to optimally solve these sub-problems, and then uses the sub-gradient method to update the multiplier. sub-problem, using heuristics to convert the solution of the sub-problem to a feasible solution to the original problem. The above process is repeated until certain stopping conditions are met. However, when the scale of the actual problem is large, the computational complexity of optimally solving the Lagrangian problem by dynamic programming also increases, which makes the solution quite time-consuming. Therefore, this paper introduces the interleaved subgradient method in the LR algorithm, which is a special case of the surrogate subgradient method[5], which requires each iteration to optimally solve a Lagrangian problem and saves the calculation time. The purpose is to obtain better solutions to large-scale problems in a shorter computational time. In recent years, there are few researches on the optimization of HFSP based on the surrogate subgradient method For different production scheduling problems, it is necessary to study the specific implementation of the algorithm to obtain a satisfactory solution. Therefore, aiming at the total weighted completion time, this paper investigates the effectiveness of solving the embedded interleaved subgradient method LR of HFSP with waiting consideration, extending the theory of LR algorithm and its application. Mathematical description The HFSP studied in this paper is to schedule workpieces in the same machining order on G-stage parallel machines, with the goal of minimizing the total weighted completion time to reduce inventory. The waiting time of the workpiece between adjacent processing stages is not allowed to exceed the upper limit of waiting. Assuming that each operation is not allowed to be interrupted, each workpiece can only start processing at time , and the transportation time cannot be ignored. Symbol description Known parameters: is the total number of workpieces; is the total number of stages; is the number of machines available for stage ; is the workpiece in stageprocessing time; is the release time of workpiece ; is the transportation time of stages and ; is the upper waiting limit between adjacent stages and of workpiece ; is the total planned time level. Decision variable: is the completion time of workpiece in stage ; is a variable, if workpiece is being processed in stage at time , its value is 1, otherwise it is 0. ; ; . Integer programming model Constraint (2) represents the operation priority of a workpiece between processing stages; constraints (3) to (5) define the time interval that each workpiece occupies the machine in the processing stage; constraint (6) represents the waiting time after the workpiece is machined at stage and delivered to stage cannot exceed the upper limit of waiting; Constraint (7) states that all machine requirements must meet the number of machines available at that time; Constraint (8) states that each workpiece can only be Processing can only be started at the start end of the production system; constraints (9) to (10) define the value range of variables. Solution method Based on the workpiece decomposition strategy, the machine capability constraints are relaxed into the objective function by introducing Lagrangian multipliers. The purpose of the relaxation capability constraints is to decompose the relaxed problem into multiple workpiece-level sub-problems that are relatively easy to solve. Relaxation and decomposition The Lagrangian multiplier vector (whose component is is introduced, and the constraint (7) is relaxed into the objective function to form the Lagrangian relaxation problem: Satisfy constraints (2)～(6), (8)～(10) and: Then the Lagrange duality problem is: Satisfy constraints (2)～(6), (8)～(11). Given , the artifact-level subproblem of artifact is: Satisfy constraints (2)～(6), (8)～(11). Decomposition and coordination Figure 1 shows the two-level decomposition-coordination structure of the LR algorithm. At \"low level\", M artifact-level subproblems are solved given the multipliers are known; at \"high level\", the multipliers are updated based on the degree of constraint violation, and then design a heuristic based on the solution of the subproblem to transform it into a feasible solution until the end of the iterative process[4]. Figure 1 Two-level decomposition-coordination structure The difference between the designed LR algorithm and the traditional LR algorithm is that the designed algorithm approximately solves the subproblems in each iteration and uses the interleaved subgradient method[5] to update the multipliers in the \"advanced\". Approximate solution of subproblems Given a certain workpiece and the multiplier , the recursive relation for optimal solution of backward dynamic programming is: Then trace forward to get the optimal solution of the sub-problem in the s-th iteration. When and , let ; when let , then obtain an approximate solution to the relaxation problem. Construction of feasible solutions Based on the solution of the relaxation problem obtained above, for each stage , arrange the workpieces in increasing order of the start time of the stage, and then assign them to the available machines in turn. If the waiting time between adjacent processing stages exceeds , then delay the start time of the workpiece in phase until the waiting time constraint is satisfied. Dual problem The traditional subgradient method requires the optimal solution of all Lagrangian problems in each iteration to obtain the subgradient direction, so when the scale of the problem is large, the solution of the relaxation problem is complicated and time-consuming. To this end, the interleaved subgradient method[5] is designed to reduce the solution time spent in each iteration, and it can update the multipliers after each sub-problem is solved. The surrogate dual function is defined as: Then the surrogate subgradient is defined as: The execution process of the interleaved subgradient method is as follows: Step 0 initializes and minimizes all subproblems to get , that is: Calculate the dual cost and subgradient, update the multipliers along the direction of the subgradient. Let the subproblem label. Step 1 Knowing the of the s-th iteration, optimally solve the p-th sub-problem while keeping the solutions of other sub-problems unchanged, and calculate the surrogate dual cost and surrogate subgradient according to equations (16) and (17). Step 2 Update the Lagrange multipliers from the and obtained in the previous step: where the step size is defined as: Here , is the estimated value of the optimal dual cost, and is the surrogate dual cost of the s-th iteration. Step 3 Let , if , then reset . Step 4 If the CPU time reaches a certain limit or the agent dual gap is less than a small number, the program stops, otherwise it returns to Step 1. Simulation results Using C language to execute the designed algorithm on PC (2.10GHz CPU), the simulation experiment compares the algorithm with the traditional LR based on subgradient method. First, tests on small and medium scale problems demonstrate the effectiveness of the two algorithms; then the results of running on real large scale problems are compared to estimate the performance on real scale problems. The maximum size of the tested problem is 200 artifacts, 4 stages, 5 parallel machines. For each set of , 10 instances are randomly generated; in each instance, the data of each workpiece is randomly generated as follows: the weight and processing time satisfy the uniform distribution , and the release time satisfies the uniform distribution . The transportation time between adjacent processing stages satisfies the uniform distribution . The waiting time is taken as 5, 15. The total time level is set as the sum of all machining times. The algorithm terminates after 90 seconds. LR-ISG is used to represent the LR based on the interleaved subgradient method, and LR-SG is used to represent the traditional LR based on the sub-gradient method. The performance indicators of the two algorithms are measured by the duality gap and the number of iterations. SDG is defined as the surrogate dual gap (%), and its value is equal to (UB-SLB)/SLB×100%, DG is the true dual gap, calculated by (UB-LB)/LB×100%, IN represents the number of iterations, here , UB represents the feasible cost, that is, the upper bound of the original problem; LB represents the dual cost, that is, the lower bound; SLB is the agent dual cost. Example 1 In this section, the cases of 40 and 80 workpieces are tested, and the calculation results are shown in Tables 1-2. The results in the table (except the last row) are the average of 10 groups of instances of the same scale. From the table it can be seen that: For the case of 40 workpieces, when and 15, the average dual clearances obtained by LR-ISG are 2.64% and 3.09%, respectively, and those obtained by LR-SG are 2.97% and 2.97%, respectively. Therefore, the proposed algorithm reduces the dual gap by 0.33% and 0.17% on average compared with the traditional LR. For the case of 80 workpieces, when and 15, the average dual gaps obtained by LR-ISG are 5.22% and 6.04%, respectively, and those obtained by LR-SG are 5.46% and 5.46%, respectively. Therefore, the proposed algorithm reduces the dual gap by 0.24% and 1.95% on average compared with the traditional LR. In the same calculation time, the number of iterations performed by LR-ISG is dozens of times that of LR-SG. This is because LR-ISG only optimally solves one sub-problem in each iteration. It's time is much less than solving all subproblems. When and 15, the deviations of LR-ISG's surrogate dual gap and true dual gap are 0.04% and 0.05% (for 40 workpieces), 0.38% and 0.49, respectively % (for 80 workpieces), that is, the surrogate dual gap obtained by LR-ISG is not much different from the real dual gap. To sum up, for small and medium-sized problems, these two algorithms can obtain a good near-optimal solution in a short computing time (90s), and the proposed LR algorithm performs better. Table1 Test results when M=40 G×mg U = 5 U = 15 LR-ISG LR-SG LR-ISG LR-SG SDG DG IN DG IN SDG DG IN DG IN 3×3 2.37 2.43 32873 3.18 1513 2.53 2.60 20815 3.42 657 3×4 2.02 2.05 33625 2.44 1551 2.42 2.46 21144 2.84 681 3×5 1.66 1.68 33801 1.75 1601 1.92 1.92 22164 1.81 728 4×3 4.23 4.33 19792 5.24 852 4.69 4.83 11703 5.67 360 4×4 2.67 2.69 21706 2.94 842 3.32 3.34 11498 3.08 362 4×5 2.67 2.68 21228 2.24 843 3.34 3.36 11311 2.74 348 avg 2.60 2.64 27171 2.97 1200 3.04 3.09 16439 3.26 523 Table2 Test results when M=80 G×mg U = 5 U = 15 LR-ISG LR-SG LR-ISG LR-SG SDG DG IN DG IN SDG DG IN DG IN 3×3 3.84 4.44 12488 5.24 412 4.67 5.54 9221 6.75 173 3×4 3.79 4.02 12964 4.19 409 4.29 4.60 8800 5.66 171 3×5 3.60 3.71 13318 3.56 400 4.18 4.30 7810 4.96 170 4×3 6.41 7.30 7438 7.76 216 6.93 7.98 5184 11.24 91 4×4 6.19 6.53 7859 6.68 213 7.13 7.59 5081 10.42 90 4×5 5.22 5.31 8296 5.32 215 6.07 6.21 5180 8.90 91 avg 4.84 5.22 10394 5.46 311 5.55 6.04 6879 7.99 131 Example 2 The number of workpieces tested in this section is taken from , and the test results are shown in Tables 3 to 5. From the results in the table, the following conclusions can be drawn: When , for the cases of 120 workpieces, 150 workpieces and 200 workpieces, the average surrogate-dual gap obtained by LR-ISG at 5492, 3732 and 1939 iterations, respectively, is 5. 44%, 5. 25%, 5. 34%; the real dual gaps are 6. 49%, 6. 70%, 7. 83%. The dual gap obtained by LR-SG at 140, 90 and 51 iterations, respectively, is 8. 20%, 10. 86%, 18. 79%. Therefore, the dual gap of LR-ISG is lower than that of LR-SG by 1. 71%, 4. 16%, 10. 96%. When , for the cases of 120 workpieces, 150 workpieces and 200 workpieces, the average surrogate duality gap obtained by LR-ISG at 4130, 2900 and 1860 iterations, respectively, is 6. 94%, 7. 32%, 8. 63%; the real dual gaps are 8. 49%, 9. 60%, 13. 56%. The dual gaps obtained by LR-SG at 59, 36 and 18 iterations, respectively, are 16. 54%, 27. 42%, 51. 97%. Therefore, the dual gap of LR-ISG is lower than that of LR-SG 8. 05%, 17. 82%, 38. 41%. When and 15, the deviations of LR-ISG's surrogate dual gap and true dual gap are 1.05% and 1.55% (for 120 workpieces), 1.45% and 2.28%, respectively (for 150 workpieces), 2.49% and 4.93% (for 200 workpieces), that is, as the scale of the problem increases, the difference between the surrogate dual gap and the true dual gap obtained by LR-ISG is also greater. To sum up, LR-ISG can obtain a good near-optimal solution for large-scale problems in a short computing time (90s), and LR-ISG is significantly better than LR-SG in terms of solution quality and computational efficiency. Table3 Test results when M=120 G×mg U = 5 U = 15 LR-ISG LR-SG LR-ISG LR-SG SDG DG IN DG IN SDG DG IN DG IN 3×3 2.81 3.79 6782 5.36 186 5.58 8.01 5678 12.93 77 3×4 3.88 4.73 7302 5.80 184 5.57 6.80 5364 11.00 79 3×5 4.66 5.14 7601 5.85 183 5.64 6.43 5405 10.75 76 4×3 6.91 9.91 3435 11.81 92 8.33 11.04 2650 23.31 38 4×4 7.01 8.07 3784 10.72 96 8.09 9.43 2839 21.16 40 4×5 7.36 8.02 4046 9.64 98 8.40 9.25 2844 20.11 40 avg 5.44 6.49 5492 8.20 140 6.94 8.49 4130 16.54 59 Table4 Test results when M=150 G×mg U = 5 U = 15 LR-ISG LR-SG LR-ISG LR-SG SDG DG IN DG IN SDG DG IN DG IN 3×3 1.93 2.89 4415 5.65 119 5.21 8.11 3625 19.73 49 3×4 3.88 4.98 4954 7.38 116 5.57 7.48 3768 16.89 50 3×5 4.40 5.23 5249 7.30 118 6.15 7.45 3832 17.15 49 4×3 6.55 9.29 2451 15.36 63 9.15 13.09 1955 36.97 25 4×4 7.28 9.16 2550 14.93 63 8.99 11.25 2062 37.20 23 4×5 7.48 8.62 2771 14.53 62 8.86 10.22 2157 36.60 22 avg 5.25 6.70 3732 10.86 90 7.32 9.60 2900 27.42 36 Table5 Test results when M=200 G×mg U = 5 U = 15 LR-ISG LR-SG LR-ISG LR-SG SDG DG IN DG IN SDG DG IN DG IN 3×3 1.64 2.85 2447 11.36 67 5.91 10.87 2290 41.16 24 3×4 2.81 4.35 2387 11.14 67 5.84 8.91 2452 36.47 24 3×5 4.75 6.38 2620 12.00 67 6.23 8.43 2545 35.03 25 4×3 5.75 10.09 1291 26.53 34 10.89 20.29 1205 74.86 12 4×4 7.69 11.21 1395 25.58 35 10.98 16.54 1316 63.97 13 4×5 9.37 12.10 1496 26.14 36 11.91 16.34 1350 60.35 13 avg 5.34 7.83 1939 18.79 51 8.63 13.56 1860 51.97 18 Summary In this paper, an improved LR algorithm with embedded interleaved subgradient method is designed for HFSP considering waiting, and the goal is to minimize the total weighted completion time. The computational complexity and required computation time of each iteration are simplified by the approximate solution of the relaxation problem, and a reasonable asynchronous subgradient direction is obtained to search for a better solution. The simulation results show that the proposed algorithm can obtain a good near-optimal solution in a short computing time when solving small to large-scale problems, especially for practical large-scale problems, its performance is significantly better than that of traditional LR. Further work can generalize the method to complex production scheduling problems with other production characteristics. References: [1] Gicquel C，Hege L，Minoux M，van Canneyt W． A discrete time exact solution approach for a complex hybrid flow-shop scheduling problem with limited constraints[J]． Computers＆ OperationsＲesearch，2012，39(3) : 629-636． [2] Niu Q，Zhou T，Fei M，Wang B． An efficient quantum immune algorithm to minimize mean flow time for hybrid flow shop problems[J]． Mathematics and Computers in Simulation，2012，84: 1-25． [3] Gupta J N D． Two-stage hybrid flowhsop scheduling problem[J]． Journal of the OperationalＲesearch Society，1988，39: 359-364． [4] Chen H X，Luh P B． An alternative framework to Lagrangian relaxation approach for job shop scheduling[J］． European Journal of OperationalＲesearch，2003，149(3) : 499-512． [5] Zhao X，Luh P B，Wang J． Surrogate gradient algorithm for lagrangian relaxation[J]． Journal of Optimization Theory and Application，1999，100(3) : 699-712．","tags":[{"name":"优化","slug":"优化","permalink":"https://renzehua1998.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"系统优化中期作业","date":"2021-12-31T03:00:00.000Z","path":"2021/12/31/系统优化中期作业/","text":"研一上系统优化中期作业，优化求解。 Project Requirement Give a non-quadratic nonlinear objective function and linear inequality constraints (at least two). Select a computational method (primal or dual) for constrained optimization you learn in the class. Show your computational results and corresponding analysis. Submit the typed report. Attach your program Problem Consider the problem below: We solve this problem by using Lagrangian Relaxation Method. Main method When we use the Lagrangian Relaxation Method, we describe the problem as below, the i-th equality constrain is expressed as while the i-th inequality constrain is expressed as So the unconstrained optimization problem can be described as: We can construct the Joseph-Louis Lagrange operator function, then the necessary conditions for the optimal solution can be obtained. It can be found that when the constrained plane is tangent to the equipotential surface, the gradient orthogonality on the equipotential line and the gradient orthogonality on the constrained plane are both on the same tangent plane, so the two gradients are expressed linearly. In other words, we can express each other with a coefficient, which we usually call the Lagrangian multiplier. When the constrained area contains the original feasible solution of the objective function, and the feasible solution of the constrained is still inside the constrained area at this time, corresponding to the case of g(x)&lt;0, then the constrained condition does not work; when the constrained area is not When the original feasible solution of the objective function is included, the feasible solution falls on the boundary g(x)=0 after adding constraints. The following figure describes the two cases respectively. The right figure shows that the feasible solution with the constraint will fall on the boundary of the constraint region. So we know that in either case the expression below always holds: If λ≠0, this means that the feasible solution x falls on the boundary of the constrained region. At this time, the feasible solution should be as close as possible to the unconstrained solution, so on the constrained boundary, the negative gradient direction of the objective function should be far away from the constrained region Towards the unconstrained solution, the gradient direction of the constraint function is exactly the same as the negative gradient direction of the objective function: This solution also holds in equation constrains, thus we get the KKT conditions: Our problem has non-quadratic nonlinear objective function and linear inequality constraints. So we can rewrite the unconstrained optimization problem as: Where equal to the above. The KKT conditions can be rewrite as: Results and analysis Step1: Write the Lagrange function: Step2: Get the partial derivative of : Step3: Relax constrain2, that means . We get the equation: Solve this equation, we get: x1 = 0.157380, x2 = 5.098362, = -1.316836, = -20.983589, Constrain2: = -9.963951 &lt; 0 The results meet constraint2 and x1,x2 &gt; 0, but &lt; 0 doesn’t meet KKT condition (4), so they are *not* optimal solutions. Step4: Relax constrain1, that means . We get the equation: Solve this equation, we get: x1 = 0.252336, x2 = 4.346513, = 1.139798, = -30.866020, Constrain1: = -6.489574 &lt; 0 The results meet constraint1, x1,x2 &gt; 0 and &gt; 0 meets KKT condition (4), so they are optimal solutions. Step5: Conclusion We obtain that when the point is (0.252336, 4.346513), the objective function reaches the minimum value: -30.866020. Test1 We use function fmincon in Matlab and function minimize in Python to solve the nonlinear programming. The results are written below: In Matlab, we get the optimal solution is (0.2523, 4.3465), the minimum value is -30.8660. In Python, we get the optimal solution is (0.252332, 4.346513), the minimum value is -30.866020. So the results we get is correct! Test2 We draw the corresponding 3D picture of the objective function, points witch don’t satisfy the constrains were deleted. The minimum point is very close to (0.26, 4.35), and the minimum value is close to -30.8309. Program Matlab program 123456789101112131415161718192021222324252627282930x = 0:.01:5;y = 0:.01:5;[x,y] = meshgrid(x,y);f=-20.*exp(-3*x).*x-18.*exp(0.75*(3-y)).*y;f(-5*x+8*y-40 &gt; 0 | 2*x-13*y+56 &gt; 0) = nan;mesh(x,y,f)clear;%% 使用matlab自带优化函数求解function fy = f(x) fy =-20*(exp(-3*x(1)))*x(1)-18*(exp(0.75*(3-x(2))))*x(2);end[x,y]=fmincon('f',[0 0],[-5 8;2 -13],[40;-56],[],[],[0 0],[])%% 拉格朗日乘子法求最优化解% 用syms表示变量构造拉格朗日函数syms x y lama1 lama2f1=-20*(exp(-3*x))*x-18*(exp(0.75*(3-y)))*y+lama1*(-5*x+8*y-40);f2=-20*(exp(-3*x))*x-18*(exp(0.75*(3-y)))*y+lama2*(2*x-13*y+56);% 分别求f1函数关于 x1、y1、lama1；f2函数关于 x2、y2、lama2的偏导dx1=diff(f1,x);dy1=diff(f1,y);dlama1=diff(f1,lama1);dx2=diff(f2,x);dy2=diff(f2,y);dlama2=diff(f2,lama2);% 分别令两个约束之一无效（可行解在约束区域内），研究结果[x1, y1, lama1]=solve(dx1,dy1,dlama1,x,y,lama1)result1=-20*(exp(-3*x1))*x1-18*(exp(0.75*(3-y1)))*y1test1 = 2*x1-13*y1+56 % 测试约束2是否满足[x2, y2, lama2]=solve(dx2,dy2,dlama2,x,y,lama2)result2=-20*(exp(-3*x2))*x2-18*(exp(0.75*(3-y2)))*y2test2 = -5*x2+8*y2-40 % 测试约束1是否满足 Python program 1234567891011121314151617181920212223242526from scipy.optimize import minimizeimport numpy as np# 待优化非线性函数：def func(args): fun = lambda x: -20*x[0]*np.exp(-3*x[0])-18*x[1]*np.exp(0.75*(3-x[1])) return fun# 各种约束def con(args): cons = ({'type': 'ineq', 'fun': lambda x: 5*x[0]-8*x[1]+40}, {'type': 'ineq', 'fun': lambda x: -2*x[0]+13*x[1]-56}) return consif __name__ == \"__main__\": args = () args1 = () cons = con(args1) x0 = np.array((2.0, 1.0)) # 设置初始值 # 调用默认包求解 res = minimize(func(args), x0, method='SLSQP', constraints=cons) print(res.success) print(\"x1=\", res.x[0], \"; x2=\", res.x[1]) print(\"最优解为：\", res.fun)","tags":[{"name":"Python","slug":"Python","permalink":"https://renzehua1998.github.io/tags/Python/"},{"name":"matlab","slug":"matlab","permalink":"https://renzehua1998.github.io/tags/matlab/"},{"name":"优化","slug":"优化","permalink":"https://renzehua1998.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"系统工程大作业","date":"2021-12-30T04:00:00.000Z","path":"2021/12/30/系统工程大作业/","text":"研一上系统工程大作业，包括课堂汇报PPT和平时作业，仅作存档。 课堂汇报：PPT 平时作业：作业 大作业报告：大作业","tags":[{"name":"控制","slug":"控制","permalink":"https://renzehua1998.github.io/tags/%E6%8E%A7%E5%88%B6/"}]},{"title":"数理统计大作业","date":"2021-12-29T04:00:00.000Z","path":"2021/12/29/数理统计大作业/","text":"研一上数理统计大作业，使用一种数理统计方法进行分析，解决问题。 题目 为了研究不同树种和地理位置对松树生长的影响，我们对4个地区的3种同龄松树的直径进行测量，得到的数据见下表。其中A1，A2，A3分别表示3个不同的树种,B1至B4分别表示4个不同的地区。对每种水平组合进行了5次测量。给定显著性水平α=0.05，对上述试验结果进行分析，研究两种因素对松树的生长有无显著影响。 三种同龄松树的直径测量数据 B1 B2 B3 B4 A1 23, 25, 21, 14, 15 20, 17, 11, 26, 21 16, 19, 13, 16, 24 20, 21, 18, 27, 24 A2 28, 30, 19, 17, 22 26, 24, 21, 25, 26 19, 18, 19, 20, 25 26, 26, 28, 29, 23 A3 18, 15, 23, 18, 10 21, 25, 12, 12, 22 19, 23, 22, 14, 13 22, 13, 12, 22, 19 解题 方差分析 考虑二者的交互作用，计算两种因素、交互作用和误差的平方和、自由度与F值，与拒绝域边界进行比较，计算PR。方差分析结果如下表所示： 双因素方差分析表 方差来源 平方和 自由度 均方和 F值 PR(&gt;F) 因素A 352.533333 2 176.2666665 8.958916 0.000494 因素B 87.516667 3 29.17222233 1.482705 0.231077 交互作用 71.733333 6 11.9555555 0.607652 0.722890 误差 944.400000 48 总和 1456.18333 59 将PR值与α值进行比较，若PR小于α，则拒绝原假设H0，认为该因素对松树生长有显著影响；否则接受原假设H0，认为该因素对松树生长无显著影响。 从上表可得： 0.000494 &lt;&lt; 0.05——因素A，即树种对于松树的生长有显著影响； 0.231077 &gt;&gt; 0.05——因素A，即地区对于松树的生长无显著影响； 0.722890 &gt;&gt; 0.05——因素A，即二者的交互作用对于松树的生长无显著影响。 由此我们得出结论： 仅树种对松树生长有显著影响，地区和交互作用对松树生长都无显著影响。 Shapiro-Wilk正态性检验 由于方差分析的前提假设是样本在每个因素下的水平都呈现正态分布，而我们进行方差分析的结果是否有效，和样本是否服从正态分布密切相关。所以，在完成方差分析后，我们还需要对数据的正态性进行检验。 此处我们使用Shapiro-Wilk正态性检验方法： 假设H0: 一定样本量n(3&lt;n&lt;50)的研究对象总是符合正态分布。 将样本量为n的样本按照大小顺序编排，然后根据公式计算统计量W的值，该值越接近于1，且显著水平大于0.05时，我们就没法拒绝原假设。 使用此方法检验每个因素在不同水平下样本的正态性，得到如下结果： 正态检验结果表 水平 统计量W 显著水平P 因素A水平1 0.9758586287498474 0.8702935576438904 因素A水平2 0.9438899755477905 0.28368762135505676 因素A水平3 0.9106301665306091 0.06552256643772125 因素B水平1 0.9835260510444641 0.9880000948905945 因素B水平2 0.8537424802780151 0.019627654924988747 因素B水平3 0.948333740234375 0.4986009895801544 因素B水平4 0.9451896548271179 0.45210620760917664 从上表可以看出，仅因素B的水平2未通过正态分布检验，由此可知，数据的整体正态性优良，得到的结论说服性强。 Bartlett方差齐性检验 对于方差分析，我们除了假设正态分布外，还假设了同种因素各水平样本方差相同。所以我们使用Bartlett方差齐性检验： 假设H0: 研究对象方差相同。 根据公式计算统计量K2的值，显著水平大于0.05，我们就没法拒绝原假设。 假设有r个分组，每组的标准差为S12，S22，Sr2由这些标准差还可以计算出MSe，统计量K2近似服从r - 1的卡方分布。 其中： 使用此方法检验每个因素样本的正方差，得到如下结果： 方差齐性检验结果表 水平 统计量K2 显著水平P 因素A 0.5900002171357336 0.8702935576438904 因素B 2.043625626141553 0.5634015923679045 从上表可以看出，数据在两因素各水平下样本方差基本相同。 源代码 代码1 123456789101112131415161718'''第一部分双因素方差分析代码'''y = np.array([23, 25, 21, 14, 15, 20, 17, 11, 26, 21, 16, 19, 13, 16, 24, 20, 21, 18, 27, 24, 28, 30, 19, 17, 22, 26, 24, 21, 25, 26, 19, 18, 19, 20, 25, 26, 26, 28, 29, 23, 18, 15, 23, 18, 10, 21, 25, 12, 12, 22, 19, 23, 22, 14, 13, 22, 13, 12, 22, 19])A = np.repeat([1,2,3],[20,20,20])B_1 =np.repeat([1,2,3,4],[5,5,5,5])## 构造因素B的水平对照B= np.concatenate((B_1,B_1,B_1))trees = pd.DataFrame({'y':y,'A':A,'B':B})## 进行方差分析tree_lm = smf.ols('y ~ C(A, Sum)*C(B, Sum)', data=trees).fit()table = anova_lm(tree_lm, typ=2)print(table) 输出： sum_sq df F PR(&gt;F) C(A, Sum) 352.533333 2.0 8.958916 0.000494 C(B, Sum) 87.516667 3.0 1.482705 0.231077 C(A, Sum):C(B, Sum) 71.733333 6.0 0.607652 0.722890 Residual 944.400000 48.0 NaN NaN 代码2： 12345678## 正态性检验print('因素A水平1的正态性检验：',st.shapiro(y[A==1]))print('因素A水平2的正态性检验：',st.shapiro(y[A==2]))print('因素A水平3的正态性检验：',st.shapiro(y[A==3]))print('因素B水平1的正态性检验：',st.shapiro(y[B==1]))print('因素B水平2的正态性检验：',st.shapiro(y[B==2]))print('因素B水平3的正态性检验：',st.shapiro(y[B==3]))print('因素B水平4的正态性检验：',st.shapiro(y[B==4])) 输出： 因素A水平1的正态性检验： (0.9758586287498474, 0.8702935576438904) 因素A水平2的正态性检验： (0.9438899755477905, 0.28368762135505676) 因素A水平3的正态性检验： (0.9106301665306091, 0.06552256643772125) 因素B水平1的正态性检验： (0.9835260510444641, 0.9880000948905945) 因素B水平2的正态性检验： (0.8537424802780151, 0.019627654924988747) 因素B水平3的正态性检验： (0.948333740234375, 0.4986009895801544) 因素B水平4的正态性检验： (0.9451896548271179, 0.45210620760917664) 代码3： 123## 方差齐性检验print(\"因素A：\",st.bartlett(y[A==1],y[A==2],y[A==3]))print(\"因素B：\",st.bartlett(y[B==1],y[B==2],y[B==3],y[B==4])) 输出： 因素A：BartlettResult(statistic=0.5900002171357336, pvalue=0.7445315066337076) 因素B：BartlettResult(statistic=2.043625626141553, pvalue=0.5634015923679045) 考试小抄 祖传数理统计小抄：考试小抄","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Python","slug":"Python","permalink":"https://renzehua1998.github.io/tags/Python/"}]},{"title":"创新港周边健身线路推荐","date":"2021-11-21T04:00:00.000Z","path":"2021/11/21/创新港周边健身线路推荐/","text":"研一党支部“我为师生办实事”活动中写的推荐文章。 大家来到创新港科研学习已经有将近三个月了，在繁忙的研究生活中，不知道有没有想要出去运动一圈放松一下呢？今天我们为大家带来了港村周边适合跑步、健走、骑行的线路，保证让各位同学在保证安全的同时尽情享受运动的乐趣。 创新港田径场 位置：4、5号楼之间 长度：600米（内圈585米） 材质：塑胶 运动方式：跑步、健走 注意事项：这里是短跑和短距离长跑最适宜的场地，塑胶地面非常适合穿上跑鞋来一场酣畅淋漓的奔跑。在结束一天忙碌的科研生活后，走出工位来到楼前就可以开跑。旁边的台阶和双杠可以暂时放置一下外套和水瓶，目前没有发生过失窃现象，但是建议不要放置贵重物品以免造成损失。白天人不多，以夜跑为主，晚上会开灯但是人也会变多。跑道不是很宽，晚饭后会有许多散步的同学，跑步时需要注意避让。晚上十一点会熄灯。 创新港外环 位置：创新港外大圈（思源环南路-思源环北路） 长度：8公里 材质：柏油马路 运动方式：跑步、骑行 注意事项：这里是创新港长距离跑者必刷路线，也是骑行的好去处，同时也是天然的练车路段。这里车虽然不多但是普遍比较快，北边有专门为跑者和自行车修的路，南边车多且没有自行车道。青年教师公寓入口出车很多，过路口一定要注意安全。不建议天黑跑，很不安全，跑步建议结伴同行互相照应。 创新港-咸阳渭河三号桥 位置：创新港向东，新河-滨渭湿地公园线路。 长度：6-8公里 材质：石板路、柏油路、土路 运动方式：跑步、骑行 注意事项：这边的路段比较原生态，适合结伴骑车游玩，或者对复杂路段有经验的跑者挑战。由于路程较远，不建议步行。过程中会经过两个大路口，需要注意来往车辆。可以漫步在渭河之滨，可以奔跑在霞光里，可以感受着对岸吹来的晚风吃点东西。由于这边公园尚在开发，所以人工景点不多，主要是原生态的渭河风光。 河堤路向西 位置：创新港以西河堤路。 长度：任意（甚至可以去宝鸡） 材质：柏油路 运动方式：骑行 注意事项：河堤路有专门为自行车修的通道，沿线非常平坦安全。每个区县修建的路段都不太一样。从学校刚出去是沣西新城修的红色柏油路，稍微走一走就是西安鄠邑区修的两条黑色柏油路，穿过鄠邑区来到周至县又是另一种样式。两边的树和绿化带灌木也不相同，非常漂亮。要是傍晚过去可以看到渭河落日，感受一下“落霞与孤鹜齐飞，秋水共长天一色”。当然要是自己有车，也可以开车去更远的地方看看，按道理可以一直走到渭河源头。","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"文明餐桌活动感悟","date":"2021-11-19T04:00:00.000Z","path":"2021/11/19/文明餐桌活动/","text":"研一上参加了文明餐桌活动写的感悟，存档。 今天和班里的同学们参加了文明餐桌志愿活动，我们在惠风苑二楼收餐具窗口负责餐具整理与剩饭收集工作。经过中午与晚上的工作，我们帮助收餐阿姨收拾了一大批餐具，也将剩饭进行了干湿分离，感觉这一天的工作非常充实。 在收餐具的同时我们也发现，同学们剩饭剩菜的现象比较严重。有好多米饭才动了几口就匆匆丢弃，还有同学点的炒菜剩下了大量土豆和蔬菜。我们询问阿姨每天要处理剩饭的量，她们说一般每天会有3-5桶，在高峰期会更多。这也提醒着我们一粥一饭当思来之不易。我们也体会到仅仅是收餐这窗口一处就如此忙碌，进一步反映了食堂工作的校工的辛苦。 尽自己所能为文明校园作出一份贡献，我感到非常自豪，期待再次参加相关活动！ 活动照片：","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"复杂网络大作业","date":"2021-10-31T04:00:00.000Z","path":"2021/10/31/复杂网络大作业/","text":"研一上复杂网络课程大作业：（复现、改进与对比分析） 在现实世界的超图中，超边是如何重叠的？——模式，测量指标与生成 开题报告：开题 原始论文：原文 翻译 改进说明：PPT 源代码：GitHub","tags":[{"name":"算法","slug":"算法","permalink":"https://renzehua1998.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Python","slug":"Python","permalink":"https://renzehua1998.github.io/tags/Python/"},{"name":"图与网络","slug":"图与网络","permalink":"https://renzehua1998.github.io/tags/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"name":"CPP","slug":"CPP","permalink":"https://renzehua1998.github.io/tags/CPP/"}]},{"title":"人工智能与网络安全的联系","date":"2021-10-31T04:00:00.000Z","path":"2021/10/31/人工智能和网络安全的联系/","text":"研一上自然辩证法课程感悟作业，查了些资料写成的，不太完善，存个档吧。 在当今这个万物互联的时代，当一台设备被攻陷，影响就有可能瞬间传递到大量关联设备，带来巨量用户信息泄露与财产损失。而随着人工智能技术的崛起，越来越多的日常用品被赋予“智能化”功能，基于云端运算进行控制调动，传统的安全观已经不再适用于越来越复杂的人工智能应用场景。而针各种网络场景开展的各类攻防博弈中，AI的身影也屡见不鲜。基于机器学习的多维特征匹配技术在威胁检测方面取得了显著成果，而使用强化学习的分布式攻击策略制定也为网络安全防卫带来了巨大挑战。 1. 泛人工智能时代的安全问题 智能设备已经深入我们的生活，从智能音箱等居家设备到自动驾驶汽车等交通工具，再到智能手表等可穿戴式设备，我们衣食住行的方方面面已经离不开基于局域网互联的各式移动终端。截止到去年2020年，全球接入互联网的终端设备已经达到了120余亿台，大量基于人工智能技术的智能终端组成了庞大的物联网络。而全球互联网用户还不到40亿，不及智能设备物联网的1/3，新的庞大平台必将为包括病毒在内的各种网络攻击提供广阔土壤。 由于智能设备可以直接联系我们日常生活的物理层面，从硬件操作的角度为我们提供服务，所以信息世界（赛博空间）和真实世界（物理空间）之间的界限变得逐渐模糊。而随着各种贴身终端的广泛使用，我们工作与生活的界限变得愈发难以分清。在这种情况下，一台联网设备只要被攻破，包括银行账户信息和公民健康信息在内的各种隐私敏感信息将会暴露无遗，将会为我们带来难以估量的损失。这种事情离我们并不遥远，2016 年 10 月，一款名为 Mirai 的恶意软件侵袭了大量存在漏洞的智能摄像头、智能网关、智能家电等物联网设备，被感染后的它们瞬间变成了网络中的「肉鸡」设备。在工控领域，2010 年的 Stuxnet （震网）蠕虫病毒能够针对西门子的监控与数据采集（SCADA）系统进行攻击，并通过 U 盘和局域网进行传播。 当然，我们面对的威胁还不止于此。在智能设备普及的当下，网络泛化已经成为大趋势。换言之，内网与外网的界限已经被大大模糊了。特斯拉汽车就可以随时随地通过Wi-Fi或者3G/4G接入互联网，而在未来，无人车还将与交通控制信号系统相连。一旦一台终端车被控制，攻击者可以通过它接入交通控制内网，从而操纵现实中的交通设施，从物理层面威胁到每一个交通参与者的人身安全。由于物联网和我们之间物理联系，多种多样的终端也为攻击者带来了丰富的攻击角度，前面提到的震网病毒就是如此。2013年3月美国曾利用“震网”蠕虫病毒攻击伊朗的铀浓缩设备，已经造成伊朗核电站推迟发电。目前国内已有近500万网民、及多个行业的领军企业遭此病毒攻击。 2. AI在网络攻防博弈中大放异彩 网络攻击的检测并非十分困难，反而相对容易。举例来说，当一台服务器被多IP短时大量访问可以判断为DDos（分布式拒绝服务）攻击，大量按顺序访问不同端口可以判断为端口扫描……经验丰富的安全运维人员可以轻易作出判断。但是，随着网络规模的扩大，一台大型服务器每天会受到数以亿计的攻击，仅仅靠人工判断依据无法满足大型网络的安全需求，通过设置一些规则让机器自动判断的方法也就应运而生。 然而让电脑学会人类的经验并不容易，我们通常会将各种各样的网络事件从不同的维度提取特征，如攻击次数、目标来源等等。通过这些多维特征向量为攻击行为作出画像，再利用人工智能领域最广为人知的分类技术对它们进行识别分类，作出相应的措施。以机器学习为代表的技术被大量应用于安全防卫领域，近些年来使用深度神经网络进行分类学习的技术也取得了长足的发展，在某些事件的处理应对准确率上也已超越了人类。 技术本身是中立的，而技术的应用却具有两面性。人工智能技术在帮助安全人员解放工作、服务于人民日常生活的同时，也开始被网络攻击者作为入侵工具。正如一把剑的两面刀刃，黑客利用人工智能技术，可以更好地训练自动化脚本模拟人类行为，让现有检测技术失效。而随着大量深度学习框架的开源，训练数据的学习门槛进一步降低。只要稍加学习，很多人都可以利用现有技术生成一套用于对抗检测系统的规则，作出一些以前无法实现的攻击。 人工智能技术本身的漏洞也有可能变成攻击的切入点。这就涉及到“泛安全”的概念，即涉及安全领域不止局限于网络，而是推广为各种技术，包括人工智能本身。因为当前机器学习严重依赖于数据，如果攻击者有意干扰训练数据，生成恶意样本，会导致错误识别或无效识别。比如，在无人驾驶测试路段德国 A9 高速公路上，有专门的标识引导无人驾驶车。如果路边的标识被恶意修改，误导依赖标识的无人驾驶车，则会造成极度危险的情况。 3. 可能的出路：一些个人想法 目前人工智能模型训练与应用上存在结果难以解释的问题，即虽然分类结果很好，但分类机理无法理解，也不能说出其中各种事件之间相互的关联关系。在后续的研究中，我们可以利用机器学习和统计学相结合的大数据分析方法，对各事件的关联度进行分析，找到常见合理可解释的攻击链条。从时间和空间相结合的角度还原黑客的进攻路径，找到防卫环节的薄弱点，有针对性地进行具体布防。 当前检测算法以大量数据为支撑，要训练准确度更高、普适性更好的分类模型就需要人工标定大量的数据集。我们可以通过降低算法复杂度的方式减少对数据的依赖，在训练初始引入先验知识，引导模型向对应的方向学习，以减小算法对数据的需求。当然，迁移学习也是一种很好的思路。把一种安全场景下训练好的模型经过一定程度的修改，应用到另一种场景中去，大大提高学习成本。 总之，随着人工智能技术日益普及，我们面临的安全场景也越来越多元化、复杂化。我们必须跟紧时代，懂得变通，才能适应新问题，新领域的需要。","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"看电影学英语资料","date":"2021-10-25T04:00:00.000Z","path":"2021/10/25/看电影学英语/","text":"研一上看电影学英语课程资料，PPT和配音等素材 寻梦环游记：COCO 我是传奇：Am Legend 疯狂动物城：Zootopia 哈利波特：Harry Potter","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"gitlab服务配置方案","date":"2021-10-20T04:00:00.000Z","path":"2021/10/20/gitlab/","text":"服务器上基于docker配置gitlab服务并修改host name全过程记录 Docker配置gitlab 教程：方案 Docker 创建容器后再修改 hostname 参考文档 写作本文的动机 当前使用docker配置的gitlab环境，在打开服务后其http地址并非显示当前服务器IP，而是docker容器的ID。这是因为在初始化容器的时候没有配置hostname，默认就是容器ID。每次发送的邮件里面都长这样： 之前想过很多办法修改，比如说ssh host可以通过配置gitlab.rb解决 下列操作都是在docker容器中进行的。 1vi /etc/gitlab/gitlab.rb 改了external_url就万事大吉了。 http host网上主流方法都是配置gitlab.yml。这种方法不是长久之计！ 1vi /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml 把 改成 这里就存在一个问题，每次服务器断电重启以后，这个文件就被重置了，相应的主机名和端口也变了。http涉及到网页服务和邮件服务，虽然使用git环境远程连接是没有问题的，但是每次收到邮件没有办法直接点进去看，网页端想跳回主页面直接来一个http://adb8725071ce神仙也打不开。 网上有方法是在建立docker容器的时候就设置： 1docker run --detach --hostname git.imebo.com --publish 8888:80 --publish 10443:443 --publish 10022:22 --name gitlab_web --restart always --volume /home/gitlab/config:/etc/gitlab --volume /home/gitlab/logs:/var/log/gitlab --volume /home/gitlab/data:/var/opt/gitlab docker.io/twang2218/gitlab-ce-zh 使用 --hostname参数直接设置就好，我们没有域名就设置IP地址。但是这种方法需要重新建一个gitlab环境，旧的gitlab现在已经运行了大半年，好多仓库也不能舍掉，所以只有另寻他法。 世上是有后悔药的，只要肯琢磨！再也不用重新创建容器了！ 操作过程 1. 查看容器配置文件在宿主机上的位置 1sudo docker inspect gitlab 复制这个路径 2. 关闭容器、关闭 docker 服务（重要） 查看当前运行的docker进程 1sudo docker ps 可以看到容器名称、ID、建立时间、端口映射信息。这些都是在建立的时候搞的。 123456# 关闭容器sudo docker stop gitlab# 关闭docker服务sudo systemctl stop docker# 查看是否关闭sudo systemctl status docker 3. 修改宿主机配置文件 cd到刚刚找到的目录下 这里有一个问题，普通用户权限不够，sudo的话显示sudo: cd: command not found。 这是因为cd不是一个应用程序而是Linux内建的命令，而sudo仅仅只对应用程序起作用。 使用sudo -i命令提升用户权限 搜索原 hostname 1grep \"adb8725071ce\" * 这三处需要修改 备份原文件 123cp config.v2.json config.v2.json.bakcp hostname hostname.bakcp hosts hosts.bak 使用vi或者vim修改、保存 123vi config.v2.jsonvi hostnamevi hosts 4. 启动 docker 服务，启动容器 12systemctl start dockersystemctl status docker 1docker start gitlab 5. 查看 hostname 1docker exec gitlab hostname 6. 检查是否ok","tags":[{"name":"git","slug":"git","permalink":"https://renzehua1998.github.io/tags/git/"}]},{"title":"智能车项目设计实验报告","date":"2021-01-29T04:00:00.000Z","path":"2021/01/29/智能车项目设计实验报告/","text":"大四上智能车项目设计实验报告 一、项目要求及准备 (一)项目要求 1.完成小车装配，了解硬件与操作系统，初步设计功能。 2.学习Linux常用命令，尝试编译、执行程序。 3.安装软件、学习控制各模块，学习GPIO相关知识。 4.学习电机相关知识，H桥、PWM等。 5.学习超声传感器相关知识，完成相关功能。 6.学习红外避障传感器，完成避障功能。 7.学习红外循迹传感器，完成循迹功能。 8.学习摄像头的使用，完成双线循迹。 9.根据已有传感器设计综合项目 (二)前期准备 根据老师提供的资料完成了小车的装配。 在装配小车的过程中我们发现小车有两块板子，主要控制部分为上面的树莓派板子，下面的板子和树莓派几乎没有关系（可能是因为学长学姐还车时没把线插好），在排查完后我们了解到下面的板子主要起到电机控制的功能，和其他部分关系不大，可以直接把传感器接在树莓派板子的GPIO口上。 2. 小车远程连接 这部分主要是小车Linux系统SSH和VNC远程连接配置的问题，在查阅相关资料以后得以解决。遇到的难题是把小车网络配置静态IP以后，每次不使用显示屏进行调试时，小车会自动连接默认WiFi。我们发现小车在路由器、手机、电脑构成的局域网下默认IP地址是不同的，以我们测试的设备为例：路由器192.168.1.x、电脑192.168.137.x、手机192.168.43.x，这与不同设备所能承载的最大连接数有关，所以在更换设备后会出现无法连接的情况。 GPIO和Linux操作指令的学习 这一部分主要是各自查阅资料进行学习，Linux系统不同于我们常用的Windows系统，它的绝大部分工作是靠命令行来完成的，这样简化了许多不必要的操作，保证了系统运行的稳定性。 小车引脚一共有40个，但不是所有引脚都可以作为IO口，经过查阅技术手册，我们得到了对应的引脚图。 小车的初步试运行 我们将小车安装完成以后进行了进一步的测试，主要是连接了小车与显示器，配置了远程连接，通过浏览器访问的方式测试了摄像头的状态，经过一系列的学习和初步调试，我们已经初步掌握了小车调试的方法，接下来就是进一步的工作。 二、调试过程 (一)摄像头模块 读入摄像头照片 123import cv2cap = cv2.VideoCapture(0)ret, frame = cap.read() 我们使用python中的opencv库读入摄像头数据，cv2.VideoCapture(0)中的参数0表示是系统默认的摄像头，ret为布尔值，true表示读取正常，frame为三维rgb矩阵。cv2.cvtColor(), cv2.threshold()将图像二值化为黑白图，一共进一步处理。默认像素640×480。 循迹核心代码 1234567891011121314151617for i in range(num_point): detect_height = height - 15 * (i+1) left_area = dst[detect_height, 0: half_width-1] right_area = dst[detect_height, half_width: width-1] left_line = np.where(left_area == 0) right_line = np.where(right_area == 0) if len(left_line[0])!=0: left_point[i] = int(np.max(left_line)) else: left_point[i] = 0 if len(right_line[0])!=0: right_point[i] = int(np.min(right_line)) else: right_point[i] = half_width - 1 left_max = np.max(left_point) right_min = np.min(right_point) 核心逻辑： i值为选取的行数，我们读取摄像头照片的后几行，每个间隔为15像素，然后取最值（避免噪声的干扰）。 将照片分为左右两部分，左边取像素为0的列坐标最大值，右边取像素为0的列坐标最小值，达到检测赛道的目的（蓝线）。 当小车行驶到将要转弯的地方时，（假设将要左转）那么此时左侧的赛道将会消失，取而代之的是右侧赛道检测值向左偏。 当检测到一侧赛道消失时，控制小车向这个方向转弯。而弯道的大小由另一侧偏离的量决定，将这个值传递给小车转弯控制函数作为参数，即可实现小车的实时控制。 3. 左右转函数 左右转函数在后面原理相同，只是参数不同，在此先叙述原理。 小车电机控制由四个端口输出的值来决定，将端口使能后，分别将其命名为pwm1-pwm4。经过测试我们发现，pwm1值不为0时，小车左边前后轮正转；pwm2不为0时，小车左边前后轮反转；pwm3值不为0时，小车右边前后轮正转；pwm4不为0时，小车右边前后轮反转。通过修改pwm1和pwm3的参数即可控制左右转的程度。 12345678910def right(left_distance): # 右转 pwm1.ChangeDutyCycle(max(50,min(left_distance,320)/5)) pwm2.ChangeDutyCycle(0) pwm3.ChangeDutyCycle(0) pwm4.ChangeDutyCycle(0)def left(right_distance): # 左转 pwm1.ChangeDutyCycle(0) pwm2.ChangeDutyCycle(0) pwm3.ChangeDutyCycle(max(50,min(right_distance,320)/5)) pwm4.ChangeDutyCycle(0) 内部min函数保证左右两边传入参数不大于320，除以5是为了和pwm的区间相对应；外部max函数保证即使传入参数很小，小车也可以以50%的占空比进行转弯，因为我们测试发现，当占空比很小时，小车由于阻尼比较大，无法正常前进，所以使用此方法保证可以行进。 (二)红外循迹模块 循迹原理 红外循迹传感器原理不用多说，无非就是没检测到黑线为低电平，检测到为高电平。 核心代码 123456789101112131415SR = gpio.input(RIGHT)SL = gpio.input(LEFT)# print(\"SR={},SL={}\".format(SR,SL))if (SL == 0 and SR == 0)or(SL == 1 and SR == 1): # 未检测到，直行 print(\"go1\") run()elif SL == 1 and SR == 0: # 左传感器检测到，左转 print(\"left\") left()elif SL == 0 and SR == 1: # 右传感器检测到，右转 print(\"right\") right()elif SL == 1 and SR == 1: # 两边同时检测到 print(\"go2\") run() 此代码逻辑很简单，即：左边检测到就往左转，右边检测到就往右转，两边都没有检测到就直行，两边都检测到也直行。 3. 使用的端口 GPIO.36 左红外传感 GPIO.32 右红外传感 （使用BOARD模式） 4. 遇到的问题 刚开始忘记强制上拉下拉引脚，导致刚开始出了问题，当右传感器一检测到就会停车，后来发现这是因为很多IO由于CMOS工艺问题会出现float的现象，所以不能悬空，需要PU或PD。对于红外引脚，未检测到障碍时为低电平，我们选择下拉，避免浮动。 使用语句： 12gpio.setup(RIGHT_infrare_sensor,gpio.IN,pull_up_down=gpio.PUD_DOWN)gpio.setup(LEFT_infrare_sensor, gpio.IN,pull_up_down=gpio.PUD_DOWN) (三)红外避障模块 避障传感器原理 原理也很简单无需赘述，有障碍为低电平，否则为高电平。 当时调试传感器比较费事，主要调节方法为：将传感器对着被测物体，物体和传感器的距离为想要的灵敏距离。将502可调电阻反时针调节到最大，将103电阻慢慢的旋转一圈直至led刚变亮 核心代码 123456789101112131415def hongwai(): #红外避障 while (1): SR = gpio.input(RIGHT_infrare_sensor) SL = gpio.input(LEFT_infrare_sensor) if SL == 0 and SR == 0: back() time.sleep(1) left() time.sleep(1) elif SL == 1 and SR == 0: left() elif SL == 0 and SR == 1: right() elif SL == 1 and SR == 1: run() 原理也相当简单：左边检测到向右转，右边检测到向左转，避开将要遇到的障碍物。当两边都没有检测到就直行。两边都检测到就先后退，执行一段时间的延时，然后再左转。 3. 使用的端口 GPIO.33，GPIO.35为左右传感端口。（BOARD模式） (四)超声波模块 超声测距原理 模块自动发送8个40khz的方波，自动检测是否有信号返回 有信号返回，通过IO口ECHO输出一个高电平，高电平持续的时间就是超声波从发射到返回的时间。 测试距离=（高电平*声速（340m/s）/2） 核心代码 123456789101112def disMeasure(): gpio.output(Trig,gpio.LOW) time.sleep(0.001) gpio.output(Trig,gpio.HIGH) time.sleep(0.001) while (gpio.input(Echo)!=1){ start=time.time() } while(gpio.input(Echo)!=0){ stop=time.time() } return (stop-start)*340/2 主要思想就是检测ECHO的时间从而得到模块与障碍物的距离，后面的逻辑可以根据这个距离进行判断是否应该规避。 实际测试中我们发现超声模块的效果很不好，经过查阅资料我们发现应该和温度传感器一起使用，以确定当时的具体声速，才能获得精确的距离，而且该超声模块比较廉价，精度本身就不高。 3. 使用的端口 超声模块占据引脚的38以及40端口，用于发送触发信号TRIG以及接收回声信号ECHO（BOARD模式） (五)语音识别模块 模块原理 LD3320A是一颗基于非特定人语音识别技术的语音识别/声控芯片。LD3320 芯片上集成了高精度的 A/D 和 D/A 接口，不再需要外接辅助的 Flash 和 RAM，即可以实现语音识别/声控/人机对话功能。并且，识别的关键词语列表是可以动态编辑的。 上面是抄说明书的，没什么用。 我们只需要知道： 模块基于C语言编写，可以识别自定义语句（无音调），可以控制IO口返回相应的高低电平，我们根据返回的三位二进制数解码出对应的指令，进行小车行为的控制。 核心代码 1234567891011121314151617181920212223242526272829303132333435363738394041def voice(): while(1): p1 = gpio.input(port1) p2 = gpio.input(port2) p3 = gpio.input(port3) function=4*p1+2*p2+p3 if function==6: run() print(\"run\") time.sleep(5) stop() time.sleep(3) elif function==5: back() print(\"back\") time.sleep(5) stop() time.sleep(3) elif function==4: left() print(\"left\") time.sleep(5) stop() time.sleep(3) elif function==3: right() print(\"right\") time.sleep(5) stop() time.sleep(3) elif function==7: stop() print(\"stop\") elif function==2: print(\"xunxian\") xunxian() elif function==1: print(\"bizhang\") hongwai() else: print(“wait\") 核心逻辑很好理解：定义function，将二进制翻译为十进制数，使用判断语句，找到对应的指令，进入相应的功能模块。 对应指令： 0：等待（空转默认状态） 1：红外避障 2：红外循迹 3：右拐 4：左拐 5：后退 6：前进 引脚设置 GPIO.7 ,GPIO.11 ,GPIO.13为传感器返回识别结果端口。 （BOARD模式） 三、成果展示 (一)主要成果 经过不断的调试，我们的小车不仅在自己的赛道上表现良好，在同学搭建的其他赛道（宽度、形状完全不同）也运行顺畅，仅需要根据具体赛道对参数做细微修正。 传感器的单独调试效果也很好，我们让每个传感器都物尽其用。 我们的综合功能设计也做得很好，在语音控制下可以做出前进、后退、左拐、右拐、循迹、避障等等行动。实现了完全的语音控制。 (二)视频展示 主要视频展示在答辩时已经进行过了，现附在附录文件夹中，完整版合集视频投稿在哔哩哔哩视频网，链接如下： https://www.bilibili.com/video/BV1Kp4y1x7Hu (三)课件汇报 主要为两部分，之前课堂汇报的课件和最终答辩的课件，具体内容也附在附件里面了。 四、主要承担的工作 作为大学本科阶段的最后一个实验，也是战线长达一学期的项目设计实验，我们小组展现了很好的团队精神。大家一起攻坚克难，一起想控制逻辑，一起调传感器，一起学习知识，一起调参。最终结果可能并不是最亮眼的，但是我们应该是没有遗憾了。 在这次项目设计实验中，我和其他四位同学一起商讨策略，一起完成任务，一起拓展创新，在过程中学到了很多。在后面主要负责小车调参、传感器功能实现和视频剪辑工作。熬过夜，扛着赛道到处找教室调车，也因为验收临时改赛道而心态爆炸。但是我们都坚持了下来，最后汇报呈现出来的结果可能不那么理想，但拼搏精神是最大的收获！","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Python","slug":"Python","permalink":"https://renzehua1998.github.io/tags/Python/"},{"name":"控制","slug":"控制","permalink":"https://renzehua1998.github.io/tags/%E6%8E%A7%E5%88%B6/"}]},{"title":"表达与交流","date":"2020-12-13T02:00:00.000Z","path":"2020/12/13/表达与交流/","text":"大四上表达与交流大作业和汇报slides 继续上学期女巫攻击的系列研究，被选中上台讲了讲。 大作业：论文 论文汇报：PPT PPT讲述练习：PPT","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Python","slug":"Python","permalink":"https://renzehua1998.github.io/tags/Python/"},{"name":"图与网络","slug":"图与网络","permalink":"https://renzehua1998.github.io/tags/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/"}]},{"title":"智能机器人实验报告","date":"2020-11-29T02:00:00.000Z","path":"2020/11/29/智能机器人实验报告/","text":"大四上NAO智能机器人实验报告 实验二 机器人舞蹈 一、实验目的 1、了解Nao人形机器人的关节构造及运动自由度； 2、了解基于关键帧（key frame）的 Nao 人形机器人动作设置方法； 3、了解基于时间轴的多线程编程方法； 4、掌握Nao人形机器人运动姿态控制编程； 二、实验内容 1、了解Nao人形机器人的关节构造及运动自由度； 2、基于关键帧（key frame）实现Nao机器人动作设置； 3、了解基于时间轴的多线程编程方法； 4、通过多线程设置Nao人形机器人舞蹈姿态与背景音乐； 5、实现Nao人形机器人与音乐协调的舞蹈演示； 三、实验设备 1、Nao人形机器人一台 2、路由器一台 3、笔记本电脑一台 4、Nao可编程软件一套 四、实验原理 Nao机器人所配置的Choregraphe软件提供了基于时间轴（time line）的多线程交互式机器人位姿设定与动作控制，通过关键帧（key frame）设定的方法，可以实现流程的机器人动作。图1给出了时间轴指令盒编程界面，图2给出了基于关键帧的方法进行机器人动作设置的说明。通过手臂部动作、腿部动作、音乐设置等多个线程协调工作，可以实现Nao机器人的舞蹈设计与实现。 图1 时间轴指令盒编程界面 图2 基于时间轴的关键帧动作设置 五、实验步骤 1、以无线方式连接 Nao 机器人； 2、基于Choregraphe软件创建时间轴（time line）指令盒； 3、建立多个线程，添加背景音乐； 4、配合音乐节奏，逐帧建立机器人的关键帧动作，注意关键帧之间留出足够的动作转换时间，避免机器人发生摔倒； 5、实现机器人舞蹈表演； 六、实验过程及功能实现 程序的整体实现流程如下：先是一个初始动作（Stand_Up），接下来等待一段时间（Wait）然后进入Time_Line指令盒。在Time_Line指令盒中，最上方动作层可以插入关键帧，包括单个部位或者全身，控制机器人的动作；在下方行为层，我们在一层加入了音乐，另一层使用指令盒在结尾加入了一个腿部自转的动作。Time Line指令盒中程序运行结束后再次执行站立动作（Stand Up），至此程序结束，完成舞蹈流程。舞蹈的核心程序部分是Time_Line。 图3 舞蹈程序总览 图4 音乐层展示 在进行舞蹈动作设计，对Time_Line动作层进行插入关键帧、设计机器人姿势的过程中，可以使用两种方法。其一是在机器人视图中，选择需要移动的部位，对要运动的关节输入所需的角度，改变机器人姿势。使用该方法我们可以较为精准的控制机器人的动作，尤其是对于一些对称性动作，我们使用相同的参数可以保证完美的对称性，但是该方法需要我们了解各个Nao机器人各关节活动的范围，否则就有可能出现输入越界、机器人自身动作发生冲突等问题。其二则是使用人工方式改变机器人动作。这种方式仅需要在电脑上解除机器人运动所需对应关节的自由度，然后人工扭转Nao机器人的各个关节，即可获得需要的动作姿势。该方法不需要完全了解机器人的关节活动范围等参数，但是由于是人工设计姿势的限制，它在精确性上不如第一种方法，仅能保证机器人大致运动到目标姿势。 在实验中，我们使用两种方法相结合的方式进行姿势设置。首先使用第二种方法，按照我们的姿势和动作设计，得到机器人大致的舞蹈动作。然后使用第一种方法，对需要保持对称或是不太完美的帧进行参数调整，使得机器人舞蹈动作更加精确。 图5 舞蹈动作帧展示 图6 舞蹈动作帧展示 七、实验思考题 1、对Nao人形机器人的动作控制及基于关键帧的编程方法进行总结； 对机器人的动作进行控制的时候，通过“机器人视图”，我们可以选择将它的各个关节进行解锁，然后用手进行动作的调整后上锁；或者利用坐标空间，在选择某个关节后直接输入要调整的数据进行调整。这两种控制方式在我们的实验中均有应用。 基于关键帧的编程方法的本质是在某个时间点保存机器人当前状态下各关节所处的坐标。可以分为对整个身体，仅头，仅手臂，仅腿进行保存，时间线上的每个小格代表一毫秒（在默认中框架率FPS为10）。两个保存的帧之间的时间差代表从这个动作到下一个动作所用的时间，如果时间间隔过小，而动作较为剧烈的话，很可能会影响机器人的稳定性，甚至使机器人跌倒。 2、对Nao人形机器人基于时间轴的多线程编程模式进行总结； Nao机器人的多线程表现在基于时间轴的编程中，存在多个行为层的并行行为，且多个行为层的线程可以同时被处理。 基于时间的编程主要包含在一段时间中Nao的动作变化，时间轴会依据时间来编排Nao机器人的动作。在基于时间轴的多线程编程模式中，主要分为动作层、行为层和编辑部分的设计。在动作层中，我们可以定义每个框架的动作样式，通过建立关键帧，包括单个部位或者全身，控制机器人的动作姿态。在这个阶段主要需要避免因两帧间隔过短、动作过大，导致机器人失去平衡的问题；在下方行为层，我们可以继续生成动作层和关键框架，关键框架有图表可以放置指令盒，用以执行其他任务指令。实验中，我们可以新建多个行为层，在执行动作层的同时，继续执行其他行为，比如进行背景音乐播放，为机器人的舞蹈动作进行配乐。而且在这个部分，我们也可以将之前预设的动作或者其他功能模块导入进行使用，作为动作层的一种补充。我们机器人最后的原地旋转和立正动作就是在行为层中完成的。对于编辑部分，我们在本次实验中并没有进行修改，但是该部分可以对动作播放的框架率（FPS），框架数量，以及播放模式等属性进行设定，修改这部分的参数对机器人的动作也会产生影响。 八、实验结果展示 九、实验体会 本次实验中，我们使用广播体操音乐对机器人进行了编舞。正如我前面所讲的，本次任务的核心是关键帧部分，这部分的工作也给我们留下的印象最深。我们也尝试过在行为层插入动作模块，但是只能添加预设的动作，因为我们想设置自己的动作，所以还是选择了在动作层插入关键帧。在建立关键帧的过程中，为了避免机器人摔倒。我们专门有一个队员在执行程序的时候扶着机器人，这才避免了在前期动作设置不合理的时候机器人不至于因失去平衡而跌倒，造成损坏。 从逐个动作的人工设计到关节参数的详细调整，从各帧动作的简单排列到伴着音乐的逐帧对应，可以说机器人编舞的过程工作量还是蛮大的。从动作的思考设计、再到插入关键帧实现动作、再到最终的当机器人成功舞蹈，我们了解了Nao机器人基于时间的编程模式，也掌握了一些指令盒的使用。当最终看到我们的机器人按照设想，随着音乐节拍做出动作的时候，我们心里还是成就感满满的。在感受到机器人带来的趣味与快乐的同时，也确实增进了对Nao机器的的了解，掌握了更多的相关知识，算是收获满满。 实验三 人脸识别 一、实验目的 1、了解 Nao 人形机器人的音频和视频传感器工作原理； 2、了解基于声音的目标定位方法； 3、了解基于图像的人脸识别方法； 4、掌握Nao人形机器人声源定位、人脸检测及人脸识别方法。 二、实验内容 1、了解Nao人形机器人的视觉及听觉传感信息基本处理方法； 2、实现主动人脸寻找、定位与识别记忆； 3、编程实现根据声音源寻找定位人脸，识别身份并进行语音交互。 三、实验设备 1、Nao人形机器人一台 2、路由器一台 3、笔记本电脑一台 4、Nao可编程软件一套 四、实验原理 Nao机器人配置有两个视觉传感器即摄像头，分别位于额头和下巴，两个摄像头各自有不同的观测范围，图1给出了Nao机器人的摄像头配置。通过调用摄像头可以获取Nao机器人看到的图像，从而利用图像处理的各种方法实现图像目标定位、识别、记忆等。Nao机器人还配备有4个麦克风，用于声音信号的拾取，图2给出了Nao机器人的麦克风配置。基于麦克风获取的声音信号，可以实现声源定位、语音识别功能。此外，Nao机器人还配备有两个扬声器，可以实现人机之间的语音交互。 图1 Nao机器人摄像头配置 图2 Nao机器人的麦克风配置 五、实验步骤 1、以无线方式连接Nao机器人； 2、编程实现声源定位及人脸检测； 3、编程实现人脸识别记忆，至少能够分辨两个不同身份人脸； 4、在人脸识别的基础上，编程实现识别到不同人脸时的不同语音交互。 六、实验过程及功能实现 1、人脸数据库建立 Nao机器人进行人脸识别的前提是人脸数据库不为空，若数据库为空，那必然无法正确识别人脸。在实验中，我们先使用Unlearn_All_Face指令清空人脸数据库，防止此前保存的人脸对新录入的人脸产生影响。此后，使用Learn_Face指令将需要识别的人脸存入数据库。在本实验中，我们录入了田瑞峰、郝世龙和任泽华同学的人脸，并将他们分别取代号为图图、健康哥哥和壮壮，为接下来的Nao机器人人脸识别功能做好准备。 图3 Nao机器人人脸数据库建立程序 2、人脸识别 Nao机器人的人脸识别方法主要依赖于Face_Reco脸部记录指令完成。该指令使用摄像头和数据库中的脸部数据来辨识脸部。脸部记录指令盒可以辨认出每张脸属于谁（如果数据库中有的话）。当脸部辨识成功，第二个输出端会输出脸的名字。当有数张脸被辨识出来，数据库中记录的名字会依序输出。 在进行识别后，我们首先使用Say_Text指令使机器人报出识别到的人脸代号，再使用一个Switch_Case分支，使机器人在识别到不同人脸后，执行不同的动作，以进一步标识不同的人脸识别结果。 此外，为保证人脸识别功能可以循环运行（非一次性识别），我们将执行完动作后的指令流返回到Face_Reco脸部记录指令盒,使人脸识别功能可以反复、持续运行。 图4 Nao机器人识别程序 七、实验思考 1、对Nao人形机器人的声源定位方法进行总结； 按照官方介绍，Nao使用4个麦克风来探测声音，声源定位功能帮助机器人辨别出声源方向。Nao的声源定位基于一个名为“到达时间差”的方法，当一个声源发出声音时，NAO的4个麦克风接受到声波的时间略有不同。如果一个人站在Nao左边和它说话，其声波会首先到达左侧麦克风，在几微秒后到达位于前方和后方的麦克风，最后到达右侧麦克风。这种时间差名为“双耳时间差”，可对其进行数学处理，以确定声源的位置。在Choregraphe软件中有相关的指令盒，可以调用并运行该功能。 但本实验中的声源定位似乎是与摄像头人脸追踪的程序存在冲突，因而始终未能实现。在我们的实验中，若Nao机器人的摄像头识别到一个人脸，那么其头部会始终跟随识别到的人脸进行转动，此时就算我们在程序中加入了声源定位指令Sound_Loc(提供角度和置信度)或是Sound_Tracker（根据输入，头部转向），Nao机器人也不会执行声源定位任务。 在调试过程中，当我们将Camera_select部分的Python代码进行修改，将摄像头选择参数修改为1，强行停止摄像头的工作，此时发现Nao机器人可以顺利执行声源定位指令。但这样一来，摄像头由于停止工作，又无法进行人脸识别工作。所以通过调试，我们认为可能是默认执行的人脸跟随功能阻止了声源定位的执行。 2、对Nao人形机器人的人脸检测方法进行总结； 脸部检测指令盒(Face_Detection)会使用摄像头来检测脸部及产生辨别人数，在执行该指令的过程中，实际调用的是Nao机器人中ALFaceDetection的视觉API模块，人脸检测被定义为该API中的一个事件FaceDetected()。 在该部分中，Nao机器人通过两个摄像头进行图像采集，然后将用分类器所检测出的区域图像与模板图像进行匹配，将所得到的相似度值与预设阈值进行比较，相似度大于阈值的判断为是目标，小于阈值的判断为非目标，并在程序中使用FaceID标注检测到的不同人脸。注意，按照Nao机器人官方文档说明，需要保证摄像头捕捉到的脸部在图像中至少为20像素，否则会检测失败。 我们在实验中使用脸部检测指令盒(Face_Detection)时，内部检测盒会从内存中读取FaceDetected()的返回值FaceInfo，得到检测到的人脸信息（如FaceID等），进而输出检测到的人脸数量。从我们API使用者的视角上看，也就是在脸部检测指令盒(Face_Detection)的输出端直接输出检测出的人脸数目。当然，在指令盒输出侧还有另一个输出，它在没有检测出脸部的时候会被启动，用来结束检测过程。 3、对Nao人形机器人的人脸识别方法进行总结； Nao机器人的人脸识别方法主要依赖于Face_Reco脸部记录指令盒完成。而该指令盒和脸部检测指令和一样，调用的是Nao机器人中ALFaceDetection的视觉API模块。而且在进行人脸识别的过程中，需要以人脸检测事件FaceDetected()为基础。 正如我前面提到的，FaceDetected()对每个被检测的脸，都会在返回值中返回一个关键信息——FaceInfo。在FaceInfo中，存储了FaceID、脸部长宽、脸部轮廓、scoreReco、faceLabel等关键信息。人脸检测过程中，scoreReco是识别过程返回的分数（越高越好），在识别过程前设置置信度阈值，若识别分数大于设定阈值大小，程序判定识别成功，会在faceLabel中标注已识别脸部的名称。否则识别失败，认为检测到的人脸并不存在于数据库。 注意到，在识别过程中，每个检测到的人脸都会被赋予0到1之间的匹配分数。分数越高，表示确定性越高。我们可以通过调节阈值的方式，使人脸识别的要求变得更加放松或是更加严格。较低的阈值意味着模块经常返回结果，但结果可能是错误的。较高的值表示仅考虑具有较高确定性的匹配项，从而降低了出错的风险，但可能很难获得任何结果。 在实际的功能实现时，我们直接调用了Face_Reco脸部记录指令盒，该指令使用摄像头和数据库中的脸部数据来辨识输入的人脸。从流程上看，该功能首先进行人脸的检测，在存在人脸的情况下，可以将检测到的人脸与数据库人脸进行比对，辨认出每张脸属于谁（如果数据库中有的话）。当脸部辨识成功，输出端将输出脸的名字。当有数张脸被辨识出来，数据库中记录的名字会依序输出。 此外，使用Nao机器人进行人脸识别时也有注意事项。按照官方文档说明，在识别过程中，摄像头捕捉的人脸图像至少要20个像素。而且文档还强烈建议最小尺寸为40像素，以获得更好的学习和识别效果。 八、实验结果展示 九、实验体会 通过本次实验，我们熟悉了人脸检测和人脸识别的功能。在实验过程中，我们的确希望能够完成人脸识别+声源定位两部分功能，但是似乎Nao机器人内嵌的人脸追踪程序与声源定位存在矛盾，所以最终确实没有同时实现。 在建立人脸数据库的同时，由于机器人始终在进行人脸追踪，所以换下一位同学记录人脸的时候经常会记录失败，而上一位同学由于被摄像头追踪，人脸被反复记录。这样看，我们采用一个程序记录人脸的方式在操作性上确实较差，后续改进可以考虑通过每次只记录一张人脸，让学习部分的程序单次运行三次的方式进行人脸记录，提高建立数据库这部分功能的稳定性。在后续的人脸识别任务中，我们使用Face_Reco脸部记录指令盒顺利的完成了识别任务，也感受到了Nao机器人的趣味与功能的强大，Nao机器人的种种功能，真的是给我们带来了许多惊喜与快乐，给我们也留下了深刻的印象。 当然，最后的遗憾就是没有完成声源定位，这个任务困扰了我们至少两节课，尝试了各种可能的办法都没有将它与人脸识别功能完美结合，还是有些不甘心。在与其他组同学的交流中，发现大家都没有完成这一部分，所以感觉这应该还是一个很有趣、也很有挑战的任务，但是限于实验已经结束，可能对这个问题的思考和探索也只能留到以后了吧。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"控制","slug":"控制","permalink":"https://renzehua1998.github.io/tags/%E6%8E%A7%E5%88%B6/"}]},{"title":"生命科学基础实验报告","date":"2020-11-28T04:00:00.000Z","path":"2020/11/28/生命科学基础实验报告/","text":"大四上生命科学基础实验报告：生物大分子+小鼠解剖 生物大分子结构模拟 一、核小体Nucleosome结构的观察： 核小体由DNA和蛋白质构成，其中DNA围绕在蛋白质的外围。DNA双链结构经过进一步盘曲折叠，形成螺旋状的二级结构，盘曲旋转形成一个中空的管道。DNA链内部是蛋白质分子，其主要结构为α螺旋，几个蛋白质亚基填充其中，起到支撑、维持核小体结构的作用。 二、猪圆环病毒衣壳（Porcine Circovirus）结构的观察 猪圆环病毒衣壳呈现正十二面体的结构，其中每个蛋白质亚基结构相同，在空间上形成了完全对称的结构，它内部包裹着病毒的遗传物质进行传播。 三、比对不同物种肌红蛋白Myoglobin的结构 马（红色）和人（青色） 马的肌红蛋白是红色，人的肌红蛋白是蓝色，不同的是，在该蛋白的一头，马的肌红蛋白比人类的更长，多出来一节细长的肽链。同时，在画面的右下角，两者在细长的圆环位置有细微的不同，在画面的其他部分重合较号，但是这一部分形成了错位。由此我们可以看出不同物种的肌红蛋白有着细微的不同，正是这种不同形成了不同物种的不同形态，造就了它们不同的适应环境的本领。 四、标记显示辣椒素受体TRPV1的511和550位的突变 使用标记法标出TRPV1的511和550号位点的突变，使用与原始蛋白不同的表示，用不同的对比和视角分别展示。 辣椒素受体的突变位点在蛋白质结构的内部，使用更近一些的视角可以看出，辣椒素受体的突变位点位于α螺旋的末端，这一点对我们的研究也有一定的启示。 五、选择一条序列（A/B/C/D），利用SWISS-MODEL进行结构预测并观察 我们择的是序列C，预测出两条序列：序列 1和序列2 从中可以看出，序列1比较复杂，由6个α螺旋构成，整体呈现一个近似球形的结构；序列2比较简单，也是由6个α螺旋构成，整体呈现一个L型的结构。 六、Spike Glycoprotein (S)结构观察与比较 蓝色：SARS 红色：2019 n-Cov 调节为大致为相同的角度，可以看出二者的结构大致相同，不同的是SARS左上角的β折叠结构比较小而2019 n-Cov的这部分结构比较大。 小鼠解剖实验报告 一、实验目的、意义 实验目的： （1）掌握小鼠解剖的基本操作方法。 （2）了解小鼠的生理构造和器官分布。 实验意义： 小鼠具有体型小、易饲养、繁殖快、控制标准成熟等特点，是生命科学研究中常用的实验动物品种。因此，了解小鼠的生理构造和器官分布在生物、医学及相关实验开展中具有重要的基础作用和实际意义。 二、实验器材、试剂 器材： 注射器，烧杯，解剖剪，棉球，镊子，图钉，解剖盘，等等。 试剂： 乙醚，氯化钠，等等。 三、实验步骤 小鼠的抓取与固定 一名同学手提起来小鼠尾部，将其放在解剖台上，拉住尾巴，另一名同学用两指捏住小鼠的两耳后颈部。 小鼠的处死 采用颈椎脱位法，一名同学按住小鼠后颈部，另一名同学抓住尾巴用力向后拉，造成小鼠死亡。 小鼠的解剖 ① 处死小鼠后，用夹子固定四肢。 ② 从外生殖器前缘剪开腹腔，再向上剪开胸腔，观察并取出胃、肝、脾、肾、心、肺等器官。 ③ 将小鼠翻过来，剪开后脑皮肤，使用解剖剪撬开头盖骨，观察并取出大脑 脏器的观察 将取出的脏器用纯水涮洗，放置在生理盐水中浸泡，并放于冰块中，最后全部取出观察拍照 台面的清理 将小鼠尸体与脏器放入专门的回收袋中，清洁台面 四、实验结果 器官照片，从上到下从左到右以此为： 胃、肺、脑、心、肝、脾、肾 器官在体内的分布位置简要说明。 胃：在腹腔的最上方，上与食道相连，下与十二指肠相连 肺：在胸腔内部，占大部分空间 脑：在头颅中，被头盖骨保护 心：在胸腔，被肺所包围 肝：在腹腔上部，占据绝大部分空间 脾：在胃的左下侧 五、作业题 简要描述解剖的器官(心脏、肝脏、脾脏、肺、肾、胃、脑)的形态特征。 （1）肺：右肺分为四叶，左肺为一整叶。呈现淡粉色，密度很小，可飘在水面上。 （2）心：呈锥状，心上方有白色的胸腺。呈现深红色，刚解剖时心脏仍在跳动。 （3）胃：呈淡粉色扩大囊状，上与食管相连，下与十二指肠相连。 （4）肝：呈暗褐色，分为四叶。 （5）脾：呈暗红色长条扁平状。 （6）肾：呈紫红色豆状，下端连有输尿管。 （7）脑：大脑包括左右大脑半球，下与颈椎相连。 通过本实验你掌握了那些实验技能？ 掌握了小鼠抓取、处死、固定、解剖、清理仪器等技能；克服了心理上的不适；深入了解了小鼠的解剖结构，为以后的研究奠定了基础。 3.哺乳类适于陆生生活的形态结构特征有哪些？ 门齿像凿形，臼齿发达，消化系统发达，消化腺发达，盲肠粗大，有消化纤维的作用","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}]},{"title":"大数据作业2——k-means算法","date":"2020-11-25T04:00:00.000Z","path":"2020/11/25/大数据大作业2/","text":"大四上大数据分析与知识发现大作业——k-means算法 本报告主要工作：本次大作业使用python自己编程实现了k-means算法，主要介绍了算法流程，对用到的数据集进行了简要介绍，除了距离度量之外，调整不同K值情况下，衡量了聚类每一个结果簇的密度。 代码运行环境为Python 3.7.4，IDE为Pycharm，所有代码均为自己编写。参考书籍：《数据挖掘概念与技术》（原书第二版）、《机器学习实战》。 一、聚类的简要介绍 聚类：将实际或者抽象的集合组成多个类的过程。 聚类算法的常见要求有：可伸缩性、处理不同类型数据的能力、发现任意形状的能力、降噪能力、用于决定输入参数的领域知识最小化、输入顺序不敏感、高维度、基于约束聚类、可解释性和可用性等等。 它与分类最大的不同是，分类会提前指定分类数目和类别名称，聚类不会指定类别名称，甚至不会指定类别数目。不过在本次实验中的k-means算法必须指定聚类数目k，这个k被作为聚类算法中的先验知识使用。 二、算法流程 k-means算法属于无监督学习的一种聚类算法，其目的为：在不知数据所属类别及类别数量的前提下，依据数据自身所暗含的特点对数据进行聚类。对于聚类过程中类别数量k的选取，需要一定的先验知识，也可根据“类内间距小，类间间距大”（一种聚类算法的理想情况）为目标进行实现。 k-means算法以数据间的距离作为数据对象相似性度量的标准，因此选择计算数据间距离的计算方式对最后的聚类效果有显著的影响，常用计算距离的方式有：余弦距离、欧式距离、曼哈顿距离等。 本次实验中选用欧氏距离，其基本公式为： 其基本算法流程伪代码为： 随机选取k个初始质心（作为初始cluster）； repeat： ——对每个样本点，计算得到距其最近的质心，将其类别标为该质心所对应的cluster； ——重新计算k个cluser对应的质心； until 质心不再发生变化 k-means存在缺点： k-means是局部最优的，容易受到初始质心的影响；比如在下图中，因选择初始质心不恰当而造成次优的聚类结果（SSE较大）： 同时，k值的选取也会直接影响聚类结果，最优聚类的k值应与样本数据本身的结构信息相吻合，而这种结构信息是很难去掌握，因此选取最优k值是非常困难的。 三、数据集简要介绍 UCI数据集作为一个标准测试数据集经常被用来训练机器学习的模型，广泛出现在机器学习的论文中。在此我们使用了UCI数据集中的two_cluster、three_cluster、five_cluster三个不同簇数的点集，它们都是二维数据，便于可视化观察。 为了结果变得有趣，我们还使用了真实测量的wine数据集，这些数据是对来自意大利同一地区但来自三个不同品种的葡萄酒进行化学分析的结果。分析确定了三种葡萄酒中每种所含13种成分的数量。其中13个属性分别为： 1）酒 2）苹果酸 3）灰 4）灰的碱度 5）镁 6）总酚 7）类黄酮 8）非黄酮酚 9）原花青素 10）色彩强度 11）色调 12）稀释酒的OD280 / OD315 13）脯氨酸 四、实验结果 1.two_cluster k=2 2.three_cluster k=3 3.five_cluster k=5 4.wine数据集 k=3 在一次测试中，迭代循环5次。 三个聚类中心点坐标为： [1.25166667e+01 2.49420290e+00 2.28855072e+00 2.08231884e+01 9.23478261e+01 2.07072464e+00 1.75840580e+00 3.90144928e-01 1.45188406e+00 4.08695652e+00 9.41159420e-01 2.49072464e+00 4.58231884e+02] [1.38044681e+01 1.88340426e+00 2.42617021e+00 1.70234043e+01 1.05510638e+02 2.86723404e+00 3.01425532e+00 2.85319149e-01 1.91042553e+00 5.70255319e+00 1.07829787e+00 3.11404255e+00 1.19514894e+03] [1.29298387e+01 2.50403226e+00 2.40806452e+00 1.98903226e+01 1.03596774e+02 2.11112903e+00 1.58403226e+00 3.88387097e-01 1.50338710e+00 5.65032258e+00 8.83967742e-01 2.36548387e+00 7.28338710e+02] 都是13维向量。 （聚类结果比较庞大不便于展示，下面是部分截图） 第一列是种类编号，0~2三种；第二列是与聚类中心点的距离。 五、 调整不同k值情况下，结果簇密度 此次使用wine数据集来举例说明。 1. 轮廓系数 首先我们使用轮廓系数来衡量结果簇密度： 轮廓系数（Silhouette Coefficient），是聚类效果好坏的一种评价方式。 轮廓系数的值是介于 [-1,1] ，越趋近于1代表内聚度和分离度都相对较优。 a：某个样本与其所在簇内其他样本的平均距离 b：某个样本与其他簇样本的平均距离 则针对某个样本的轮廓系数s为： 聚类总的轮廓系数SC为： 分别采用k=2，3，4，5，6来进行实验： k 轮廓系数 2 0.6555165156460525 3 0.5711220218877621 4 0.5577126423216353 5 0.5081523788793872 6 0.5198737583976687 说明在此条件下分两类轮廓系数最大。 2.均值和方差 簇密度衡量采用以下两个指标：平均距离、距离的方差。 平均距离越大说明簇越大，方差越大说明簇密度越小 分别采用k=1，2，3，4，5来进行实验。 k 平均距离 距离方差 1 [413.72368779034764] [221.24947931661688] 2 [123.09435513723407, 157.4466947804894] [75.56317450732195, 105.68405292728465] 3 [82.69643456704392, 142.0457556870106, 68.87463704313525] [47.9537891109816, 93.6984317794299, 40.97548621196613] 4 [104.82235926873521, 59.349722824078796, 88.96909761169158, 59.98844301237363] [80.53919889877352, 35.24233250616651, 39.80030928690068, 34.23786395437574] 5 [59.01909723610794, 45.67869656758982, 48.62669527451465, 104.2003462385525, 68.32061555316555] [31.912851937637157, 22.550061590085217, 28.69038482660511, 72.61053918190882, 43.829622606222365] 从上述表格可以看出，随着k值的增大，平均距离和距离方差都在减小，这也很好理解，随着聚类粒度的减小，每个聚类簇的大小必定会有所减小，而这样就会导致每个簇中节点相似度提高，簇密度增大。 附录（源代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import numpy as npimport matplotlib.pyplot as pltfrom sklearn import metrics# 导入数据def loadData(fileName): dataset = np.loadtxt(fileName) n = len(dataset) # 计数，用于去除第一个值 data = [[] for i in range(n)] for i in range(n): line = dataset[i, 1:] data[i] = line data = np.array(data) return data# 计算欧式距离def euclid(x, y): return np.sqrt(np.sum((x-y)**2))# 随机生成k个聚类中心def randomK(dataset, k): m, n = dataset.shape # 获取数据集维度与个数 centers = np.zeros((k, n)) for i in range(k): centers[i, :] = dataset[np.random.randint(0, m), :] return centers# k-means算法def kmeans(dataset, k): m, n = dataset.shape mark = np.zeros((m, 2)) # 存放当前点的类别（距离最近的中心标号）与距离量 centers = randomK(dataset, k) # 随机生成聚类中心 haveChange = True # 经过一次迭代有节点所属类别有变化 index = 0 while haveChange: index += 1 print('迭代第', index, '次') haveChange = False for i in range(m): # 遍历每个点 typeIndex = -1 # 当前类别 minDis = float('inf') # 与最近中心的距离 for j in range(k): # 遍历每个中心 dis = euclid(dataset[i], centers[j]) if dis &lt; minDis: minDis = dis typeIndex = j mark[i, 1] = minDis # 更新距离 if mark[i, 0] != typeIndex: # 如果类别有变化，更新类别 haveChange = True mark[i, 0] = typeIndex for j in range(k): # 更新中心 cluster = dataset[np.nonzero(mark[:, 0] == j)[0]] centers[j] = np.mean(cluster, axis=0) return centers, mark# 衡量每个簇的距离均值def meanError(mark, k): result = [0 for i in range(k)] for i in range(k): result[i] = np.mean(mark[np.nonzero(mark[:, 0] == i)[0], 1]) return result# 衡量每个簇的距离方差def stdError(mark, k): result = [0 for i in range(k)] for i in range(k): result[i] = np.std(mark[np.nonzero(mark[:, 0] == i)[0], 1]) return result# 画图展示（仅限二维）def plotResult(dataset, centers, mark): m, n = dataset.shape k = len(centers) dotType = ['or', 'ob', 'og', 'ok', '^r', '+r', 'sr', 'dr', '&lt;r', 'pr'] # 点的类型 centerType = ['Dr', 'Db', 'Dg', 'Dk', '^b', '+b', 'sb', 'db', '&lt;b', 'pb'] # 中心类型 if n &gt; 2: print('数据大于二维，无法绘制') return 1 if k &gt; len(dotType): print('类别过多无法区分') return 1 for i in range(m): # 画样本点 index = int(mark[i,0]) # 类序号 plt.plot(dataset[i,0], dataset[i,1], dotType[index]) for i in range(k): # 画中心点 plt.plot(centers[i,0], centers[i,1], centerType[i]) plt.show()fileName = 'wine.txt'data = loadData(fileName)print(data)k = 3 # 聚类数centers, mark = kmeans(data, k)print(centers,'\\n', mark)plotResult(data, centers, mark)mean_error = meanError(mark, k)std_error = stdError(mark, k)print(mean_error, '\\n', std_error)print(\"轮廓系数：\", metrics.silhouette_score(data, mark[:, 0], metric='euclidean'))# print(mark[np.nonzero(mark[:, 0] == 0)[0], 1])","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Python","slug":"Python","permalink":"https://renzehua1998.github.io/tags/Python/"},{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://renzehua1998.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"}]},{"title":"大数据作业1——apriori算法","date":"2020-11-05T04:00:00.000Z","path":"2020/11/05/大数据大作业1/","text":"大四上大数据分析与知识发现大作业——apriori算法 本报告主要工作：本次大作业使用python自己编程实现了apriori算法，并分别从分布式实现和事务压缩处理的角度进行了算法优化。从中医药网站爬取了两万多条药方作为数据集，用来挖掘各种中药材之间的关联规则，分别使用不同的支持度、置信度进行实验，取得了比较有趣的结果。同时也使用老师给的百货商店数据集进行了测试。 代码运行环境为Python 3.7.4，IDE为Pycharm，所有代码均为自己编写。参考书籍：《数据挖掘概念与技术》（原书第二版）、《机器学习实战》。 一、 关于关联规则的简要介绍 要介绍关联规则，首先要引入两个概念：事务和频繁项集。 事务：数据集中的一条内容，可以是一次消费的购买记录，也可以是一次测量的返回结果，或者是一个药方中的药品。可以理解为与某个事情相关的名词的集合。 频繁项集：要想介绍频繁项集，首先要介绍“项集”。顾名思义，“项集”就是项的集合，项就是每一条事务中的一个名词，可以代表一个物品或者一个事件。“频繁项集”就是在数据集中频繁出现的项集，即一种频繁的模式，这个项集可大可小，依据其在数据集中出现的频率而判断是否为频繁项集。 而关联规则是基于这二者进行计算的，它的基本定义为： 关联规则：两个项集之间所具有的某种相关关系，其紧密程度由支持度和置信度来衡量。我们将关联规则中前面的项集叫做前件，后面的项集叫做后件，规则的含义可以表示为：前件出现，后件将有很大概率出现。 下面介绍衡量关联规则的两条准则：支持度与置信度。 支持度：一个项集的支持度被定义为数据集中包含该项集的记录所占的比例 置信度：两个项集之间关联规则紧密程度的置信度可以理解为前后件的并集所代表的项集的支持度与前件支持度的比，即：出现前件的条件下出现后件的概率。 二、Apriori算法主要流程 为了寻找频繁项集，就必须计算每个项集的支持度，当事务中项的数目很多时，它们之间互相的排列组合就变得及其复杂。当数据集庞大时，每个事项的检测都包含的大量的比对和筛选，算法复杂度变得很高，计算时间成本极大。 为了解决这个问题，我们提出了apriori原理：如果某个项集是频繁项集，那么它所有的子集也是频繁的。即如果 {0,1} 是频繁的，那么 {0}, {1} 也一定是频繁的。这个规则看似直观，但需要经过极为严格的证明，所幸前人已经为我们证明好了这个定理。乍一看它似乎没什么用，但是把这个定理反过来，它的逆否命题为：如果某个项集非频繁，那么它的超集也非频繁。那么我们就可以在由小项集组合大项集时提前筛掉那些不频繁的项集，从而大大减少计算量。 算法的主要步骤为： 寻找频繁项集 ① 扫描整个数据集获取所有单个名词的项集列表——候选1-项集。 ② 扫描数据集计算每个候选1-项集的支持度，删除不满足最小支持度的项集，形成频繁1-项集，此时k=2。 ③ 对此时的频繁（k-1）-项集进行组合，形成候选的k-项集。若k-项集为空，退出。 ④ 扫描数据集计算每个候选k-项集的支持度，筛选出符合条件的k-项集，形成频繁k-项集。返回第三步。 寻找关联规则 使用递归的方法，遍历所有大于1的频繁项集，求取它们的1项集子集： —如果是频繁2项集： ——使用差集的方法计算置信度，符合的关联规则直接输出。 —或者项集中项数大于等于3： ——如果子集可以继续组合成能生成其他规则的新子集：（1） ———子集进行组合，测试新生成的规则是否满足条件，符合的直接输出。 ———如果还可以继续组合，递归调用（1） ​ 否则： ———继续遍历下一个项集 一些优化方法： 使用分布式的方法，将数据集分为多个块，在遍历数据集时利用python中的map函数，将比较统计的部分分开进行，再使用reduce函数整合每个块统计的结果，形成最终的答案。这对大规模数据集比较适用。 使用事务压缩的方法，在遍历数据集时，如果某个事务已经不包含当前的频繁k-项集，那么它们必然不包含由这频繁k-项集组成的候选k+1-项集，那么在下一次遍历时就可以跳过这些事务，不必再进行子集计算，节省了运行时间。这对大部分情况都比较适用。 三、 所采用的数据集简介 中医药的理论博大精深，各种药材之间的配合在治病的疗效上会起到1+1&gt;2的效果。比如茯苓和人参搭配，具有益心力，除谬忘，能饮食，延年益寿之功效。主治上气，胸胁满闷，霍乱，积痢。其他的相似组合还有很多，进行关联规则的发现可以帮助我们更系统地归纳古人留下的药方中的知识，便于将中医药应用于现代疾病的治疗中。 所用我从某中医网站爬取了2万多条药方的数据，作为待挖掘的数据集，意在找出哪些药材之间的关联规则比较大，哪些药材常常出现并且被搭配使用在药方当中。爬取数据集的代码放在crawler.py文件中，2万条药方的网址已经提前爬出可以直接导入进行读取，节省时间。（url.csv） 中医网站页面（网址：http://zhongyaofangji.com/all.html） 药方详细页面 数据集展示（prescription.csv） 四、 实验结果分析 （1） 三种方式运行时间比较 选取prescription.csv药方数据（2万余条），最小支持度和最小置信度都为0.01 不同改进算法的运行时间比较表 运行时间 第一次 第二次 第三次 第四次 第五次 平均值 基本算法 36.0405 35.8101 34.1877 35.9658 33.7644 35.1537 分布式 34.2813 33.9013 34.2965 34.5172 34.3388 34.26702 事务压缩 31.0910 32.0156 31.2278 31.0221 31.6232 31.39594 从运行时间可以大致看出，分布式算法由于使用mapreduce并行执行，运行时间略有减少，但是并行运行会占用更多的内存，分布式的主要用处是在数据集过大无法全部导入内存时可以进行计算，在节省时间方面不是主流。而基于事务压缩的方法可以避免多次无用的遍历，所以在时间节约上也比较明显。 （2）修改支持度、置信度的结果 不同支持度、置信度比较表 置信度 支持度 0.01 0.05 0.1 0.2 0.3 0.4 0.01 频繁项集 419 419 419 419 419 419 关联规则 679 648 515 288 156 88 运行时间 30.6290 33.8207 32.0566 30.7340 31.0242 30.5041 .015 频繁项集 207 207 207 207 207 207 关联规则 255 255 219 139 82 51 运行时间 19.0702 20.9975 18.1798 18.6537 18.4798 18.5693 0.02 频繁项集 126 126 126 126 126 126 关联规则 119 119 113 79 48 31 运行时间 14.9484 14.8706 14.7600 14.6400 14.8406 14.9926 0.03 频繁项集 59 59 59 59 59 59 关联规则 36 36 36 29 21 15 运行时间 11.9174 11.9613 12.1243 12.0313 12.0253 11.8591 0.04 频繁项集 38 38 38 38 38 38 关联规则 22 22 22 18 13 10 运行时间 11.3005 11.3198 11.2225 11.3224 11.0737 11.3320 0.05 频繁项集 23 23 23 23 23 23 关联规则 10 10 10 10 7 6 运行时间 10.7939 11.0177 10.8461 10.9094 10.7684 10.7101 0.06 频繁项集 15 15 15 15 15 15 关联规则 4 4 4 4 2 2 运行时间 10.7497 10.5669 10.6482 10.7804 10.6141 10.6488 从上表可以看出： 支持度相同，最小置信度越高，关联规则数越少； 置信度相同，最小支持度越高，频繁项集数越少； 运行时间和最小支持度关系最大，最小支持度越大，运行时间越短； 关联规则的挖掘几乎不会影响到运行时间，因为比较的频繁项集数量级都很小； 随着最小支持度的增大，最小置信度的变化对发现的关联规则数量的影响减小； 最小置信度变化幅度不大时对发现的关联规则数目影响不大； 频繁项集和支持度的相关关系是非线性的，在某一区间内变化很明显。 （3）挖掘出的有趣规则 支持度、置信度均为0.01时前25项挖掘出的关联规则 我们随机取其中的五条：没药-&gt;乳香；川芎-&gt;当归；柴胡-&gt;甘草；熟地-&gt;当归； 荆芥-&gt;防风。在搜索引擎中分别搜索这几种组合。 可以看出挖掘出的关联规则中的药物都有着很深的关系，至少人们经常把它们放在一起作为药方。 测试该条件下置信度最弱的一条关联规则：甘草-&gt;桂枝 即使是预设条件下关联规则最弱的一条也可以在网上找到相应的搭配，可见我们挖掘出的关联规则在统计意义下是有效的。 我们也注意到，在挖掘出的关联规则中，经常出现的中药材有甘草、人参、当归、白术、白芍、川芎等等，我们搜索中药方中最常用的药材： 相关的内容也几乎匹配。 （4）使用老师提供的百货商店数据集挖掘出的一些规则 支持度、置信度均为0.01时前25项挖掘出的关联规则 对上述关联规则进行一定的分析可以发现一个比较有趣的事情：美国人在购物时比较偏爱“whole milk”，即全脂牛奶，在购买黄油、凝乳、鸡蛋、糖、汉堡肉、蔬菜等等食物之后都偏爱购买牛奶，这与他们的生活习惯不无关系。搜索相关内容也会发现类似的报道。 附录（源代码） 1. 基本Apriori算法代码：（basic.py） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142from numpy import *from csv import readerimport time# 导入数据集def load_dataset(fileName): with open(fileName, 'rt', encoding='UTF-8') as raw_data: readers = reader(raw_data, delimiter=',') dataset = list(map(frozenset, readers)) return dataset# 以下为挖掘频繁项集相关函数# 统计所有1-项集def get_one_itemset(dataset): itemset = [] # 1-项集 for affair in dataset: # 遍历一遍数据集统计项集个数 for item in affair: if [item] not in itemset: itemset.append([item]) return list(map(frozenset, itemset))# 通过候选k-项集的筛选，确定频繁k-项集# 输入：数据集，候选k-项集，最小支持度； 输出：频繁k-项集列表，支持度字典def get_freqset(dataset, itemset, minSupport): supportData = {} # 支持度字典 count = {} # 计数字典 freqset = [] # 频繁k-项集 for affair in dataset: # 遍历数据集计算候选项集频次 for item in itemset: if item.issubset(affair): # 如果候选项集是事务的子集，计数+1 if item in count: count[item] += 1 else: count[item] = 1 number = len(dataset) # 事务的数目 for key in count: # 遍历计数字典筛选符合条件的项集作为频繁项集，计算支持度 support = count[key]/number if support &gt;= minSupport: freqset.append(key) supportData[key] = support return freqset, supportData# 由频繁k-项集求候选k+1-项集# 输入：频繁k-项集，项集中的项数k； 输出：候选k+1-项集def get_itemset(freqset, k): itemset = [] # 候选k+1-项集 freqlen = len(freqset) # 频繁项集个数（用于遍历） for i in range(freqlen): # 遍历候选项集组合新项集 for j in range(i+1, freqlen): item = freqset[i] | freqset[j] if len(item) == k and item not in itemset: # 项数为k且之前未出现 itemset.append(item) return itemset# 挖掘所有满足条件的频繁项集# 输入：数据集，最小支持度； 输出：频繁项集列表、支持度字典def get_all_freqset(dataset, minSupport=0.001): # 最小支持度默认0.001 C1 = get_one_itemset(dataset) L1, supportData = get_freqset(dataset, C1, minSupport) print('已经挖掘频繁', 1, '项集...') freqset = [L1] k = 0 while len(freqset[k]) &gt; 0: # 循环，直到挖掘完毕所有的频繁项集（最后一项为空） Ck = get_itemset(freqset[k], k+2) # 求候选项集 Lk, support = get_freqset(dataset, Ck, minSupport) # 求频繁项集和支持度字典 freqset.append(Lk) supportData.update(support) k += 1 print('已经挖掘频繁', k+1, '项集...') return freqset, supportData# 以下函数为挖掘关联规则相关函数# 测试筛选符合最小置信度的关联规则# 输入：频繁项集、频繁项的子集列表、支持度字典、规则集合、最小置信度； 输出：符合最小置信度条件的频繁项子集列表def test_rule(freqset, subset, supportData, rules, minConfi): trueSubset = [] for item in subset: # 测试每一个子集与对应项集生成的规则是否满足条件 confi = supportData[freqset]/supportData[freqset-item] if confi &gt;= minConfi: # 满足条件即加入规则库 rules.append((freqset-item, item, confi)) trueSubset.append(item) return trueSubset# 递归地遍历各种可能的规则组合，从单元素子集开始构建多元素子集来划分项集生成规则，不满足最小置信度的频繁项子集不参与新子集的构建# 输入：频繁项集、频繁项的子集列表、支持度字典、规则集合、最小置信度def form_subset(freqset, subset, supportData, rules, minConfi): itemNum = len(subset[0]) # 求子集元素个数，用于判断是否迭代 if len(freqset) &gt; (itemNum+1): # 子集可以组合形成可以生成完整规则的新子集 newSubset = get_itemset(subset, itemNum+1) # 子集进行组合 newSubset = test_rule(freqset, newSubset, supportData, rules, minConfi) if len(newSubset) &gt; 1: # 还可以继续组合 form_subset(freqset, newSubset, supportData, rules, minConfi)# 求关联规则# 输入：频繁项集、频繁项集支持度字典、最小置信度（默认0.01）； 输出：关联规则元组列表# 关联规则元组结构：前件、后件、置信度def get_rules(freqset, supportData, minConfi=0.01): rules = [] for i in range(1, len(freqset)): # 遍历大于1的频繁项集 for item in freqset[i]: subset = [frozenset([unit]) for unit in item] # 生成项集的子集 if i &gt; 1: form_subset(item, subset, supportData, rules, minConfi) else: test_rule(item, subset, supportData, rules, minConfi) return rules# 主程序部分minSupport = 0.01 # 最小支持度minConfi = 0.01 # 最小置信度dataset = load_dataset('prescription.csv') # 导入数据集# 'groceries.csvtime_start = time.time() # 计时L, supportData = get_all_freqset(dataset, minSupport) # 求频繁项集及其支持度字典print('所有的频繁项集为：\\n', L)print('频繁项集的支持度为：\\n', supportData)print('频繁项集总数为：', len(supportData))time_end1 = time.time()print('求频繁项集所用时间：', time_end1-time_start, '秒')rules = get_rules(L, supportData, minConfi) # 挖掘关联规则print('挖掘出的关联规则为：')rules.sort(key=lambda x: x[2], reverse=True)# mat = \"{:^32}{:^48}{:^32}\"# print(mat.format('前件', '后件', '置信度'))# for item in rules:# print(mat.format(str(list(item[0])), str(list(item[1])), item[2]))print('关联规则总数为：', len(rules))time_end2 = time.time()print('求关联规则所用时间：', time_end2-time_end1, '秒') 2. 分布式Apriori代码：（distributed.py） （以下主要为新加入的内容） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from functools import partial # 偏函数from functools import reduce # reduce需要引入 在python 3.0.0.0以后, reduce已经不在built-in function里了# 数据集分块def block_gen(dataset): blockData = [] num = len(dataset) blockNum = int(sqrt(num)) + 1 k = blockNum block = [] for affair in dataset: if k &gt; 0: block.append(affair) k -= 1 else: block.append(affair) blockData.append(block) k = blockNum block = [] blockData.append(block)return blockData# 统计频次的map映射函数def map_freq(block, itemset, count): for affair in block: # 遍历数据集计算候选项集频次 for item in itemset: if item.issubset(affair): # 如果候选项集是事务的子集，计数+1 if item in count: count[item] += 1 else: count[item] = 1 return count# 通过候选k-项集的筛选，确定频繁k-项集 ///分布式算法///# 输入：数据集，候选k-项集，最小支持度； 输出：频繁k-项集列表，支持度字典def get_freqset(blockData, itemset, minSupport): supportData = {} # 支持度字典 count = {} # 计数字典 freqset = [] # 频繁k-项集 partial_func = partial(map_freq, itemset=itemset, count=count) list(map(partial_func, blockData)) # 分布式求项集频次 number = reduce(add, map(len, blockData)) # 分布式求事务的数目 for key in count: # 遍历计数字典筛选符合条件的项集作为频繁项集，计算支持度 support = count[key]/number if support &gt;= minSupport: freqset.append(key) supportData[key] = support return freqset, supportData# 挖掘所有满足条件的频繁项集# 输入：数据集，最小支持度； 输出：频繁项集列表、支持度字典def get_all_freqset(dataset, minSupport=0.001): # 最小支持度默认0.001 blockData = block_gen(dataset) C1 = get_one_itemset(dataset) L1, supportData = get_freqset(blockData, C1, minSupport) print('已经挖掘频繁', 1, '项集...') freqset = [L1] k = 0 while len(freqset[k]) &gt; 0: # 循环，直到挖掘完毕所有的频繁项集（最后一项为空） Ck = get_itemset(freqset[k], k+2) # 求候选项集 Lk, support = get_freqset(blockData, Ck, minSupport) # 求频繁项集和支持度字典 freqset.append(Lk) supportData.update(support) k += 1 print('已经挖掘频繁', k+1, '项集...')return freqset, supportData 3. 事务压缩方法：（affairs_comp.py） （主要修改部分） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 通过候选k-项集的筛选，确定频繁k-项集# 输入：数据集，候选k-项集，最小支持度； 输出：频繁k-项集列表，支持度字典def get_freqset(dataset, itemset, minSupport, flag): supportData = {} # 支持度字典 count = {} # 计数字典 freqset = [] # 频繁k-项集 i = 0 for affair in dataset: # 遍历数据集计算候选项集频次 if not flag[i]: # 此事务上次遍历不包含候选项集时，此次跳过 i += 1 continue flag_temp = False # 此标记用于判断本事务此次是否包含候选项集 for item in itemset: if item.issubset(affair): # 如果候选项集是事务的子集，计数+1 flag_temp = True if item in count: count[item] += 1 else: count[item] = 1 if not flag_temp: flag[i] = False i += 1 number = len(dataset) # 事务的数目 for key in count: # 遍历计数字典筛选符合条件的项集作为频繁项集，计算支持度 support = count[key]/number if support &gt;= minSupport: freqset.append(key) supportData[key] = supportreturn freqset, supportData# 挖掘所有满足条件的频繁项集# 输入：数据集，最小支持度； 输出：频繁项集列表、支持度字典def get_all_freqset(dataset, minSupport=0.001): # 最小支持度默认0.001 flag = [True for _ in range(len(dataset))] # 用于事务压缩的标记数组 C1 = get_one_itemset(dataset) L1, supportData = get_freqset(dataset, C1, minSupport, flag) print('已经挖掘频繁', 1, '项集...') freqset = [L1] k = 0 while len(freqset[k]) &gt; 0: # 循环，直到挖掘完毕所有的频繁项集（最后一项为空） Ck = get_itemset(freqset[k], k+2) # 求候选项集 Lk, support = get_freqset(dataset, Ck, minSupport, flag) # 求频繁项集和支持度字典 freqset.append(Lk) supportData.update(support) k += 1 print('已经挖掘频繁', k+1, '项集...') return freqset, supportData 4. 爬取数据集代码：（crawler.py） 123456789101112131415161718192021222324252627282930313233import requestsfrom lxml import etreeimport csv# 获取源码html = requests.get(\"http://zhongyaofangji.com/all.html\")# 打印源码print('访问成功...')etree_html = etree.HTML(html.text)# 获取药方链接content = etree_html.xpath('//*[@id=\"divMain\"]/div/div/ul/li/a/@href')# 保存药方链接便于之后爬取with open('url.csv', 'w', newline=\"\", encoding='utf-8') as f: csv_write = csv.writer(f) for each in content: temp = [str(each)] csv_write.writerow(temp)print('url保存成功...')# 后续爬取免于从根目录爬网址，直接读取即可# with open('url.csv', 'rt', encoding='UTF-8') as raw_data:# readers = csv.reader(raw_data, delimiter=',')# content = list(readers)# print(content)with open(\"prescription.csv\", 'a', newline=\"\", encoding=\"utf-8\") as input_csv: csv_write = csv.writer(input_csv) num = len(content) for i in range(0, num): print('第', i+1, '项正在访问：', content[i]) html = requests.get(content[i]) html.encoding = 'GBK' etree_html = etree.HTML(html.text) herb = etree_html.xpath('//*[@id=\"divMain\"]/div/div[2]/div[2]/div[2]/div[1]/p[1]/a/text()') csv_write.writerow(herb) print(herb)","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Python","slug":"Python","permalink":"https://renzehua1998.github.io/tags/Python/"},{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://renzehua1998.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"}]},{"title":"计算机控制实验","date":"2020-07-19T12:26:00.000Z","path":"2020/07/19/计算机控制实验/","text":"大三下计算机控制实验：基于LabVIEW-myRIO的自我循迹避障、语音操控小车。 和峰哥龙哥一起完成，还投了B站，激情燃烧的岁月啊…… 实验一： 第一次报告：报告1 实验二： 第二次报告：报告2 实验三： 第三次报告：报告3 原始代码：代码","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"控制","slug":"控制","permalink":"https://renzehua1998.github.io/tags/%E6%8E%A7%E5%88%B6/"},{"name":"LabVIEW","slug":"LabVIEW","permalink":"https://renzehua1998.github.io/tags/LabVIEW/"}]},{"title":"电子线路设计下实验报告2","date":"2020-07-09T15:30:00.000Z","path":"2020/07/09/电子线路设计下实验报告2/","text":"大三下电子线路设计下实验报告2 一、实验准备 1、Keil的基本使用方法 2、51单片机C8051F020基础知识 3、ADC 4、液晶实时显示波形 5、PID控制算法和调参方法 二、实验任务与要求 (一)基础要求 编程实现平衡器控制系统功能调试。要求采用基于C8051F020智能控制器作为平衡器控制系统的核心部件，编程实现对平衡器的自动控制。要求程序中必须包含数码管、液晶显示、键盘、AD。 将实验任务一和任务二的功能整合成一个大工程，LCD屏上显示主菜单：包括三个子菜单 （1）个人信息 ； （2）实验一功能； （3）实验二功能：LCD屏上显示控制电压曲线、LED显示控制电压值。 自己编写PID算法并实现PID参数的整定，能够保证控制的稳定性和快速性。 (二)工程实现的功能 重新编辑了主菜单，为了配合按键显示，将实验一的功能一和功能二合成了一个子功能。加入了显示个人信息界面和实验二的显示波形、控制飞行器子功能。 1.主菜单包括三个选项：显示个人信息（左键）、进入实验一功能（中键）、进入实验二功能（右键）。其中显示个人信息界面下显示姓名学号班级等等信息，按右键退出。 2.实验一子菜单内是实验一实现的功能，在此不再赘述。值得一提的是，由于实验一有三个功能，缺一个返回按钮，所以我把计时和播动画两个功能进行了合并，变为一个“计时选图”选项，并创建了一个过度菜单来选择，将右键统一设置为返回按钮。 3.实验二子菜单有三个选项：显示波形（左键）、控制平衡器（中键）、返回主菜单（右键）。 4.显示波形子功能中选中进入过渡菜单，按左键进入播放，中键播放下一个，右键返回。一共有三种波形：正弦波、三角波、方波。进入以后再按左键重新播放这一个波形。 5.控制平衡器功能选中进入选择滤波方式过渡菜单。其中左键选择下一个，右键退出。一共有三种滤波方式：算数均值滤波、中值平均滤波、滑动均值滤波。按中键确定进入，按右键退出。进入显示波形界面后，上半屏显示霍尔传感器实时检测的电压曲线，下半屏是提示信息，左键为飞行器向上，中键为飞行器向下，右键为返回停止。 (三)流程图 1.主逻辑 2.实验一子菜单 3.实验二子菜单 4.显示波形、控制飞行器子功能 三、硬件原理 (一)ADC A/D转换器片内有D/A转换和电压比较器，基本电路图如下： ADC电路通常由两部分组成，它们是：采样、保持电路和量化、编码电路。其中量化、编码电路是最核心的部件，任何ADC转换电路都必须包含这种电路。 模—数转换的过程有四个阶段，即采样、保持、量化和编码。 ADC有4种转换启动方式，在本实验中使用的是定时器3溢出（即定时的连续转换）方式。 (二)DAC 每个C805 1F020/1/2/3器件都有两个片内12 位电压方式数/模转换器(DAC)。每个DAC的输出摆幅均为0V到(VREF-ILSB)，对应的输入码范围是0x000到0xFFF。可以用对应的控制寄存器DACOCN和DACICN允许/禁止DACO和DAC1。每个DAC都具有灵活的输出更新机制，允许无缝的满度变化并支持无抖动输出更新，适合波形发生器的应用。其中使用方式有两种：根据软件命令更新输出、基于定时器溢出的输出更新。在本实验中使用第二种方式，使用定时器2进行输出，具体操作将在后面调试中介绍。 下面是信号发生器的硬件电路： (三)模拟飞行器 模拟飞行平衡器实物 模拟飞行平衡器原理图 直升机垂直升降系统接口 序号 信号 作用 1 +12V +12V 电源 2 +5V +5V 电源 3 GND 地线 4 AIN0 0 号模拟量检测端子，霍尔传感器电路输出检测端子。 5 AIN1 1 号模拟量检测端子，霍尔传感器电路接地端。 6 AIN2 2 号模拟量检测端子，螺旋桨电机电压检测端子。 7 AIN3 3 号模拟量检测端子，螺旋桨电机电压检测端子。 8 DA-OUT0 模拟量控制信号端子，螺旋桨电机电压控制端子。 9 AGND 模拟地线 (四)外部放大电路 实验板输出电压0~5v不能驱动控制对象，需要用放大电路放大信号。 (五)接线方法 如图所示，实验板输出控制电压（DAC）接到DA-OUT0口，实现螺旋桨电机电压控制。AIN0口霍尔传感器电路输出检测端子接到放大电路，放大后的信号接到实验板输入接口（ADC）。其中5V、12V、地线都从实验板引出，通过面包板连接即可。 备注：其他硬件模块功能已在实验1 四、软件实现 (一)主函数 (二)显示个人信息 (三)实验一增加的中转界面 (四)实验二主菜单 (五)显示波形 定时器中断输出波形 按键中断显示波形条件语句： (六)选择滤波方式 (七)控制平衡器 滤波操作： 显示检测值、设定值、控制量：（led数码管上中下三行） 控制算法： 网上参考的位置型PID算法出处： 根据网上找到的参考PID算法，进行简单修改以后即可投入使用，需要注意的是，在风扇电机控制中，控制量应该是原检测值加上PID控制量，因为该电机没有积分环节，必须保留原始值才可以。 三种滤波算法： 数码管显示检测、设定、控制值子函数： Lcd屏幕绘制电压波形子函数： 各种初始化合集函数： 备注：全部代码在提交的工程文件中，此处由于篇幅限制不粘贴全部代码。 五、调试过程 (一)RAM不够的问题 显示地址空间溢出，查找相关资料后发现是全局变量太多把ram用超了，需要利用一下高字节ram和片外存储器。由于实现的功能比较多，各种函数之间传递参数必须用到全局变量，所以在尽可能精简以后存储器空间还是超了，这就需要扩充到其他存储空间。 论坛找到的资料——我遇到了这个问题后，我发现是RAM不够，一般的话。有data、idata、pdata以及xdata。data的话，就是低128（片内）字节；idata的话，就是256个（片内）字节。起始data就是idata的一部分。pdata以及xdata是片外RAM的，那就得看单片机的手册进行操作。例如STC12C5A60S2的话，要用内部扩展的话，是要用到xdata的，即unsigned char xdata a[256]，那么这就去了256个字节了。内部扩展的。也就是说，当你编译后，发现data已经是大于128了，同时伴随着报错。那你就得使用xdata或者pdata了。 在变量定义时声明为idata或者xdata即可 可以看到编译通过。 (二)定时器选择与DAC输出方式的改变 刚开始我在按照例程写完DAC输出时发现并没有对电机起到控制作用，在仔细查看操作手册以后我发现这和DAC初始化时向DAC0CN写入的控制字有关。两个例程中写入的控制字不同，一个是0x98（10011000），另一个是0x94（10010100）。 对于我的工程来说，使用定时器2，直接对DAC0写入，所以控制字写入0x98即可达到效果，而我尝试使用定时器4，发现数码管会发生肉眼可见的闪烁，这应该与定时器的周期有关，所以在使能时关掉了定时器4，中断中也没有使用定时器4的功能。 (三)波形全屏显示 由于霍尔传感器的输出电压是一个范围，并不是准确的0-5V，而之前编写的显示函数显示范围是0-4096，即将0-5V映射到12位二进制数中。所以对于不同的飞行器要根据其显示范围，确定不同的变换系数。即将飞行器霍尔元件输出电压区间拉伸映射到整个显示区间。 在我使用的这块板子上，标定的参数为： (四)PID参数的整定 PID参数必须通过整定才能达到最好的控制效果，而不好的PID参数甚至可能会使控制系统不稳定。 网上查到的凑试法调节PID参数方法： 根据这个方法可以进行PID参数的整定，下面是具体的调参过程： 1.在初步确定了一组PID参数后，得到了一组控制曲线： 可以看出，在飞行器高度较高时，稳态性能不好，有抖动和静差。而在调节高低的过程中，在加入扰动以后，响应曲线的动态性能也不好。有震荡和超调的存在，响应时间也很长。 2.比例环节的调节 按照方法中的指示，先从比例环境调起，可以很明显地看出，比例环节过小，调节时间太长且具有静差；但是比例环节太大以后，出现了较大的超调，比较合适的时调节出理想的4：1衰减曲线。 3.积分环节的调节 积分环节能够起到消除稳态误差的作用，但是如果积分环节过大，会破坏系统的稳定性，出现较大的超调和震荡，应该将积分环节调节到几乎没有超调且没有静差。 4.微分环节的调节 微分环节起到一个“超前调节”的作用，如果没有微分环节，可能会造成调节时间过长，而微分环节过大会造成系统失衡，稳定性变差。 调节到最后，应该在保证没有静差、系统稳定的情况下，尽可能地缩短调节时间，以达到完美的响应曲线。 5.最终调节结果 这一个是我特别满意的调节曲线，可以看出，不管是从小到大还是从大到小，调节曲线都很稳定，而且没有超调和静差，响应时间也很快。最关键的是，从视频中可以看出，在按下改变设定值按钮后，飞行器迅速响应，马上稳定且没有震荡，稳定以后也没有细微的波动。 对应的PID参数为：Kp：1.3，Ki：0.04，Kd：0.003 备注：对应的参数只对特定的实验仪器有用。 六、实验总结 这次实验前前后后做了五天的时间，从研读例程，到尝试修改例程、测试功能，再到列清单设计菜单，到把两次实验整合起来，最后再加入PID控制，调试PID参数以达到完美的响应曲线。这次试验确确实实花费了很多时间和心血，从借到实验板到拿着小起子转电位器调节显示波形，再到研读数据手册解决问题，最后搭板子调PID参数，整个过程确实让人难忘。最让我印象深刻的是例程当中存在的各种各样的问题，在无法实现功能，寻找解决办法的过程中发现了其中的各种bug，看来，发现和解决问题是最好的学习方法。在感叹于例程错误多的过程中，我也逐渐的加深了对单片机的认识，在查找数据手册、请教老师、同学交流和上网查找解决方案的过程中，我对于这些知识的掌握也更加深刻。许多错误的发生正是我们在编程中最容易发生的，这也为我的编程提供了参考与警示。 PID参数的调节过程又是一个挑战，对于我们自动化专业，PID可以说是老朋友了，但是在之前的课程和实验中，都是确定了的理想条件，包括做实验也是调试好的集成设备，可以直接拿来使用。对于一个不太了解的系统，如何调节参数以达到最好的控制效果确实是第一次遇到。在仔细复习了PID算法、PID参数调节方法以后，我对于控制对象的参数调节前前后后进行了一天时间。一方面是因为三个参数互相耦合，牵一发而动全身；另一方面是因为不太的模拟飞行器都有一套不同的参数，下午再来到实验室时更换了实验板和飞行器，还有重新进行波形显示的调节和参数的整定，这里也浪费了一些时间。不过最终结果让人满意，我调出了理想的曲线，控制效果也很让人满意。这也给定一个实际系统来进行单片机控制，也接近于实际应用，让我更好地体会到了理论与实践相结合的魅力。 附带的视频如果电脑自带视频播放器打不开可以使用腾讯视频打开。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"电子线路设计下实验报告1","date":"2020-07-07T13:19:00.000Z","path":"2020/07/07/电子线路设计下实验报告1/","text":"大三下电子线路设计下实验报告1 一、实验准备 1、Keil的基本使用方法 2、51单片机C8051F020基础知识 3、Img2lcd软件的使用 4、液晶的显示机制 二、实验任务与要求 (一)基础要求 每位同学把“电子线路设计训练专题实验1”所作的项目功能，修改程序用于基于C8051F020智能控制器系统调试。若控制器硬件资源足够，修改程序进行调试即可；若控制器硬件资源不够，在面包板上搭建不足的电路部分，用导线连接到控制器，修改程序进行调试。 (二)工程实现的功能 由于上学期实验项目是单片机延时播放动画的程序，这学期在这个基础上添加了计时、按键选图功能，并添加了操作界面。上学期的动画一共有上千帧，单片机存储空间有限，不能存放下这么多的内容，在Proteus中使用了SD卡模块，这学期在实际接触到板子以后发现外接SD卡不太可能，所以选取了一个10帧的动画来展示。 1、有一个主菜单，包括各种功能选择和班级姓名的显示。 2、点击左键进入计时功能模块，其中左键为清零、中键为开始/停止计时、右键为退出。Led数码管第一行显示计时结果，后两行定义为学号后8位，lcd屏显示按键功能和学号。 3、点击中键进入显示图片模块，其中左键为上一张，中键为下一张，右键为退出，对应的lcd显示屏上面左屏为图像说明和按键说明，右屏为图片。一共四张。 4、点击右键进入动画播放模块，其中左键为立即播放，中键为延时5秒后播放，右键为退出。延时时，lcd显示请等待提示，播放完动画后显示右键退出提示。 (三)流程图 三、硬件原理 (一)LED 一位数码管的引脚是10个，显示一个8字需要7个小段，另外还有一个小数点，所以其内部一共有8个小的发光二极管。对共阴极数码来说，我们给数码管的任一个阳极加一个高电平时，对应的这个发光二极管就被点亮了。如果想要显示数字8，并且把小数点也点亮的话，可以给8个阳极全部送入高电平，依次类推，就可以控制数码管的显示。 P5和P6是LED的选通信号，P7是LED显示数字的控制信号。LED的显示是基于“刷新”的，也就是几个LED单元轮流显示，在周期很短的时候肉眼就看不出来闪烁。所以LED刷新函数必须放在主循环里面才能实现LED数字的显示。 (二)Lcd Lcd的显示在例程中主要基于四个函数： 1234void WriteStr(uchar row,uchar col,uchar *puts)void ImageShow(uchar *imagePtr)void LineClear(uchar line)void LcdClear( void ) 其中第一个是向lcd指定行、指定列写入字符串，值得注意的是，中文字符串占用了两个英文字串的位置，若是中文混着英文，中间的英文字符必须为偶数（可以用空格占位），否则后面的中文字符会有乱码。而且中文字符中有些lcd字库中没有的也会乱码，可以替换为其他字符。 第二个函数是在lcd上显示一幅图片，它和字符的显示相互独立，如果不注意二者可能会重叠。其中主要有三层循环，第一层循环两次，分别控制屏幕的上半部分和下半部分；第二层循环有32次，是显示屏的列控制；第三层循环有8次，是显示屏的行控制。根据显示原理可以将例程中的右半屏显示改为全屏显示，也可以改为上半屏显示。 (三)按键 按键的检测通过中断2实现： void INT1_ISR(void) interrupt 2 其中检测端口P5的值来判断按下了哪个按键，通过修改全局变量botflag的值（改为0，1，2）来对主函数进行控制，每次修改完以后，botflag修改为非三个按键的变量（工程中使用4）。在例程中，中断2里面添加了一些控制规则，在本次实验中我没有加，只返回标志变量的值，在下一次实验中添加了不参与主循环的单次运行的功能。 值得注意的是，中断2只在数码管运行刷新的时候才会执行，所以在实现功能时必须保留有LedDispNum();或者类似的led显示功能。 备注：DAC和ADC功能将在实验2 的报告中说明。 四、软件实现 主要思想就是全局变量flag的使用以实现菜单功能。 主要标志变量有：botflag（按键标志）、TRflag（计时标志）、showflag（页面标志）、imgflag（图片标志）、GFlag（动画标志） 使用if语句对页面标志showflag进行选择，显示对应的页面，实现不同的功能。在每个条件语句内加入了对按键标志botflag的判断，若检测到有按键操作，将对应的标志变量改变，botflag置4，并进行相应的操作（清屏、显示提示信息等等）。 下一次循环时由于标志变量的改变，直接进入对应页面。 (一)主菜单 其中包含了一些其他页面的显示功能，增强软件的鲁棒性。 (二)计时功能 (三)按键选图 (四)播放动画 (五)显示图片子函数 (六)数码管显示数字子函数 原例程中这一部分选通数码管写的不对，进行修改以后可以正常显示，其中第一行显示计时，第二行、第三行显示学号后八位。 (七)全屏显示子函数 通过修改对应写入命令字将例程中的半屏显示改为全屏显示。 备注：全部代码在提交的工程文件中，此处由于篇幅限制不粘贴全部代码。 五、实验总结 这次实验的目的主要是实现上学期电子线路设计实验一在Proteus平台上的功能。上学期我实现了单片机12864显示屏播放动画的功能，这学期在实际的单片机平台上实现也遇到了不少问题。首先就是读卡器的问题，在上学期的实验中使用的是串口总线读取方式，这学期由于实验开发板的限制难以外接，所以我使用了10帧的动画代替。在上学期计时播动画的基础上增加了定时和选图功能，对于单片机显示屏、数码管和按键的工作原理有了进一步的认识。 上学期的mmc存储卡映射文件的生成方式我也进行了探索，利用生成的二进制文件bin和二进制文件合成工具合成了相应的动画，在提交的文件中也有附带。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"网络与信息安全实验报告","date":"2020-06-30T11:31:00.000Z","path":"2020/06/30/网络与信息安全实验报告/","text":"大三下网络与信息安全选修课实验报告 女巫攻击论文 针对 Sybil 攻击的防御技术的发展 实验一 使用SybilGuard算法实现社交网络中Sybil节点的检测 一、实验目的 学会使用Python平台搭建基本的社交网络模型。 能够利用已有的社交网络数据集生成具有类似拓扑的新网络。 可以生成一个随机的Sybil攻击，把Sybil节点添加进网络中。 能够编写正确的Sybil Guard算法，检测出添加的Sybil节点。 二、实验设备与平台 ​ 笔记本电脑一台；Python3.7环境；必需的Python函数包；Spyder IDE；来自http://networkrepository.com的社交网络数据集。 三、实验内容与要求 利用Python导入网上找到的社交网络数据集，将其转化为邻接矩阵。 按照该社交网络模型生成节点数、网络拓扑相类似的另一个网络（避免偶然性，防止程序仅对特定网络有效）。 在现有网络的基础上生成一个随机的Sybil攻击，即：Sybil节点数随机、攻击位置随机、攻击边数随机（小于最大限度）。 编写实现Sybil Guard算法，检测出网络中的Sybil节点，返回检测准确性的矩阵，用于衡量算法是否有用。 四、实验步骤 1. 利用Python导入网上找到的社交网络数据集，将其转化为邻接矩阵。 （1）导入数据集 此处我使用的是Network Repository网站上面的开源网络数据集，选择了其中网络节点数比较少的网络：Caltech36，它是一个基于Facebook真实数据产生的769个节点，16.7K条边的社交网络图。下载下来是mtx格式，所以我使用scipy.io中的mmread函数将其导入，并且使用todense方法将稀疏矩阵转化为邻接矩阵形式。 其中遇到一点点小问题，导入时报错：文件不是以MatrixMarket matrix格式存储的，导入失败，后来我用UltraEdit软件打开才发现，本来MatrixMarket matrix格式第一行应该有两个“%”才能被识别，但是数据集只有一个“%”，将其更改完毕即可成功导入。下面几行就是网络规模、边数和邻接关系。 将数据集导入后打开矩阵F可以看到邻接矩阵的形式： 数据集Caltech36的网络拓扑结构如下： （2）绘制各个度数节点数量的统计图： 这一步是比较重要的，它描述了网络的大致拓扑结构，为接下来检验重构网络是否与原网络结构相似提供了依据。 其中包含一些子函数的定义： friends (A):返回每个人的朋友列表组成的矩阵，前k项为朋友序号，k为节点度数，其余值为-1. degre (A,i):返回社交图节点的度数：它仅包含计算每个人的朋友数 degremoyen(A):网络的平均节点度数 tablederoutage (A,B):计算每个节点列表的排列 tableroutage2 (A,B,C, node):将每个节点与其排列相关联 search(B,row,friend):搜索朋友 next2(B, RT, friend):在具体步骤中通过这些排列获得的每个节点的图像 statistique (A):返回向量v，第i项为第i个节点的度数 这一步比较费时间，定义了一个print功能可以实时显示进度： 使用以下代码即可画出网络各个度数节点数量的统计折线图： 最终画出的统计图如下： 可以看出，度数小的节点数量比较多，度数大的相对较少。 2. 按照该社交网络模型生成节点数、网络拓扑相类似的另一个网络。 （1）生成新网络 somme (f,n):节点度数累加起来，后一项是前面的求和 f(i):估计出的原始图形节点度数分布函数 构建v矩阵： prob(v):根据与函数f相关的概率分布，计算随机节点的度数 matricerandom2(A,v): 构建类似于原矩阵的邻接矩阵（相同大小，相似的“给定度数的节点数”轮廓） 生成对应矩阵C并且画出新网络的节点分布： 它与原网络分布形状类似，可以应用于实际操作。 原网络节点分布图： 3. 在现有网络的基础上生成一个随机的Sybil攻击。 k(v):指数概率分布的生成d服从均匀分布，s为指数分布，v为指数分布的参数 generation( n,f):随机确定哪些节点将链接这两个网络： ajoute(A):使用刚刚定义的攻击边缘将两个社交网络连接起来。 生成攻击过后的网络D： 4. 编写实现Sybil Guard算法，检测出网络中的Sybil节点，返回检测准确性的矩阵 （1）网络Caltech36 witness(A,B,RT,node,w):生成随机路线 comp (A,B,RT,V,S,W):两条随机路线的比较-研究他们的交点 listpour (A,v,s,m):返回两个节点的路线之间交叉点数目不同的列表 estimation (A,v,s,m):使用listpour并返回经验期望： 检测Sybil节点，返回检测准确度矩阵J： J00，诚实检测为诚实；J01，诚实检测为sybil； J10，sybil检测为诚实；J11，sybil检测为sybil 最后运行几次，更改初始诚实节点的值，比较检测效果。 经过实验，阈值x选在140左右检测效果最好。 检测结果： 1.诚实节点标号s=300，阈值x=140，随机生成14个： 2.诚实节点标号s=150，阈值x=140，随机生成14个： 3.诚实节点标号s=200，阈值x=140，随机生成3个： 4.诚实节点标号s=200，阈值x=140，随机生成4个： 5.诚实节点标号s=350，阈值x=140，随机生成12个： （2）新网络Reed98 仅用一个数据集不足以证明检测算法的鲁棒性，我在同一个网站上下载了另一个规模相近的网络数据集Reed98进行测试，其网络拓扑图如下，其中节点数为962，边数为18.8k，规模比上一个网络大了一些，计算时间也相应长了一些。 检测结果： 1.诚实节点标号s=600，阈值x=140，随机生成6个： 2.诚实节点标号s=921，阈值x=140，随机生成5个： 3.诚实节点标号s=66，阈值x=140，随机生成3个： 4.诚实节点标号s=168，阈值x=140，随机生成12个： 五、实验结论与体会 自己利用Python平台复现了论文中检测Sybil攻击的Sybil Guard算法，在检测结果上取得了不错的成绩，针对第一个网络，仅仅在Sybil节点数为14的时候发生了误判，将诚实节点检测为了Sybil节点。而总体上来说，当Sybil节点相较于网络规模来说不多时，Sybil节点的检测精确度还是很高的。而对于本次实验来说，费时间的不是生成Sybil节点，也不是检测算法，而是进行节点统计的函数，迫不得已只能使用print来显示进度。 这次实验给我最大的收获就是编程能力的提高，还有就是分析解决问题的能力，在网上寻找相关代码时只有一个不完整的工程，其中的代码是用Python2编写的，许多语句不匹配，而且缺乏相关数据集，在搜索大量网页以后终于找到了一个可用的开源数据集，这样让我明白，我们信息类专业，数据对我们来说是至关重要的，正所谓“工欲善其事必先利其器”，只有拥有了专业靠谱的数据，我们的工作才能继续开展。而获得的数据必须进行一定的处理才能为我们所用，就像我刚开头提到的“%”的问题，可能是因为调用的接口不同，导致了原数据与我们的需要不匹配，这就需要我们进行进一步的处理。 PS：下面这个是当时做区块链报告时为了解比特币挖矿机制而进行的一个简单的小测试，放到后边做一个附注吧。 实验二 基于MATLAB模拟比特币挖矿的实验 一、 实验目的 通过实验了解区块链的基本原理和基本结构，体会“挖矿”的概念 二、 实验设备与平台 笔记本电脑一台、MATLAB r2018b、网上下载的SHA256计算代码DataHash.m 三、 实验内容与要求 利用软件模拟挖矿、记录交易的过程，体会区块链的基本思想 四、 实验步骤 1.定义区块的数据结构 2.定义区块链的数据结构 3.定义挖矿的函数 4.执行挖矿的过程 执行的结果：（只展示初始化和第三个block挖完的结果） 初始化： 第三个块： 可以看出执行到第1377次遍历时才得到前三位都为0的哈希值。 5.修改挖矿难度再次实验 难度为1（第一位为0） 难度为2（前两位为0） 难度为3（前三位为0） 难度为4（前四位为0） 挖矿时间随难度的变化 五、实验结论与体会 利用MATLAB进行了简单的挖矿模拟实验，可以看出，随着挖矿难度的增加，挖矿时间呈现指数增长，而寻找合适的随机数使得哈希值满足要求就只能使用遍历。在挖矿设备越来越多时，要保证恒定的打包率，就只能增大难度，而每增加一位难度，挖矿时间都将以指数形式增长。比特币带来的到底是巨大的金融利益，还是电能的巨大耗费，这一点值得我们思考。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Python","slug":"Python","permalink":"https://renzehua1998.github.io/tags/Python/"},{"name":"图与网络","slug":"图与网络","permalink":"https://renzehua1998.github.io/tags/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/"}]},{"title":"自动控制下实验报告1","date":"2020-06-24T04:54:00.000Z","path":"2020/06/24/自动控制下实验报告1/","text":"大三下自动控制下实验报告1。 实验一 实现直流电机系统模型识别 一、实验设备与软件 1.硬件设备：计算机，NI ElvisⅡ实验平台，Quanser QNET 直流电机。 2.软件系统：Win7 系统，Labview2015 开发软件。 二、实验步骤 1.研读例程，熟悉 LabVIEW ，及方波、滤波器、波形生成、系统辨识等控件。 2.编程实现对 Quanser QNET 直流电机的系统辨识，获得电机的模型参数 3.调试出系统后，保存记录幅值、频率、采样率初值下的曲线图与辨识结果，再对比记录幅值、频率、采样率增大和减小情况下曲线变化和辨识结果。 三、LabVIEW 设计过程及说明 本次实验在给定采样率，幅值和频率的情况下通过信号发生函数产生方波，送入模拟波形函数得到激励方波信号。同时，在 for 循环内，根据给定的电压值和采样率在 AI 处产生波形，并将此波形经过低通滤波得到实际转速。从理论上来说，转速与给定的电压成正比，电压越大，转速越快，但是实际转速还受到阻尼、上升时间等方面的影响，与理论曲线有一定的差异。 将激励方波作为系统传递函数模型辨识的激励信号波形输入，实际转速作为响应信号波形输入，设置传递函数分子多项式阶数为0，分母多项式阶数为1，系统传递函数模型输出与激励方波送入模型仿真得到模型的理论曲线，理论曲线和实际转速图像显示在前面板上。模型输出送入系统模型得到传递函数表达式，得到电机模型，由电机模型可以计算出 PID 参数等后续内容。 图 1 LabVIEW 程序框图 四、实验结果与分析 1.将传递函数模型设定为一阶系统，设定基本参数初值采样率 250Hz，幅值为 3V，频率为0.5Hz，据此画出的波形以及拟合出的传递函数如图 2 所示。 图 2 采样率250Hz 幅值为 3V 频率为 0.5Hz 时的波形和传递函数 2.改变采样率 图 3 采样率为500Hz时的波形和传递函数 图 4 采样率50Hz时的波形和传递函数 由图 2、图 3、图 4 的对比可以看到，当采样率越大，电机实际输出信号曲线与模型理论曲线拟合效果越好，传递函数的比例系数和时间常数也稍有增大。在采样率为 50Hz 的时候，电机输出信号与模型信号拟合效果比较差，有毛刺信号，表明50Hz的采样率不适用。 3.改变幅值 图 5 幅值为1时的波形和传递函数 图6 幅值为5的波形和传递函数 由图 2、图 5、图 6 的对比可以看到，通过增大方波幅值可以使得传递函数的比例系数增大，同时时间常数 T 增大，响应时间变慢。 4.改变频率 图 7 频率为0.1时的波形和传递函数 图 8 频率为1时的波形和传递函数 由图 2、图 7、图 8 的对比可以看到，通过修改频率的大小对传递函数模型的影响较小，影响的是曲线中周期的数目，一般来说曲线中以2-3个周期为佳，频率太小图像中只有一个周期，不具代表性；频率太大，图像中周期太多，细节信息观察不到。 五、调试中的出现的问题与解决方法 1.问题：电机输出信号与模型信号不符合激励方波的响应信号的图像 解决方法：检查程序框图的接线是否有误。 2.问题：调节时间过长 解决方法：适当减小采样率、幅值。 六、实验总结 本次实验通过LabVIEW软件和Quanser QNET直流电机实现直流电机系统模型识别，在LabVIEW软件程序框图编程，在前面板对不同幅值、频率、采样率实验。实验操作完成后，对记录的不同幅值、频率、采样率参数下的系统辨识结果，进行对比分析。通过这次实验的学习，我们对LabVIEW软件有了更深的掌握，加深了对参数影响系统辨识的理解。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"控制","slug":"控制","permalink":"https://renzehua1998.github.io/tags/%E6%8E%A7%E5%88%B6/"},{"name":"LabVIEW","slug":"LabVIEW","permalink":"https://renzehua1998.github.io/tags/LabVIEW/"}]},{"title":"自动控制下实验报告2","date":"2020-06-24T04:50:00.000Z","path":"2020/06/24/自动控制下实验报告2/","text":"大三下自动控制下实验报告2。 实验二 实现直流电机位置控制 一、实验设备与软件 1.硬件设备：计算机，NI ElvisⅡ实验平台，Quanser QNET 直流电机。 2.软件系统：Win7 系统，Labview2015 开发软件。 二、实验步骤 1.研读例程，熟悉LabVIEW控制与仿真控件，计数器采样，属性节点的作用，计数值U32换算位置参数，子VI的应用等内容。 2.编程实现对Quanser QNET直流电机的位置控制。 3.调试出系统后，保存记录PD参数初值下的控制曲线图，再对比记录比例、微分参数增大和减小情况下控制曲线变化。 三、LabVIEW 设计过程及说明 首先应用控制与仿真循环，确定程序的输入量和输出量，输入为采样率和边沿计数 CI，计数器采样得到的结果经过子程序计算后输出位置信息，画出位置的波形，同时，在前面板上显示转速和幅度等信息方便我们观察。在此之后使用PD 控制器，将设定电机位置输入至 PD 控制器，输出实际位置以及电压值，同样，这些值被显示在前面板中， 方便我们观察电机位置控制的方法。 图 1 LabVIEW 程序框图 图 2 LabVIEW 子程序框图 四、实验结果与分析 1.设定采样率 250Hz，PD控制Kp = 2.1，Kd = 0.033，并且幅值为2rad，频率为0.5，波形图如下图所示。 图3 Kp=2.1 Kd=0.033的波形 2.改变 Kp 图4 Kp =1电机位置控制情况 图5 Kp =3电机位置控制情况 对比图 3、图 4、图5可知，增大 Kp 时，系统超调量基本不变，调节时间延长，Kp 过大会出现震荡。减小 Kp 时，超调量减小，调节时间缩短，但过小的 Kp 会引起稳态误差。经调试，Kp = 2.1 时系统性能最好。 3.改变 Kd 图6 Kd =0.01电机位置控制 图7 Kd =0.1电机位置控制情况 对比图 3、图 6、图7可知，增大 Kd 后，超调量减小，产生较大的滞后和稳态误差。减小 Kd 后，系统稳态误差增大，系统调整时间延长。经调试，Kd= 0.068 时系统性能最好。 五、问题及解决方法 问题：程序工作但是无图像显示 解决方法：程序框图中的控制与仿真循环有误。 六、实验结果讨论 本次实验研讨了PD控制直流电机的位置。PD控制参数中Kp 是比例系数，Kp 比例控制不能消除稳态误差，Kp 加大会引起系统的不稳定；控制系统的超调量 Kd 是微分系数，可以减小超调量，克服震荡使得系统的稳定性提高，同时加快系统的动态响应速度，从而改善系统的动态性能。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"控制","slug":"控制","permalink":"https://renzehua1998.github.io/tags/%E6%8E%A7%E5%88%B6/"},{"name":"LabVIEW","slug":"LabVIEW","permalink":"https://renzehua1998.github.io/tags/LabVIEW/"}]},{"title":"自动控制下实验报告3","date":"2020-06-24T04:45:00.000Z","path":"2020/06/24/自动控制下实验报告3/","text":"大三下自动控制下实验报告3。 实验三 直升机垂直升降控制系统设计 一、实验设备与软件 1.硬件设备：计算机，NI ElvisⅡ实验平台，直升机垂直升降模拟系统一套。 2.软件系统：Win7 系统，Labview2015 开发软件。 直升机垂直升降系统接口 序号 信号 作用 1 +12V +12V 电源 2 +5V +5V 电源 3 GND 地线 4 AIN0 0 号模拟量检测端子，霍尔传感器电路输出检测端子。 5 AIN1 1 号模拟量检测端子，霍尔传感器电路接地端。 6 AIN2 2 号模拟量检测端子，螺旋桨电机电压检测端子。 7 AIN3 3 号模拟量检测端子，螺旋桨电机电压检测端子。 8 DA-OUT0 模拟量控制信号端子，螺旋桨电机电压控制端子。 9 AGND 模拟地线 2）SS49E 系列霍尔效应线性位置传感器 型号：SS49E 供电电源：2.2~6.5Vdc 电流：10 mA 工作温度：-40℃~100℃ SS49E 和 SS59ET 系列经济型线性霍尔效应传感器，为小型、通用、线性、霍尔效应传感器装置，它的运行依靠永久磁铁或电磁铁的磁场。线性电流源输出电压由供电电压设定，并随磁场强度成比例地变化。 此集成电路具有低噪声输出的特点，致使不再需要采用外部滤波。它还包括有薄膜式电阻，能提高温度的稳定性和准确性。这些线性霍尔效应传感器的工作温度范围为-40℃至 100℃（-40°F 至 212°F ），适用于各种商业、用户和工业环境条件。 SS49E/SS59ET 系列系列霍尔效应线性位置传感器优势特点： 微型设计 5Vdc 能效时的功耗为 6mA 单一电流源输出 线性输出，使电路设计灵活多样 低噪声输出，实际上排除了对滤波的需求 薄膜式电阻，使输出稳定而精确 温度范围在-40℃至 100℃（-40°F 至 212°F） 在正或负高斯都能响应 SS49E/SS59ET 系列霍尔效应线性位置传感器应用范围：电流传感，电动机控制，位置传感，磁码读数，旋转编码器，铁金属探测器，振动传感，液位传感，重量传感。 3）螺旋桨性能参数 额定电压：12V 电流：0.17A 功率：2.14W 额定转速：10000rpm 最大气流：0.322CMM，11.4CFM （风量单位有 CMM（立方米每分）、 CMH（立方米每时）、 CFM（立方英尺每分）、 LM（升每分钟）， 1CMM=60CMH=35.245CFM=1000LM。） 最大风压：0.332inAq，8.432mmAq（inAq 是英寸水柱，mmAq 毫米水柱，,1inAq=249Pa,1mmAq=9.8Pa。) 噪音水平：39.1dB/A（噪声在测量的时候其频率计权一般有 A、C、E、L 四种形式, 一般来说通常噪声监测的计权方式是 A 计权。) 二、实验任务 1）设计界面标注控制系统名称 ，注明：“专业+学号+姓名”。 2）基于 NI Elvis Ⅱ开发平台，应用 Labview2015 软件编程，设计完成根据指定直升机状态，实时监测控制直升机的升降状态。显示实时监控数据与曲线， 横坐标为时间单位秒，纵坐标为距离。实时 PID 参数设置与整定，调试出稳定的直升机升降监控系统，保存记录几组 PID 参数整定下的控制曲线图对比比例、积分、微分作用。 3）设计实现 PID 自动控制与手动控制的自由切换。 4）设计程序启动与结束等按钮功能，满足停止按钮释放所有缓存。 三、LabVIEW 设计过程及说明 基本编程思想是通过读取模拟直升机平台上的霍尔元件数值，计算出模拟直升机的位置高低，再通过 PID 参数计算出此时位置所对应的供给直升机的电压值，从而实现直升机平台的升降。 首先需要测量霍尔元件数值变化范围。利用上学期所给例程，我们得知最低值为 2.5，最高值为 4。我们将在这个范围内进行位置设定。 在具体编程过程中，我们首先应确定程序的输入和输出，程序输入应对应霍尔元件的数值和给定的直升机电压数值，对霍尔元件数值采样后将其和给定电压值一起接入 PID 控制器的输入端，通过给定 PID 参数计算出此时对应的输出电压值，将其输出到直升机处，最终实验直升机的自动稳定控制。为了增强系统的稳定性，我们设定了 PID 输出的阈值（经测试为 4-12V）。完成了实际功能后，我们增加了程序的显示部分，能够更加直观的将实际位置和设定位置显示在程序中，便于我们观察和控制。 在完成了自动控制后，我们在程序中增加手动控制部分，即手动设置直升机的电压，通过假如一个按钮，实验逻辑判断，若为真，则执行上图中自动部分， 若为假，则进行手动调节。为了更好的手动控制电压，我们在显示部分中增加了旋钮来控制电压。 图1 LabVIEW 程序框图 四、实验结果与分析 1.手动控制模式 调节PID控制参数Kc=1.5, Ti=0.035, Td=0.004，改变设定值，观察电压的变化。 图2 Kc=1.5, Ti=0.035,Td=0.004霍尔电压上升时变化曲线 图3 Kc=1.5, Ti=0.035, Td=0.004霍尔电压下降时变化曲线 2.自动模式 1)调节比例参数 Kc （a）Kc=0.5 （b）Kc=2.5 图 4 不同 Kc 下的霍尔传感器示数曲线 分析： Kc 过大会引起系统震荡，Kc 过小会使得调节时间变长。 2)调节积分参数 Ti （a）Ti=0.015 （b）Ti=0.070 图 5 不同Ti 下的霍尔传感器示数曲线 分析： Ti 减小会使得调节时间变长，超调量增加。 3)调节微分参数 Td （a）Td=0.001 （b）Td=0.020 图 6 不同Td 下的霍尔传感器示数曲线 分析：Td 增大会略微减小超调量，但过大的 Td 会使得系统矫枉过正而变得不稳定。 五、实验结果讨论 本次实验是通过PID控制器实现直升机姿态控制系统设计，改变PID控制器参数会对调节时间、超调量和稳态误差造成影响。其中Kc 过大会引起系统震荡，Kc 过小会使得调节时间变长；Ti 减小会使得调节时间变长，超调量增加；Td 增大会略微减小超调量，但过大的 Td 会使得系统矫枉过正而变得不稳定。通过对以上参数分析，我们得到了性能较好的一组参数为 Kc=1.500，、Ti=0.035、Td=0.004，该参数下调节时间较短，超调量较少，系统较稳定。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"控制","slug":"控制","permalink":"https://renzehua1998.github.io/tags/%E6%8E%A7%E5%88%B6/"},{"name":"LabVIEW","slug":"LabVIEW","permalink":"https://renzehua1998.github.io/tags/LabVIEW/"}]},{"title":"电子线路设计下中期报告","date":"2020-06-22T09:09:00.000Z","path":"2020/06/22/电子线路设计下中期报告/","text":"大三下电子线路设计下中期报告 一、开始的准备 (一)软件准备 在上学期电子线路设计实验一中我们主要用到了Proteus和keil两个软件的联调仿真，但是这学期的实验板使用的C8051F020单片机在Proteus当中找不到。在查阅相关资料和网上求证后得知，该单片机系统比较复杂，无法用软件仿真，只能在实物上面调试。在当前条件下只能先自己完成代码部分。 关于查看使用单片机型号的问题，我经过学习了解到，应该Project-&gt; Select Device for Target即可查看单片机型号。在例程中查看发现该单片机在Silicon Laboratories.Inc.下面。选择C8051F020单片机芯片即可完成工程的初始创建。 (二)硬件准备 经过前期和老师的交流，我得知学校的实验板上面是没有对应的SD卡读卡模块的，而我的工程中包含相应的读卡器，所以需要自己外接。我在网上查看了对应的单片机读卡模块，加上手头有一张2GB micro SD卡，我选中了下面两款读卡模块： 而我们的单片机对应参数为： 供电电压3.3V，比较而言，选择第二个模块比较合适，可以直接挂接在实验板上，不用另外加其他电源。型号为120801。 这个模块的外形如下，支持大小两张卡，使用SPI方式读写即可，而C8051F020支持SPI读写方式。 二、上学期的遗留问题 上学期仿真软件中的mmc文件（SD卡映像文件）是当时找到的例程中已经写好的，我没有弄清楚它里面的机制。非常感谢刘老师，她给我推荐了软件winimage，可以把文件另存为一个软盘映像文件，但是在具体操作中读入失败，原因可能是我封装的文件格式不对。尝试了各种类型的文件，包括二进制文件，文本文件等等都显示为乱码，于是我直接把转码后的二进制文件后缀改为.mmc发现可以显示图片。 转码文件 存为二进制改为mmc 但是显示明显有问题，我认为这是因为原始显示图片时文件的扫描方式不对导致了这一的结果。更改扫描方式以后虽然有了大致的图像，但是仍然是错位的两幅图： 预期显示的图片 实际显示的图片 研究具体扫描方式时，由于之前例程中有显示模块，故我把它拿来查看，发现扫描方式应该是水平，但是字节是垂直的，只保留一半的显示函数时很明显能说明问题： 扫描方式 修改函数后的显示 所以在转码时采取这种方式，转为二进制bin文件并改后缀名为mmc即可。 造成左边图像的原因是字节内的像素反了，也就是每八行的图像颠倒了，修改为字节内像素反序即可，如右图所示。 显示效果如下： 字节未反 字节反序 另外，用ultraedit软件打开原来的SD.mmc文件，里面其实也是二进制文件，将其中的一幅图单独显示即可看出里面的像素确实是这样安排的，其中自己的图片存为img1.mmc，抽取的一帧存为img2.mmc。 那么，把这些像素帧放到一起不断地读取就可以形成动画效果了，但是工具所限，UltraEdit编辑功能有限，我用记事本将转码后的20帧的二进制文件合并，发现漏了几个字节，这就导致动画播放产生了位移，并且其中还有好多横线影响观感。其中gf.mmc是合成的第一个文件，gf2.mmc是6个原文件合并，位移效果更明显。 直接合并播放效果 改进后播放效果 在网上找到了一个可以合并bin文件的软件（附在作业中），直接运行即可： 指定输入文件夹和输出文件夹就能得到合并后的bin文件，将后缀名改成mmc即可。在工程文件中gf3.mmc是用软件合成的完整文件，gf4.mmc是4个gf3合成的结果，播放时间更长。 而对于新的单片机，需要采用新的读卡方式，但是最终仍然要落在读取字节信息上面，合成对应的二进制文件仍然是必不可少的。 之前例程中也是采用SPI总线方式读取SD卡，我也在网上找到了相应的C8051F020单片机读写SD卡的例程，以此在后续编写新的程序。 三、工程建立遇到的问题与解决 (一)模块化编程 之前C51编程没有逻辑，不讲规则，但是在看了几个例程之后发现可以使用以下几步使得工程变得有条理。 通过设置头文件指定文件夹、选择object、list文件夹等方法将不同类比的文件分别存储便于管理，在工程中也可以新建group管理不同模块的代码。 (二)关于初始化 之前各种模块的初始化都是直接放在主函数里面，这样安排没有条理，代码可读性差，和例程学习将所有的初始化函数放到一起命名为Init_Device，如图所示： (三)禁止看门狗 用户的应用软件应周期性地向WDTCN写入0xA5，以防止看门狗定时器溢出。每次系统复位都将使能并启动WDT。向WDTCN寄存器写入0XDE后再写入0XAD将禁止WDT。所以，在前面的时钟初始化程序中，{WDTCN=0xde；；//禁止看门狗定时器WDTCN=0xad；}禁止WDT。 看门狗的禁止用以下代码实现： EA=0；/最好将中断关闭 WDTCN=0xde；WDTCN=0xad；EA=1；/恢复中断 注意：写0xDE和0xAD必须在4个机器周期内完成，否则禁止操作不生效。中断的关闭就是为了保证此两条操作代码能在4个周期内完成。 (四)中断的设定 51单片机中可以设置四种中断，其中的按键功能可以用中断实现，之前我是放在循环里面去轮询，这样功耗大且费时间，下面计划改为中断方式，这是代码改进中很重要的一步。 关于interrupt函数用法： void+函数名+interrupt+数字0～4 0表示外部中断0 1表示定时器/计数器（TO） 2外部中断1 3：定时器/计数器（T1） 4：串行口 这个就是按键的中断服务子程序 (五)防止头文件重复包含 在先设定好工程基本结构，导入对应子函数框架尝试编译时，编译器报错说重复定义了东西，再次查看例程发现在头文件中都加了这样两句程序： #ifndef C8051F020_H #define C8051F020_H 这样做的目的是防止两次包含同一头文件产生冲突，这样就可以避免。 (六)下一步的工作 这是目前程序的结构，其中led，lcd的部分很快就可以改好，其中有点问题的是将按键从轮询改为中断，在上学期嵌入式实验中曾经使用过中断，这次有例程的帮助相信也可以解决。而SD卡的读写将会是一个挑战，我将结合查到的例程继续学习，争取可以在开学以前实现。 C8051F020 SPI特殊功能寄存器和I/O引脚的配置： C8051F020的SPI引脚分配为 P0.0——CLK P0.1——MISO P0.2——MOSI P0.3——NSS（一主多从模式，接高电平+Vdd） P0.4~P0.7——Slaves 片选信号 C8051F020SPI特殊功能寄存器的配置： ①SPI控制寄存器SPI0CN的配置： 选择MSTEN=1，使能主方式；SPIEN=1，使能SPI。 SPIF WCOL MODF RXOVRN TXBSY SLVSEL MSTEN SPIEN 0 0 0 0 0 0 1 1 所以，PI0CN=03H。 ②SPI配置寄存器SPI0CFG的配置： CKPHA CKPOL BC2 BC1 BC0 SPIFRS2 SPIFRS1 SPIFRS0 1 1 0 0 0 1 1 1 选择CKPHA=1，在SCK周期的第二个边沿采样数据；CKPOL=1，SCK在空闲状态处于高电平；BC2BC0=000，表示数据从最高位一直发送到最低位；SPIFRS2 SPIFRS0=111，表示发送8位数据。 所以，SPI0CFG=16H。 ③内部振荡器控制寄存器OSCICN的配置 MSCLKE —— —— IFRDY CLKSL IOSCEN IFCN1 IFCN0 0 0 0 1 0 1 1 1 选择IFRDY=1，内部振荡器频率按照IFCN位确定的频率运行；IOSCEN=1使能内部振荡器；IFCN1~IFCN0=11，内部振荡器频率为16MHz。 所以，OSCICN=17H。 ④SPI时钟速率寄存器SPI0CKR配置： SCR7 SCR6 SCR5 SCR4 SCR3 SCR2 SCR1 SCR0 0 1 0 0 0 0 0 1 设定SPI的时钟为fSCK=100KHz， 则SPI0CKR =[(SYSCLK/2)/ fSCK]—1=79=41H。 所以，SPI0CKR=41H。 ⑤端口I/O交叉开关寄存器0（XBR0）的配置： CP0E ECI0E PCA0ME UART0EN SPI0EN SMB0EN 0 0 0 0 0 0 1 0 选择SPI0EN=1，SPI总线使能，SPI的SCK、MISO、MOSI、NSS分别连到P0.0、P0.1、P0.2和P0.3四个端口引脚。 所以，XBR0=02H。 ⑥端口I/O交叉开关寄存器1（XBR1）的配置： WEAKPUD XBARE — T4EXE T4E UART1E EMIFLE CNVSTE 0 1 0 0 0 0 0 0 选择WEAKPUD=0，全局弱上拉；XBARE=1，交叉开关使能。 所以，XBR1=40H。 ⑦端口0输出方式寄存器P0MDOUT的配置： D7 D6 D5 D4 D3 D2 D1 D0 0 0 0 0 1 1 1 1 选择SCK、MISO、MOSI、NSS为推挽输出方式。 所以，P0MDOUT=0DH。 其中最后第七条，MISO应该为开漏输出，相应的位为0。P0MDOUT值需要再算， http://bbs.eeworld.com.cn/thread-114758-1-1.html","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"计算机网络与通信实验报告","date":"2020-06-01T08:07:00.000Z","path":"2020/06/01/计算机网络与通信实验报告/","text":"大三下计算机网络与通信实验报告 一、实验目的 掌握WireShark软件； 通过监测网络流量理解计算机网络体系结构的分层原理。 掌握TCP、IP、ETHERNET II协议内容。 二、实验内容 安装WireShark软件； 通过浏览器访问www.xjtu.edu.cn，使用WireShark监测应用层、传输层、网络层、数据链路层协议数据单元的内容。 （1）在WireShark中捕获某一应用层协议信息，分析数据中每层协议同网络体系结构的对应分层 （2）在WireShark中捕获某一HTTP协议信息，分析数据中TCP、IP、ETHERNET II协议数据单元内容。 三、实验环境 操作系统：Windows10 实验软件：Wireshark 3.2.4-64bit 使用浏览器：Internet Explorer 四、实验记录 1.安装WireShark软件 注：此处安装汉化版Wireshark 3.2.4-64bit 2．通过WireShark软件捕获实时网络数据 （1）点击“Start”键 （2）打开浏览器，在URL输入www.xjtu.edu.cn并回车 （3）点击“Stop”键 （4）存储当前网络数据捕获结果 3．通过DNS协议单元分析网络体系结构的分层原理 （1）找到一个有www.xjtu.edu.cn内容的DNS单元，分析请求过程的分层情况 （2）找到一个有202.117.1.13内容的DNS单元，分析响应过程的分层情况 4．通过HTTP协议单元分析TCP、IP、ETHERNET II协议数据单元内容 （1）找到一个目的地址为202.117.1.13的HTTP单元，分析请求过程中的TCP、IP、ETHERNET II协议数据单元内容 （2）找到一个源地址为202.117.1.13的HTTP单元，分析响应过程中的TCP、IP、ETHERNET II协议数据单元内容 五、实验结论及分析 对于每个数据包，我们采用先整体分析，再从上向下的分析方法，即先分析整个数据包的性质，再按照应用层、传输层、网络层、网络层、数据链路层的顺序进行展开分析，上一级的协议数据单元（PDU）的全部或一部分就是下一层的用户数据（SDU），仅分析每一层的协议控制信息（PCI）即可。 1. 通过DNS协议单元分析网络体系结构的分层原理 （1）找到一个有www.xjtu.edu.cn内容的DNS单元，分析请求过程的分层情况 如第四部分所示，我们已经找到了有www.xjtu.edu.cn内容的DNS单元，它是一个请求过程中产生的DNS协议单元。 它每一层遵循的协议如下： 应用层：DNS——域名系统（服务）协议 传输层：UDP——用户数据报协议 网络层：IPv4——网际协议版本4 数据链路层：Ethernet II——以太网协议 ① 数据包情况： 里面主要是接口ID、封装形式、到达时间、纪元时间、帧编号（108）、帧长（75bytes）、捕获长度（75bytes）、框架内的协议等等信息。 ② 应用层（DNS）协议字段： DNS报文结构： 第一个Transaction ID为事务 ID，是DNS 报文的 ID 标识。对于请求报文和其对应的应答报文，该字段的值是相同的。通过它可以区分 DNS 应答报文是对哪个请求进行响应的。此处为0xbd8d。 第二个Flags为标志字段，2字节，此处为0x0100 Flags结构：  QR（Response）：查询请求/响应的标志信息。查询请求时，值为 0；响应时，值为 1。（1byte）  Opcode：操作码。其中，0 表示标准查询；1 表示反向查询；2 表示服务器状态请求。（4byte）  AA（Authoritative）：授权应答，该字段在响应报文中有效。值为 1 时，表示名称服务器是权威服务器；值为 0 时，表示不是权威服务器。  TC（Truncated）：表示是否被截断。值为 1 时，表示响应已超过 512 字节并已被截断，只返回前 512 个字节。  RD（Recursion Desired）：期望递归。该字段能在一个查询中设置，并在响应中返回。该标志告诉名称服务器必须处理这个查询，这种方式被称为一个递归查询。如果该位为 0，且被请求的名称服务器没有一个授权回答，它将返回一个能解答该查询的其他名称服务器列表。这种方式被称为迭代查询。  RA（Recursion Available）：可用递归。该字段只出现在响应报文中。当值为 1 时，表示服务器支持递归查询。  Z：保留字段，在所有的请求和应答报文中，它的值必须为 0。  rcode（Reply code）：返回码字段，表示响应的差错状态。当值为 0 时，表示没有错误；当值为 1 时，表示报文格式错误（Format error），服务器不能理解请求的报文；当值为 2 时，表示域名服务器失败（Server failure），因为服务器的原因导致没办法处理这个请求；当值为 3 时，表示名字错误（Name Error），只有对授权域名解析服务器有意义，指出解析的域名不存在；当值为 4 时，表示查询类型不支持（Not Implemented），即域名服务器不支持查询类型；当值为 5 时，表示拒绝（Refused），一般是服务器由于设置的策略拒绝给出应答，如服务器不希望对某些请求者给出应答。 QR=0表示是查询请求；Opcode=0表示标准查询；AA无效（请求报文无效）；TC=0表示未被截断；RD=1表示期望得到一个递归查询；RA无效（请求报文）；Z=0保留字段必须为0；rcode=0表示没有错误。 第三个Questions为问题计数，是DNS 查询请求的数目。此处Questions=1表示请求查询的数目为1 第四到第六个Answer RRS、Authority RRs、Additional RRs分别表示： 回答资源记录数（DNS 响应的数目）；权威名称服务器计数（权威名称服务器的数目）；附加资源记录数（额外的记录数目（权威名称服务器对应 IP 地址的数目））它们都是0，表示都没有。 第七个Queries是问题部分，它的结构为：  Name查询名：一般为要查询的域名，有时也会是 IP 地址用于反向查询。  Type查询类型：DNS 查询请求的资源类型。通常查询类型为 A 类型，表示由域名获取对应的 IP 地址。  Class查询类：地址类型，通常为互联网地址，值为 1。 此处返回的结果为： 查询名字段：这里请求域名www.xjtu.edu.cn；查询类型字段：这里为A类型；查询类字段：这里为IN，表示互联网地址 后面的缺省所以不再表示，将在第二小问中具体介绍。 ③ 传输层（UDP）协议字段： UDP报文格式如下图： 可以看出： 源端口为50005，是我自己电脑分配的端口；目的端口为53，是学校服务器的默认端口；数据报长度为41bytes；校验值为0xde33 ④ 网络层（IPv4）协议字段： IP数据包结构： Version（版本）:4（IPv4）； Header Length（头长）:20 bytes(5)；服务类型：0x00，全部为正常；包裹总长：61bytes；重组标识：0x73d6；标志位：0000允许数据报分段，数据包后面没有包，该包为最后的包；段偏移量：0；生存时间：64；协议代码：UDP（17）；头部校验和：0x063f；32位原始地址：192.168.1.105，这是我们宿舍局域网为我分配的IP地址；32位目的地址：61.134.1.4，这应该是局域网路由器的公网IP地址，经过查询，确实是陕西西安电信网的DNS服务器的IP地址。 ⑤ 数据链路层（Ethernet II）协议字段： Ethernet II帧格式： 目的MAC地址：Tp-LinkT_f7:ec:a2 (20:6b:e7:f7:ec:a2)这是我们宿舍路由器的MAC地址，前面有普联公司特有的MAC字段：20:6b:e7；原MAC地址：IntelCor b2:81:c1(cc:2f:71:b2:81:c1)，这是我电脑的MAC地址，前面有英特尔酷睿的特有字段：cc:2f:71。 数据字段类型：IPv4 （2）找到一个有202.117.1.13内容的DNS单元，分析响应过程的分层情况 如第四部分所示，我们已经找到了有202.117.1.13内容的DNS单元，它是一个响应过程中产生的DNS协议单元。 它每一层遵循的协议如下： 应用层：DNS——域名系统（服务）协议 传输层：UDP——用户数据报协议 网络层：IPv4——网际协议版本4 数据链路层：Ethernet II——以太网协议 ① 数据包情况： 里面主要是接口ID、封装形式、到达时间、纪元时间、帧编号（113）、帧长（91bytes）、捕获长度（91bytes）、框架内的协议等等信息。 ② 应用层（DNS）协议字段： 事务 ID为0xbd8d，和之前请求的ID相匹配； 标志位分别为：QR=1表示是响应；Opcode=0表示标准查询；AA=0表示不是权威服务器；TC=0表示未被截断；RD=1表示请求方希望递归查询；RA=1表示服务器支持递归查询；Z=0保留字段必须为0；rcode=0表示没有错误。 Questions=1表示请求查询的数目为1；Answer RRS=1表示回答资源记录数为1、Authority RRs、Additional RRs都是0，表示都没有。 Queries部分： 查询名字段：这里请求域名www.xjtu.edu.cn；查询类型字段：这里为A类型；查询类字段：这里为IN，表示互联网地址 资源记录部分：资源记录部分是指 DNS 报文格式中的最后三个字段，包括回答问题区域字段、权威名称服务器区域字段、附加信息区域字段。这三个字段均采用一种称为资源记录的格式，格式如图所示。 查询名字段：这里请求域名www.xjtu.edu.cn；查询类型字段：这里为A类型；查询类字段：这里为IN，表示互联网地址；生存时间：987（16min27s）；数据长度：4；资源数据（返回的地址）：202.117.1.13。 ③ 传输层（UDP）协议字段： 目的端口为50005，是我自己电脑分配的端口；原端口为53，是学校服务器的默认端口；数据报长度为57bytes；校验值为0xed02 ④ 网络层（IPv4）协议字段： Version（版本）:4（IPv4）； Header Length（头长）:20 bytes(5)；服务类型：0x00，全部为正常；包裹总长：77bytes；重组标识：0x73d6和请求的标识相同；标志位：0000允许数据报分段，数据包后面没有包，该包为最后的包；段偏移量：0；生存时间：47；协议代码：UDP（17）；头部校验和：0x172f；32位原始地址：61.134.1.4，这是陕西西安电信网的DNS服务器的IP地址；32位目的地址：192.168.1.105，这是我们宿舍局域网为我分配的IP地址。 ⑤ 数据链路层（Ethernet II）协议字段： 目的MAC地址：IntelCor b2:81:c1(cc:2f:71:b2:81:c1)，这是我电脑的MAC地址，前面有英特尔酷睿的特有字段：cc:2f:71；原MAC地址：Tp-LinkT_f7:ec:a2 (20:6b:e7:f7:ec:a2)这是我们宿舍路由器的MAC地址，前面有普联公司特有的MAC字段：20:6b:e7。 数据字段类型：IPv4 2.通过HTTP协议单元分析TCP、IP、ETHERNET II协议数据单元内容 （1）找到一个目的地址为202.117.1.13的HTTP单元，分析请求过程中的TCP、IP、ETHERNET II协议数据单元内容 如第四部分所示，我们已经找到了目的地址为202.117.1.13的HTTP单元，它是一个请求过程中产生的HTTP数据单元。 它每一层遵循的协议如下： 应用层：HTTP——请求-响应协议 传输层：TCP——传输控制协议 网络层：IPv4——网际协议版本4 数据链路层：Ethernet II——以太网协议 ① 数据包情况： 里面主要是接口ID、封装形式、到达时间、纪元时间、帧编号（159）、帧长（340bytes）、捕获长度（340bytes）、框架内的协议等等信息。 ② 应用层（HTTP）协议字段： HTTP的请求报文包括：请求行(request line)、请求头部(header)、空行 和 请求数据(request data) 四个部分组成。 请求行包括： 请求方法，URL(包括参数信息)，协议版本这些信息： GET /_sitegray/_sitegray_d.css HTTP/1.1 请求头部(Header)是一个个的key-value值： 空行(CR+LF)：请求报文用空行表示header和请求数据的分隔： 请求数据：GET方法没有携带数据， POST方法会携带一个body： ③ 传输层（TCP）协议字段： TCP数据包结构： 源始端口：52203（本机端口）；目的端口：80（TCP协议默认端口）；数据序号：1；确认序号：1；偏移（头部字节数）：20bytes；保留部分：0；U、A、P、R、S、F：0 1 1 0 0 0（紧急指针字段无效，确认号字段有效，上交数据，复位字段无效，同步字段无效，中止字段无效）；窗口字段：1024（对应的窗口大小为262144）；包校验和：0x047f；紧急指针：0。 ④ 网络层（IPv4）协议字段： Version（版本）:4（IPv4）； Header Length（头长）:20 bytes(5)；服务类型：0x00，全部为正常；包裹总长：326bytes；重组标识：0x28b5；标志位：4000禁止数据报分段，数据包后面没有包，该包为最后的包；段偏移量：0；生存时间：64；协议代码：TCP（6）；头部校验和：0x8369；32位原始地址：192.168.1.105，这是我们宿舍局域网为我分配的IP地址；32位目的地址：202.117.1.13，这是学校服务器的IP地址。 ⑤ 数据链路层（Ethernet II）协议字段： 目的MAC地址：Tp-LinkT_f7:ec:a2 (20:6b:e7:f7:ec:a2)这是我们宿舍路由器的MAC地址，前面有普联公司特有的MAC字段：20:6b:e7；原MAC地址：IntelCor b2:81:c1(cc:2f:71:b2:81:c1)，这是我电脑的MAC地址，前面有英特尔酷睿的特有字段：cc:2f:71。 数据字段类型：IPv4 （2）找到一个源地址为202.117.1.13的HTTP单元，分析响应过程中的TCP、IP、ETHERNET II协议数据单元内容 如第四部分所示，我们已经找到了源地址为202.117.1.13的HTTP单元，它是一个响应过程中产生的HTTP数据单元。 它每一层遵循的协议如下： 应用层：HTTP——请求-响应协议 传输层：TCP——传输控制协议 网络层：IPv4——网际协议版本4 数据链路层：Ethernet II——以太网协议 ① 数据包情况： 里面主要是接口ID、封装形式、到达时间、纪元时间、帧编号（164）、帧长（226bytes）、捕获长度（226bytes）、框架内的协议等等信息。 ② 应用层（HTTP）协议字段： HTTP的响应报文包括：状态行，响应头，空行，数据(响应体)： 状态行包括：HTTP版本号，状态码和状态值组成： 响应头类似请求头，是一系列key-value值： 空白行：同上，响应报文也用空白行来分隔header和数据： 响应体：响应的data，本例中是一段js脚本。 在另一个例子中，响应体是一张jpg图片： ③ 传输层（TCP）协议字段： 源始端口：80（TCP协议默认端口）；目的端口：52203（本机端口）；数据序号：4321；确认序号：280；偏移（头部字节数）：20bytes；保留部分：0；U、A、P、R、S、F：0 1 1 0 0 0（紧急指针字段无效，确认号字段有效，上交数据，复位字段无效，同步字段无效，中止字段无效）；窗口字段：123（对应的窗口大小为15744）；包校验和：0xec9a；紧急指针：0。 ④ 网络层（IPv4）协议字段： Version（版本）:4（IPv4）； Header Length（头长）:20 bytes(5)；服务类型：0x00，全部为正常；包裹总长：212bytes；重组标识：0xfcfd；标志位：4000禁止数据报分段，数据包后面没有包，该包为最后的包；段偏移量：0；生存时间：59；协议代码：TCP（6）；头部校验和：0xb492；32位原始地址：202.117.1.13，这是学校服务器的IP地址；32位目的地址：192.168.1.105，这是我们宿舍局域网为我分配的IP地址。 ⑤ 数据链路层（Ethernet II）协议字段： 源MAC地址：Tp-LinkT_f7:ec:a2 (20:6b:e7:f7:ec:a2)这是我们宿舍路由器的MAC地址，前面有普联公司特有的MAC字段：20:6b:e7；目的MAC地址：IntelCor b2:81:c1(cc:2f:71:b2:81:c1)，这是我电脑的MAC地址，前面有英特尔酷睿的特有字段：cc:2f:71。 数据字段类型：IPv4 六、实验体会 这次实验我通wireshark软件对访问学校官网的过程做了简单的抓包，通过软件的展示，我研究了应用层的两个协议：DNS和HTTP的不同工作过程。它们都遵循同样的分层模式，在数据链路层都是Ethernet II，在网络层都是IPv4，这与我们宿舍网络配置有关。而对于传输层，DNS使用的是不太可靠的UDP协议，而HTTP采用的是比较可靠的TCP协议，这也与它们传递的信息不同有关。 在实验过程中，我分析了DNS和HTTP的简要结构，也在这个基础上向下研究了TCP、UDP、IP、Ethernet II的协议数据单元的内容，对于计算机网络的分层结构有了更深入的了解。实验中最大的感受就是在互联网传递一个简单信息时要产生许多的“冗余信息”，正是网络中每一层产生的这些控制信息，才能保证我们在网络中使用不太可靠的物理设备进行可靠的数据连接。 七、评定成绩","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"计网","slug":"计网","permalink":"https://renzehua1998.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"倒立摆的模糊控制实验（基于matlab-simulink仿真）","date":"2020-05-30T03:15:01.000Z","path":"2020/05/30/倒立摆的模糊控制实验（基于matlab-simulink仿真）/","text":"大三智能控制课程大作业，用similink仿真二阶倒立摆系统，并尝试使用模糊控制器进行姿态控制 实验目的：理解和掌握模糊控制系统的构成和设计方法，为实际工程应用打下基础。 基本要求：掌握以误差及其变化率为输入的典型模糊控制器的设计方法，了解影响模糊控制器性能的关键参数及调节方法。针对被控对象，构建合适的模糊控制器，搭建模糊控制系统。 实验内容提要：针对典型的二阶以上被控对象，设计模糊控制器。包括控制器输入输出量的选择，输入输出论域的模糊划分，模糊规则库的建立等。利用设计完成的模糊控制在Simulink中搭建模糊控制系统，要求该系统稳定且具有良好的动态及稳态特性。 实验工作概述：主要针对倒立摆进行了建模与模糊控制仿真，其中实验1-1是仅针对角度的模糊PID控制，实验1-2是针对位置与角度的分段模糊控制。后面也尝试进行了二级倒立摆的模糊控制设计，但由于知识水平不够没能完全实现，仅实现了第一级的直立控制。 实验1 单级倒立摆的PID模糊控制 一、被动对象数学描述与特性分析 关于倒立摆的相关背景：倒立摆，Inverted Pendulum ，是典型的多变量、高阶次、非线性、强耦合、自然不稳定系统。倒立摆系统的稳定控制是控制理论中的典型问题，在倒立摆的控制过程中能有效反映控制理论中的许多关键问题 ，如非线性问题、鲁棒性问题、随动问题、镇定、跟踪问题等。因此倒立摆系统作为控制理论教学与科研中典型的物理模型 ，常被用来检验新的控制理论和算法的正确性及其在实际应用中的有效性。所以我此次实验采用一阶倒立摆来验证。 当摆杆夹角很小时，近似线性化处理： 根据微分方程组做拉普拉斯变换联立求得外力针对角度的传递函数： 将各种参数输入matlab， 编辑一个函数脚本GetPendulum来求传递函数的系数： 12345678function [G] = GetPendulum(M,m,l)b = 0.15;I = 0.005;g = 9.81;q = (M+m)*(I+m*l^2)-(m*l)^2;num = [m*l/q 0 0];den = [1 b*(I+m*l^2)/q (-(M+m)*m*g*l)/q (-b*m*g*l)/q 0];G=tf(num,den);end 当M=2，m=0.8，l=0.25时，求得： 在这里插入图片描述 这是一个典型的二阶系统 二、模糊控制器的设计步骤与具体参数选择 模糊集合设计： 总共有两个输入三个输出，输入角度和角度微分的模糊集合划分都相同，论域为[-5,5]，模糊集合为3个，分别命名为：[N Z P]，输出P I D三个参数的范围分别为[110，120]，[115，125]，[80，90]，模糊集合为3个命名为：[S M B]它们的分布如上图所示。 模糊规则库的设计： 在这里插入图片描述 整个模糊控制器如下： 在这里插入图片描述 三、控制系统仿真程序的设计步骤与运行结果 在simulink中搭建简单的反馈控制模型，其中两个并行系统的控制任务分别由模糊PID控制器和普通PID控制器担任。普通PID控制器的三个控制参数分别选为：P:115 I:120 D:85。 在这里插入图片描述 输入分别选择阶跃信号和随机信号，对比输出结果： 阶跃信号输出结果 随机信号输出结果 四、总结与结论 可以看出，对于阶跃输入，虽然普通PID控制器响应较快，但是模糊PID控制效果相比更加平滑。而对于随机信号输入，普通PID的输出已经几乎跟随输入信号，失去了控制效果，而模糊PID控制器可以较好地克服随机信号的干扰，输出比较平滑且稳定。 当然，这只是将非线性的倒立摆系统简单地在平衡点附近近似为线性系统，所以对于非线性的倒立摆系统来说，当角度比较大时便不再适用，而且输入仅为角度，无法做到对于位置的控制，甚至有可能超出运动范围。这种设计在实际应用中可能并不合理，所以下面我设计了倒立摆的分段模糊控制系统。 实验2 单级倒立摆的分段模糊控制 一、被动对象数学描述与特性分析 重新建立单级倒立摆的精确微分方程模型 单级倒立摆示意图如下： 在这里插入图片描述 各种参数含义与取值： 符号 物理意义 单位与大小 小车质量 2kg 小球质量 0.8kg 摆杆长度 0.25m 小车摩擦系数 0.005kg/s 摆杆摩擦系数 0.0005 小车受力（控制力） -N 小车和小球位移 -m 摆杆摆角 -rad 建模过程： 由于现代控制理论中状态空间的相关内容还没有学完，我在这里只建立最朴素的微分方程模型，代入simulink直接求值。 根据拉格朗日方程，我们可以列出倒立摆的运动关系： 在上式中： 将和代入中得： 此时列拉普拉斯方程： 在上式中代入得： 解出对应的和： 此时利用状态空间方程的一点知识，构建状态变量： 列出四个状态变量的表达式： 它们就是我们得出的微分方程模型。 二、模糊控制器的设计步骤与具体参数选择 初步设计： 模糊集合设计： 总共有两个输入一个输出，三者模糊集合的划分都相同，此处仅列出误差e和输出u。论域为[-6,6]，模糊集合为5个，分别命名为：[NB NS ZO PS PB]，它们的分布如上图所示。由于在偏差过大时输出的控制应当几乎相同，故两侧的模糊集合曲线为梯形。 模糊规则库的设计： e de NB NS ZO PS PB NB NB NB NB NS NB NS NB NB NS PB PS ZO NB NB ZO PB PB PS PS NB PS PB PB PB PB PS PB PB PB 在这里插入图片描述 在实际仿真中，经过一系列的实验，我发现在这种参数设置下控制效果最好，但是控制精度似乎还不尽如人意，所以我考虑将位置和角度的模糊控制器分别设计并增加控制器的精度。 改进设计： 模糊集合设计： 总共有两个输入一个输出，三者模糊集合的划分都相同，此处仅列出误差e和输出u。论域为[-6,6]，模糊集合为7个，分别命名为：[NB NM NS ZO PS PM PB]，它们的分布如上图所示。 模糊规则库的设计： 位置规则库： e NB NM NS ZO PS PM PB NB NB NB NB NM NM NS NS NM NB NB NM NM NS NS ZO NS NM NM NS NS ZO PS PS ZO NM NS NS ZO PS PS PM PS NS NS ZO PS PS PM PM PM ZO ZO PS PS PM PM PB PB PS PS PM PM PB PB PB 在这里插入图片描述 角度规则库： e NB NM NS ZO PS PM PB NB NB NB NB NB NM ZO ZO NM NB NB NB NM NM ZO ZO NS NM NM NM NS ZO PS PS ZO NM NM NS ZO PS PM PM PS NM NS ZO PS PM PM PM PM ZO ZO PM PM PB PB PB PB ZO ZO PM PM PB PB PB 在这里插入图片描述 针对位置和角度的不同性质，重新设计模糊控制器，得到的simulink仿真结果得到了显著提高。 在调节参数时，我发现位置误差具有的线性较强，故控制规则曲面接近于平面比较合适；而角度误差的非线性更强，在角度误差和误差微分一个为PB，另一个为NB时，输出控制位ZO最为合适。 三、控制系统仿真程序的设计步骤与运行结果 建立simulink仿真模型： 我们将得到的微分方程模型代入simulink中，其中子系统Pendulum Dynamics是倒立摆的模拟，输入量是： 输出量是下一时刻对应的 从而实现对系统的仿真。 总体模型： 其中将位置误差、位置误差的微分作为模糊控制器1的输入，将角度误差、角度误差的微分作为模糊控制器2的输入，最后将两种控制效果合成（角度输入控制器效果为正，位置输入控制器效果为负）作为力输入倒立摆子系统中进行计算，子系统将下一步的四个参数反馈回控制器。 在这里插入图片描述 子系统： 在这里插入图片描述 其中的两个函数就分别是上面推导初的和的微分方程表达式。 同时，为了直观观察，我还编写了matlab窗口运行的仿真程序，将模糊控制过程可视化为动画，不过由于整个过程都是用窗口程序单独编写的，在求变量微分时采用的一阶差分来代替，而且为了计算快速仿真时间间隔选用0.01s，窗口仿真动画与simulink仿真曲线稍有差异。其中仿真动画程序参考了GitHub上面的一个项目，地址为：点击访问 运行效果如下图： 在这里插入图片描述 原始控制器仿真结果： 原始控制器位置响应曲线（x1为位置，x2为速度） 在这里插入图片描述 原始控制器角度曲线（x3为角度，x4为角速度） 在这里插入图片描述 原始控制器输出曲线（F为力，ux为控制器1输出，uq为控制器2 输出） 改进控制器仿真结果： 在这里插入图片描述 改进控制器位置响应曲线（x为位置，dx为速度） 在这里插入图片描述 原始控制器角度曲线（θ为角度，dθ为角速度） 在这里插入图片描述 原始控制器输出曲线（F为力，ux为控制器1输出，uq为控制器2 输出） 四、总结与结论 从上述仿真结果可以看出，在10秒的仿真时间内，原始模糊控制器虽然可以完成控制，但是控制效果不好，其状态变量会经过较大的震荡，而控制力的输出虽然比较稳定，但合成它的两个模糊控制器输出量也呈现震荡形式。而改进控制器在各种状态参数都稳定的前提下，两个控制器的输出量也呈现收敛的趋势。 但是我在试着用参考资料代入我的模型求解时却遇到了一些问题，相反第一种控制器控制下系统稳定得更快，这可能与窗口程序中时间间隔选取过大等等条件有关。由于这是在不使用模糊控制器设计软件和simulink的前提下编写的程序，比较具有创新性，所以我在提交的作业中还是附上了窗口程序的代码和录制的动画视频。（见“各种图片……”文件夹） 同时，根据simulink求解的结果我也对其进行了动画可视化处理，首先通过运行对应的simulink模型，再运行Animation.m脚本即可查看并录制动画。 备注：后续进行了二级倒立摆的尝试，由于增加的角度变量与前两个状态变量有较强的非线性耦合性，所以模糊规则较难设计。最终只能实现第一级直立，稳定状态下第二级是下垂的，后续在学习相关知识后还会继续努力完成。 源代码下载 本文之前发表在CSDN上，链接如下：原文地址","tags":[{"name":"控制","slug":"控制","permalink":"https://renzehua1998.github.io/tags/%E6%8E%A7%E5%88%B6/"},{"name":"matlab","slug":"matlab","permalink":"https://renzehua1998.github.io/tags/matlab/"}]},{"title":"利用BP网络实现非线性函数映射（基于matlab工具箱）","date":"2020-05-28T12:42:25.000Z","path":"2020/05/28/利用BP网络实现非线性函数映射（基于matlab工具箱）/","text":"大三智能控制课程大作业，基于matlab的神经网络简单实现与训练 实验目的：自己设计一个BP网络实现非线性函数映射 基本要求：设有两输入单输出函数 其中自变量x,y的取值范围为 试设计一个BP网络实现此函数映射。要求以完整的实验报告形式描述网络的结构、学习过程、结果，以附录形式附源程序。 一、网络结构 首先建立简单的BP神经网络模型，隐层神经元个数为10，输入二维，为函数的两个自变量x和y，输出为函数值的估计值，为一维。 在此基础上建立三层BP神经网络，两个隐层神经元个数都为10，输入二维，为函数的两个自变量x和y，输出为函数值的估计值，为一维。 在这里插入图片描述 二、学习过程 使用自己编写的子函数GetInput生成训练数据，可以自行指定生成的数据个数。调用格式为：[Input,Output] = GetInput(SampleNum) （1）首先尝试自己通过编程实现简单的BP网络 参数设置为： 总体样本30个，其中训练样本21个，验证样本5个，测试样本4个。 最多训练次数为10000次，允许误差选为10-7，学习速率为0.01。 传输函数为（purelin）最简单的一一对应关系。 训练算法为梯度下降法，不断地对权值矩阵W1、W2，阈值矩阵B1、B2进行修正，最终达到训练效果。 （2）利用matlab自带的神经网络工具箱搭建BP网络 备注：也尝试了GUI界面编程，但是无法以代码形式展现，其工作过程与命令行操作相同。 一共构建了两个网络：10-10-1和10-1，即第一部分中提到的两个网络。 网络10-10-1参数设置为： 总体样本分别为100个和1000个，其中训练样本70%，验证样本15%，测试样本15%。 最多训练次数为10000次，允许误差选为，学习速率为0.01，动量因子为0.9。 隐层传输函数为（tansig），输出层传输函数为（purelin）。 训练算法为神经网络训练中常用的L-M算法（trainlm） 网络10-1参数设置为： 总体样本分别为100个、300个、500个和1000个，其中训练样本70%，验证样本15%，测试样本15%。 最多训练次数为10000次，允许误差选为10-7，学习速率为0.01，动量因子为0.9。 隐层传输函数为（tansig），输出层传输函数为（purelin）。 训练算法为神经网络训练中常用的L-M算法（trainlm） 三、学习结果 （1）自己编程搭建的BP神经网络 在这里插入图片描述 30个训练样本和30个随机样本的验证结果 在这里插入图片描述 网络学习结果拟合图 （2）神经网络工具箱搭建的BP网络 Net1：10-10-1，100个样本 Net2：10-1，100个样本 Net3：10-1，300个样本 Net4：10-1，500个样本 Net5：10-1，1000个样本 Net6：10-10-1，1000个样本 四、误差分析 （1）自己编程搭建的BP神经网络 标准差：3.5937 在这里插入图片描述 （2）神经网络工具箱搭建的BP网络 标准差： 40.4614 / 0.8592 / 0.0310 0.5113 / 0.2013 / 0.2013 五、实验总结 这次实验中，我先尝试使用matlab自己编写了BP神经网络，输入映射函数使用最简单的y=x，训练算法采用梯度下降法。在实际操作中我发现当训练样本数大于28时，极有可能会陷入局部最优解，导致神经网络误差偏大，当训练样本数大于57时，误差甚至会随着迭代次数的增加而发散，这也是最基础的神经网络中难以避免的问题。20多个训练样本是比较合适的，所以总样本数选取了30。在训练样本和随机样本的检测下都显示出了比较好的效果。最后误差检验的结果显示，拟合图比较均匀地分布在直线两侧，标准差也不算太大。 由于经典梯度下降法有着各种各样的问题，我在调用神经网络工具箱时采用了现在普遍使用的L-M算法，同时也尝试搭建了三层的BP神经网络。在两层神经网络中，预测精度得到了明显的提高，而且随着训练样本的增加，精度也有提高的趋势。然而事情也并非绝对，在精度达到一个阈值时，即使增加样本，精度也不会有明显的提高。而且训练有着一定的偶然性，即使样本数很少，初始条件选择合适的话也会比样本数多的模型精度更高。而三层网络在训练样本数少时预测效果反而没有两层的好，当样本数较多时效果和两层模型相同，这也提醒我，当问题比较简单时，不要贸然增加网络深度，有时候网络过深也不见得是一件好事。 附录（源程序） （1）自编 训练函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697% function main()clc % 清屏clear all; %清除内存以便加快运算速度close all; %关闭当前所有figure图像Num=30; %所有样本总个数TrainSamNum=0.7*Num; %输入样本数量为21ValSamNum=1/6*Num; %验证样本数量为5TestSamNum=2/15*Num; %测试样本数量也是4HiddenUnitNum=10; %中间层隐节点数量取10InDim=2; %网络输入维度为2OutDim=1; %网络输出维度为1%原始数据 [p,t] = GetInput(Num);%生成输出p和输入t%输入数据矩阵p%目标数据矩阵t[SamIn,minp,maxp,SamOut,mint,maxt]=premnmx(p,t); %原始样本对（输入和输出）初始化,进行了数据的归一化[TrainSamIn,ValSamIn,TestSamIn] =divideblock(SamIn,0.7,1/6,2/15);[TrainSamOut,ValSamOut,TestSamOut] =divideblock(SamOut,0.7,1/6,2/15);rand('state',sum(100*clock)) %依据系统时钟种子产生随机数 NoiseVar=0.01; %噪声强度为0.01（添加噪声的目的是为了防止网络过度拟合）Noise=NoiseVar*randn(1,TrainSamNum); %生成噪声TrainSamOut=TrainSamOut + Noise; %将噪声添加到输出样本上MaxEpochs=10000; %最多训练次数为10000lr=0.01; %学习速率为0.01E0=1e-7; %目标误差为1e-7W1=0.5*rand(HiddenUnitNum,InDim)-0.1; %初始化输入层与隐含层之间的权值B1=0.5*rand(HiddenUnitNum,1)-0.1; %初始化输入层与隐含层之间的阈值W2=0.5*rand(OutDim,HiddenUnitNum)-0.1; %初始化输出层与隐含层之间的权值 B2=0.5*rand(OutDim,1)-0.1; %初始化输出层与隐含层之间的阈值W11=W1;W22=W2;B11=B1;B22=B2;ErrHistory=[]; %给中间变量预先占据内存for i=1:MaxEpochs HiddenOut=logsig(W1*TrainSamIn+repmat(B1,1,TrainSamNum)); % 隐含层网络输出 NetworkOut=W2*HiddenOut+repmat(B2,1,TrainSamNum); % 输出层网络输出 Error=TrainSamOut-NetworkOut; % 实际输出与网络输出之差 SSE=sumsqr(Error); %能量函数（误差平方和） ErrHistory=[ErrHistory SSE]; if SSE&lt;E0,break, end %如果达到误差要求则跳出学习循环 % 下面是权值（阈值）依据能量函数负梯度下降原理所作的每一步动态调整量 Delta2=Error; Delta1=W2'*Delta2.*HiddenOut.*(1-HiddenOut); dW2=Delta2*HiddenOut'; dB2=Delta2*ones(TrainSamNum,1); dW1=Delta1*TrainSamIn'; dB1=Delta1*ones(TrainSamNum,1); %对输出层与隐含层之间的权值和阈值进行修正 W2=W2+lr*dW2; B2=B2+lr*dB2; %对输入层与隐含层之间的权值和阈值进行修正 W1=W1+lr*dW1; B1=B1+lr*dB1;endSSE %显示最终误差%拟合图TrainHiddenOut=logsig(W1*TrainSamIn+repmat(B1,1,TrainSamNum)); % 隐含层输出最终结果TrainNetworkOut=W2*TrainHiddenOut+repmat(B2,1,TrainSamNum); % 输出层输出最终结果Trainoutput=postmnmx(TrainNetworkOut,mint,maxt); % 还原网络输出层的结果ValHiddenOut=logsig(W1*ValSamIn+repmat(B1,1,ValSamNum)); % 隐含层输出最终结果ValNetworkOut=W2*ValHiddenOut+repmat(B2,1,ValSamNum); % 输出层输出最终结果Valoutput=postmnmx(ValNetworkOut,mint,maxt); % 还原网络输出层的结果TestHiddenOut=logsig(W1*TestSamIn+repmat(B1,1,TestSamNum)); % 隐含层输出最终结果TestNetworkOut=W2*TestHiddenOut+repmat(B2,1,TestSamNum); % 输出层输出最终结果Testoutput=postmnmx(TestNetworkOut,mint,maxt); % 还原网络输出层的结果[TrainSamOut,ValSamOut,TestSamOut] =divideblock(t,0.7,1/6,2/15); %还原原始输出Tolvalue=[TrainSamOut,ValSamOut,TestSamOut];Toloutput=[Trainoutput Valoutput Testoutput];figureplotregression(TrainSamOut,Trainoutput,'训练',ValSamOut,Valoutput,'验证',... TestSamOut,Testoutput,'测试',Tolvalue,Toloutput,'全体')%绘制网络输出与真实输出的对比图HiddenOut=logsig(W1*SamIn+repmat(B1,1,Num)); % 隐含层输出最终结果NetworkOut=W2*HiddenOut+repmat(B2,1,Num); % 输出层输出最终结果newk=postmnmx(NetworkOut,mint,maxt); x=1:Num; figuresubplot(2,1,1);plot(x,newk,'r-o',x,t,'b--+') %绘对比图；legend('网络输出','实际输出');title('训练样本的预测结果')[p1,t1] = GetInput(Num);%生成检验的输出p1和输入t1[SamIn1,minp,maxp]=premnmx(p1);%归一化HiddenOut=logsig(W1*SamIn1+repmat(B1,1,Num)); % 隐含层输出最终结果NetworkOut=W2*HiddenOut+repmat(B2,1,Num); % 输出层输出最终结果newk1=postmnmx(NetworkOut,mint,maxt);subplot(2,1,2);plot(x,newk1,'r-o',x,t1,'b--+') %绘对比图；legend('网络输出','实际输出');title('随机验证的预测结果') 误差检验： 123456789[p,t] = GetInput(1000);%生成输出p和输入t[SamIn,minp,maxp,tn,mint,maxt]=premnmx(p,t); %原始样本对（输入和输出）初始化,进行了数据的归一化HiddenOut=logsig(W1*SamIn+repmat(B1,1,1000)); % 隐含层输出最终结果NetworkOut=W2*HiddenOut+repmat(B2,1,1000); % 输出层输出最终结果newk=postmnmx(NetworkOut,mint,maxt); figure;plotregression(t,newk,'自编函数')E = t-newk;std(E)% 一次运行结果：3.5937 （2）神经网络工具箱 训练函数： 1234567891011121314151617181920212223242526272829303132333435363738clear all[p,t] = GetInput(30);%生成输出p和输入t[p1,ps]=mapminmax(p);%归一化[t1,ts]=mapminmax(t);%分割为训练数据、验证数据、测试数据[trainsample.p,valsample.p,testsample.p] =divideblock(p,0.7,0.15,0.15);[trainsample.t,valsample.t,testsample.t] =divideblock(t,0.7,0.15,0.15);%关于net函数的参数说明：net = newff(minmax(p),[隐层的神经元的个数，输出层的神经元的个数],...% {隐层神经元的传输函数，输出层的传输函数｝,'反向传播的训练函数'),其中p为输入数据，t为输出数据TF1='tansig';TF2='purelin';net=newff(minmax(p),[10,1],{TF1 TF2},'trainlm');%创建BP神经网络，隐层10个神经元，两层（不包括输入层）%训练算法为Levenberg-Marquardt算法%网络参数的设置net.trainParam.epochs=10000;%训练次数net.trainParam.goal=1e-7;%训练精度net.trainParam.lr=0.01;%学习率net.trainParam.mc=0.9;%动量因子net.trainParam.show=25;%显示间隔次数[net,tr]=train(net,trainsample.p,trainsample.t);%训练网络%计算仿真[normtrainoutput,trainPerf]=sim(net,trainsample.p,[],[],trainsample.t);%训练的数据经BP得到的结果[normvalidateoutput,validatePerf]=sim(net,valsample.p,[],[],valsample.t);%验证的数据经BP得到的结果[normtestoutput,testPerf]=sim(net,testsample.p,[],[],testsample.t);%测试数据经BP得到的结果%反归一化trainoutput=mapminmax('reverse',normtrainoutput,ts);validateoutput=mapminmax('reverse',normvalidateoutput,ts);testoutput=mapminmax('reverse',normtestoutput,ts);%真实数据trainvalue=mapminmax('reverse',trainsample.t,ts);%正常的训练数据validatevalue=mapminmax('reverse',valsample.t,ts);%正常的验证的数据testvalue=mapminmax('reverse',testsample.t,ts);%正常的测试数据%plotregression拟合图tolvalue=[trainvalue validatevalue testvalue];toloutput=[trainoutput validateoutput testoutput];figureplotregression(trainvalue,trainoutput,'训练',validatevalue,validateoutput,'验证',...testvalue,testoutput,'测试',tolvalue,toloutput,'全体') 误差检验： 12345678910111213141516171819202122232425262728293031clearload net.mate=zeros(1000,6);Z=zeros(1000,1);Y1=zeros(1000,1);Y2=zeros(1000,1);Y3=zeros(1000,1);Y4=zeros(1000,1);Y5=zeros(1000,1);Y6=zeros(1000,1);for i=1:1000 a=rand(1)*4*pi-2*pi; b=rand(1)*4*pi-2*pi; y1 = sim(net1,[a;b]);%100样本三层10 5 1 y2 = sim(net2,[a;b]);%100样本两层10 1 y3 = sim(net3,[a;b]);%300样本两层10 1 y4 = sim(net4,[a;b]);%500样本两层10 1 y5 = sim(net5,[a;b]);%1000样本两层10 1 y6 = sim(net5,[a;b]);%1000样本三层10 5 1 z=2*a^2+sin(b+pi/4); Z(i)=z;Y1(i)=y1;Y2(i)=y2;Y3(i)=y3;Y4(i)=y4;Y5(i)=y5;Y6(i)=y6; e(i,:)=[z-y1 z-y2 z-y3 z-y4 z-y5 z-y6];end[std(e(:,1)) std(e(:,2)) std(e(:,3)) std(e(:,4)) std(e(:,5)) std(e(:,6))]figure;plotregression(Z,Y1,'net1');figure;plotregression(Z,Y2,'net2');figure;plotregression(Z,Y3,'net3');figure;plotregression(Z,Y4,'net4');figure;plotregression(Z,Y5,'net5');figure;plotregression(Z,Y6,'net6');%一次运行结果 43.5757 0.6526 0.0305 0.4823 0.2029 0.2029 （3）生成训练样本的子函数 12345678910function [Input,Output] = GetInput(SampleNum)Input=zeros(2,SampleNum);Output=zeros(1,SampleNum);for i=1:SampleNum x=rand(1)*4*pi-2*pi; y=rand(1)*4*pi-2*pi; z=2*x^2+sin(y+pi/4); Input(:,i)=[x,y]; Output(i)=z;end （4）训练得到的网络 1%见net.mat 本文之前发表在CSDN上，链接如下：原文地址","tags":[{"name":"神经网络","slug":"神经网络","permalink":"https://renzehua1998.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"matlab","slug":"matlab","permalink":"https://renzehua1998.github.io/tags/matlab/"}]},{"title":"“我的抗疫故事”记述报告","date":"2020-05-08T13:22:00.000Z","path":"2020/05/08/我的抗疫故事记述报告/","text":"大三下马原征文，其他征文大多是糊弄的，这篇算是真情实感。写于疫情刚开始的时候，作个纪念吧。 疫情无情人有情，携手迎接新明天 2020年初，一场突如其来的新型冠状病毒引发的肺炎疫情席卷而来。套用去年一部电影《流浪地球》中的台词：最初，没人在意这场灾难，这不过是一场山火，一次旱灾，一个物种的灭绝，一座城市的消失，直到这场灾难和每个人息息相关。就像台词中说的那样，不过是新闻中偶尔报出来的几例不明原因感染者，不过是朋友圈中几个身在武汉朋友的报平安消息，直到武汉封城，直到死亡人数超过非典，直到这场疫情成为席卷中国乃至全球的大灾难，这场疫情才真正被所有人关注。 楼下的小学还没开学，冷冷清清的操场上偶见几只鸟儿，而我的学校同样没有开学，线上的教学已经进入第12周。这绝对是人生中第一次超长的假期，从一开始对延期开学的复杂心情，到对学校生活的盼望，再到现在终于得知可以逐步返校的喜悦，这个特殊的时段注定会被我们铭记于心。而在疫情期间，虽然小区封闭、交通管制、人们居家简出，但是通过互联网，我们得以了解到在祖国各地正在发生的、让人热泪盈眶的故事，而我就在这里用自己的笔，记录下这段特殊日子的所见所闻所思所想，以及自己在这段日子的行动。 疫情刚刚爆发的时候，我的一位高中同学勇敢地报名参加了太原市防疫志愿者，负责为高速公路下来的汽车消毒。这应该是距离我最近的参与防疫志愿活动的事迹了。看到他每天在朋友圈分享的动态，我的心也跟随着他关注着抗疫一线的情况。他每天穿着厚厚的防护服工作，从他拍的一张照片中，我看到他的眼镜里面全是凝结的汗水。看到他发的“我妈把我隔离在房间不让我出来”，我为他付出的牺牲而感动；看到他晒出志愿者证书，附言“这是人生中最有意义的礼物”，我为他的奉献而骄傲。他的故事，只是千千万万奋斗在抗疫一线的志愿者的缩影。我认为，正是有了这些愿意为之付出的普通人，我们才拥有了如今取得的防疫的巨大胜利。 本来我的计划是提前返校参加数学建模比赛，但是今年的特殊情况，所有参赛的队伍都只能改到线上讨论。三个队友分散在三个地方，通过网络联系完成任务，这对于我们来说也算是独特的体验。而我们学校也不负众望，同学们克服困难，取得了骄人的成绩，今年我校建模比赛全球排名第一，我们虽然没有获得特等奖，但是也算是赛出了自己的最好水平。在前期训练中，我们也曾建立简单的传染病模型预测本次疫情的发展情况。我编写了简单的仿真程序模拟了散点式的疾病传播模式，还调用了简单的SIR模型复现了网上专家对于本次疫情将基本结束于四月中旬的预言。将自己学到的东西真正应用于实际，我也真切地感受到了知识的魅力。 当全国最为危机的那段时间，给我印象最深的不是网络上那些不断增长的数字，也不是一天天变红的中国地图。我印象最深的是自己小区的防控情况，是楼下始终坚守的社区防疫工作者。在当时，我们市也有了几十名感染者，查出的感染者距我最近的不到5公里。各个小区采取了最严格的防控措施，所有进出小区的人员必须有出入证，像我这种不能开出单位证明的人只能待在家里。在疫情逐步得到控制的时候，有一次我晚上十点回小区，我还是有一点侥幸心理，想着这个时候出入小区应该不会被阻拦。但是在我进门时发现仍然有人在执勤，执勤小哥很耐心地让我扫码填表。一时间我感慨万千，在我们被隔离在家里满是抱怨的时候，他们在岗位上任劳任怨，为小区的人员安全甘愿从寒冬站到酷暑。正是这些一线的防疫工作者的默默付出，我们才能取得防疫阻击战的阶段性伟大胜利。 在疫情期间，我们只能在家使用网络进行学习于工作。在这个特殊的时期，我们仲英书院17级生命自动化党支部克服困难，使用网络进行了多次组织生活会。我印象最深的是交大一附院援鄂医疗队的医生来给我们分享她在一线的亲身经历与所见所闻。比起我们平日在电视与网络中看到的各种报道，与真正参与了一线奋战的医务工作者面对面地交流提问，我能感受到的是更为真实立体的抗疫故事。最让我感动的是，我们书记问她：“您当时害怕吗？”她说：“没什么怕不怕的，最要紧的时候也感受不到怕了，就想着救一个人，再救一个人……”这就是一线战士最真实的感受，没有说教，有的只是一个白衣战士对于生命的敬重。 随着疫情防控的逐步胜利，我们可以就近游玩一些景点，复工复产也在稳步推进。在社区防控逐渐宽松的时候，我也可以走出小区到附近的公园锻炼身体。在路上，我发现有一个地方防控仍然非常严格，距离很远就有警戒线，还有警车在执勤。走近观看才发现，这是国际航班旅客的集中隔离点。在国内形势好转的同时，我们也面临着巨大的对外防控压力，首都北京的防控压力最大，于是选择了几个符合条件的城市分担压力，我们太原市也是其中之一。酒店门口的一个条幅让我很受触动：欢迎回家，祖国和你在一起。这虽然是很普通的一句话，确足以看出我们祖国对于海外同胞的深深牵挂与关怀。之前看到一篇报道，一位留学生发视频表达对祖国的感谢，在结束隔离期后，她如约成为了一名防疫志愿者，用实际行动回报祖国。这就是国家对于每个公民义不容辞的责任和普通人对祖国朴素的热爱 当然，在祖国各地时时刻刻都在发生许许多多感人至深的抗疫故事，有舍小家为大家的志愿者，有累倒在岗位上的防疫工作者，也有用生命挽救生命的医务工作者，当然还有你我一般的千千万万个普通人。我的抗疫故事，不是从网络上，从媒体上看到的报道，而是我真真切切经历的，切切实实感受到的故事。它们可能没有那么波澜壮阔，没有那么感人肺腑，但是从这每一件小事中、从参与小事的每一个普通人的身上都可以看出在这场人类的大灾难面前中国人民坚强乐观的品质，多年以后回忆起来也会是人生中一段独特的经历吧。","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"数字图像处理系列作业","date":"2020-04-28T14:50:00.000Z","path":"2020/04/28/数字图像处理系列作业/","text":"大三下数字图像处理选修课系列作业 太复杂了，改成markdown工作量太大，先贴pdf了…… 第一次作业：报告 第二次作业：报告 第三次作业：报告 第四次作业：报告 第五次作业：报告 第六次作业：报告","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"matlab","slug":"matlab","permalink":"https://renzehua1998.github.io/tags/matlab/"}]},{"title":"数学建模美赛存档","date":"2020-03-09T20:04:00.000Z","path":"2020/03/10/数学建模美赛存档/","text":"大三下数学建模美赛M奖存档。沙雕网友堆沙堡，赶上疫情全程云建模。第一次熬夜，第一次英文写作，第一次提交论文。很难忘的经历~ 论文","tags":[{"name":"matlab","slug":"matlab","permalink":"https://renzehua1998.github.io/tags/matlab/"}]},{"title":"思特奇大数据作业实验报告","date":"2020-02-16T12:14:00.000Z","path":"2020/02/16/思特奇大数据作业实验报告/","text":"大三下思特奇菁英班大数据作业实验报告 思特奇大数据作业实验报告 一、 题目 用HIVE/SPARK 2种SQL方式实现以下2个需求： 1、表拼接 ods_hour 表和 dwd_bd_coordinate 表拼接（拼接条件：两张表的 lng、lat 列相等），生成的数据插入 cdm.dwd_hour 表。 ------------------------------------------------------------------------------- ods_hour + dwd_bd_coordinate =&gt; cdm.dwd_hour （拼接条件：lng、lat 列相等） ​ ------------------------------------------------------------------------------- 2、条件查询 查询cdm.dwd_hour每个省的最新日期对应的字段，结果数据插入dwd_hour_latest 表。 例如：select * from dwd_hour_latest province provincecode daytime 云南省 530000 20190531 &lt;&lt;&lt; 注意这里的值：20190531 海省 630000 20190522 ----------------------------------------------------------------- 云南省的最新时间是 2019-05-31，如果新增数据中，云南省的最新时间是 2019-06-03，那么就需要更新云南省的时间为 20190603 province provincecode daytime 云南省 530000 20190603 &lt;&lt;&lt; 注意这里的值：20190603 海省 630000 20190522 二、 思路 1.表拼接 2.条件查询 三、 操作步骤与输出结果 1. Hive 表拼接 （1） 进入hive （2） 创建名为rzh的数据库（之前已创建没有截图，用show databases显示） （3） 建立四个表 （4） 导入数据 之前总是无法导入数据，在群里与老师交流后学到了要在hdfs中先导入文件 报错图： 成功导入数据 选上10列数据显示 另一个表 选上5列数据显示 （5） 实现表拼接 查看合并后的表 （6） 去除空数据 已无空数据 条件查询 （1） 按省份筛选最新数据 （2） 在日期表中找到最新数据并覆盖 2. Spark 表拼接 （1） 进入spark 发现原来的表格还在，不用重新创建 （2） 拼接操作 条件查询 （1） 按省份筛选最新数据 （2） 在日期表中找到最新数据并覆盖","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}]},{"title":"运筹学大作业","date":"2019-12-24T12:53:00.000Z","path":"2019/12/24/运筹学大作业/","text":"大三上运筹学大作业：飞机座舱分配问题的虚拟嵌套控制模型 在航空收益管理的问题中，座舱分配关系着航空公司的收益与乘客的满意度。我们针对单腿问题的座舱分配问题，采用了虚拟嵌套(virtual nesting)模型，将座位的级别映射到虚拟类中，并采用随机梯度下降法对问题进行求解，得到全局最优解。经过测试与比对，模型能够较好的计算最大收益目标下的座舱分配问题。 和两个同学一起完成，算是第一份科研经历，感谢班主任吴老师的耐心指导和两位队友的共同努力~ 完整报告：报告 原始代码：代码","tags":[{"name":"算法","slug":"算法","permalink":"https://renzehua1998.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"matlab","slug":"matlab","permalink":"https://renzehua1998.github.io/tags/matlab/"},{"name":"优化","slug":"优化","permalink":"https://renzehua1998.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"嵌入式实验报告6","date":"2019-12-22T11:48:00.000Z","path":"2019/12/22/嵌入式实验报告6/","text":"大三上嵌入式实验报告6 (一)实验目的与实验设备 实验目的： 1)掌握LCD 液晶模块的基本原理和功能。 2)掌握LCD 液晶模块和微控制器的硬件接口及程序设计方法。 3)熟悉ARM的C语言和汇编语言的编程与调试方法。 实验设备： 1)硬件：W90P710实验系统、PC机、J-LINK仿真器 2)软件：PC机操作系统、Keil MDK-ARM 4.22 (二)实验要求 编写LCD 程序： a.在LCD上显示一张图片； b. 在LCD上显示多张图片，加入键盘按键功能，制成电子相册，用键盘按键翻页循环显示； c.在LCD上显示一张动态图片（GIF图）。 (三)实验原理 W90P710 评估板的LCD 控制器的主要目的是将VIDEO/OSD 的原始图像数据显示到外部液晶屏上。LCD控制器可以支持AUO的TFT屏，LG 的 TFT 屏，CASIO 的TFT 屏，实验中使用的是AUO 3.0\" TFT A030DL01（960x240，8位数据总线）数字式TFT液晶屏。此外，LCD控制器还能够连接到STN LCD 和电视编码器上，并且支持VIDEO和OSD 两种显示模式。这两种显示模式的设定由不同的寄存器控制，通过设定相应寄存器的值可以实现不同的模式和功能。 AUO 3.0\" TFT A030DL01 液晶屏由单个像素点排列组成，向这些像素点配置不同的值，可以显示不同的颜色。但是，由于AUO TFT液晶屏内部没有缓存，需要在SDRAM中开辟一片缓冲区存储一维数组形式的原始图像数据。然后，将存储原始图像数据的SDRAM 缓冲区的首地址赋值给LCD控制器中的FIFO1SDADR寄存器。接着，原始图像数据在时钟脉冲的作用下依次输入到LCD控制器的FIFO1中，直至FIFO1被填满才将FIFO1中的数据输出到LCD颜色发生器。最后，LCD颜色发生器将图像显示到评估板上的液晶屏中。如果在液晶屏上定位显示图片或其他信息，需要计算出所要显示的内容在液晶屏上的位置。然后，在新建的SDRAM缓冲区中存入需要显示的内容即可。LCD硬件连接图如图33所示。 LCD模块由 40 个引脚与外界电路相连，由于本身没有寄存器，需要由 W90P710中的LCD 控制器提供相应的寄存器，控制选择对应的液晶类型及显示形式、FIFO 使用、颜色显示模式和时序设置。 LCDCON寄存器比较重要，需要根据实际所使用的硬件，对控制寄存器进行配置。本次实验使用16 bpp 模式、真彩型TFT LCD、没有使用查找表功能，分别使能相应的位实现LCDCON寄存器初始化操作。 (四)实验步骤 实验步骤与“LED灯闪烁实验”类似，但有两个不同点：在步骤3中不需要新建源文件，直接将文件夹“lcd显示所需文件”中提供的实验文件拷贝到工程新建文件夹中；并将所有文件添加到工程目录中，完成任务a。 然后修改lcd.c主程序，加入键盘按键功能，增加图片，制成电子相册，用键盘按键翻页循环显示完成任务b。步骤如下：  准备好几幅图片，320240像素，用Image2Lcd工具转换为16位真彩色的.c格式文件，并添加到工程中；  根据上次实验在主程序中添加按键功能；  根据不同键值切换显示图片。 最后完成任务c，连续显示一组动态图片。 (五)程序分析 1.在LCD上显示一张图片 根据例程的提示，这是一个非常简单的顺序结构，其关键代码仅为 GLCD_bitmap (0, 0, 320, 240, Background1); 在引入的Picture.c文件中，将Background1数组改为自己需要替换的图片转换而来的数组即可。 程序流程图如下： 2.在LCD上显示多张图片，加入键盘按键功能，制成电子相册，用键盘按键翻页循环显示； 通过研究键盘扫描阵列实验的例程发现，可以使用KPI中断来实现功能。在上面的实验中，键盘键值的判断采用的是中断模式，需要程序打开键盘控制器中断，并设定优先级。在中断服务程序中，读取按键键值并点亮对应的LED灯。而在本实验中，将点亮LED灯的代码改为要求的功能即可。通过引入一个标志变量keynum来实现电子相册内照片的选择。按下“0”号按键时，进入中断服务子程序，keynum加一，并且通过switch语句选择显示对应的照片，当keynum即将超过照片总数时，将其置-1，下一次按键“0”时值即为0，显示第0张照片。 程序流程图如下： 3.在LCD上显示一张动态图片（GIF图）。 由于此任务为播放GIF图片，不需要键盘进行选择，所以不需要在中断中实现，在主函数当中用一个定时和循环即可实现。利用软件将GIF图片分帧，再把每一帧图片比例都调整为320x240，用img2lcd软件转为16位真彩显示数组，将其导入工程即可。 由于人眼的视觉暂留效果，将每一帧的间隔时间定为200ms，并且同任务2一样，引入标志变量，每显示一帧图片，标志加一，在即将超过帧数时置为0。这样即可实现GIF图片的循环播放。实验中尝试了两幅GIF图片，都取得了不错的效果。 程序流程图如下： (六)程序代码 1.在LCD 上显示一张图片 12345678910#include &lt;W90P710.H&gt; /* Winbond W90P710 definitions */#include \"GLCD.h\"#define LED_ALL 0xffextern unsigned char Background1[];int main (void) { /* Main Function */ Reg8(0x78000000) = LED_ALL; /* Turn off all LEDs */ GLCD_bitmap (0, 0, 320, 240, Background1); GLCD_init(); } 2.在LCD上显示多张图片，加入键盘按键功能，制成电子相册，用键盘按键翻页循环显示； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192extern unsigned char Background0[];extern unsigned char Background1[];extern unsigned char Background2[];extern unsigned char Background3[]; extern unsigned char Background4[];extern unsigned char Background5[];#define u32 unsigned int #define REG_GPIO_CFG2 0xFFF83020#define REG_AIC_SCR29 0xFFF82074#define REG_AIC_MECR 0xFFF82120#define REG_KPICONF 0xFFF88000#define REG_KPISTATUS 0xFFF8800C#define EBILED_ADDRESS 0x78000000#define REG_EXT0CON 0xFFF01018#define EBI_EXT0_VALUE 0xF0078003#define WriteReg(Address,Value) *(unsigned int volatile *)(Address) = Value#define ReadReg(Address) *(unsigned int volatile *)(Address)int keynum=-1;void KPIInit(void);int main (void){ WriteReg(REG_EXT0CON, EBI_EXT0_VALUE); KPIInit(); while(1); return 0;}void KPIInit(void){ WriteReg(REG_GPIO_CFG2, 0x000aaaaa); //将GPIO设置为KPI模式 WriteReg(REG_AIC_SCR29, 0x00000045); //将KPI 中断设置为高电平有效，优先级为5 WriteReg(REG_AIC_MECR, 0x20000000); WriteReg(REG_KPICONF, 0x00142fff);}//KPI中断服务子程序__irq void IRQ_Handler(void){ //extern int keynum; //int keynum=0; u32 KeyValue, temp; temp = ReadReg(REG_KPISTATUS); temp &amp;= 0x0000000f; if(temp &gt; 0xB){ KeyValue = temp - 0xC; } else if(temp &lt; 0x4){ KeyValue = temp + 0xC; } else{ KeyValue = temp; } if(KeyValue==0) keynum++; switch (keynum) { case 0: { GLCD_bitmap (0, 0, 320, 240, Background0); GLCD_init(); break; } case 1: { GLCD_bitmap (0, 0, 320, 240, Background1); GLCD_init(); break; } case 2: { GLCD_bitmap (0, 0, 320, 240, Background2); GLCD_init(); break; } case 3: { GLCD_bitmap (0, 0, 320, 240, Background3); GLCD_init(); break; } case 4: { GLCD_bitmap (0, 0, 320, 240, Background4); GLCD_init(); break; } case 5: { GLCD_bitmap (0, 0, 320, 240, Background5); GLCD_init(); break; } } if(keynum==6) keynum=-1;} 3.在LCD上显示一张动态图片（GIF图）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118int main (void) { /* Main Function */ int num = -1; int dir = 1; int off = 0; int pic = 0; int clk_ani = 0; Reg8(0x78000000) = LED_ALL; /* Turn off all LEDs */ /* Setup Timer1 to generate interrupt every 10 ms */ REG_TCR1 = 0xAC000000 + (15-1); /* Dbg, IE, period mode, rst, prsc=80 */ REG_TCR1 = 0xA8000000 + (15-1); /* Dbg, IE, period mode, prsc=80 */ REG_TICR1 = (15000000 / (15 * 100)); /* Reload value=15MHz/(prescaler*100) */ REG_TCR1 |= (1 &lt;&lt; 30); /* Start Timer 1 */ /* Setup AIC for Timer1 interrupt */ REG_AIC_SCR14 = (1 &lt;&lt; 6) | 1; /* Int trig on high level, priority 1 */ REG_AIC_TEST = 1; /* Enable Debugging of AIC */ REG_AIC_MECR = (1 &lt;&lt; IRQ_TIMER1); /* Enable Timer 1 interrupt */ GLCD_init(); GLCD_bitmap (0, 0, 320, 240, gImage_ren001); for (;;) { /* Loop forever */ if (Clock100ms) { Clock100ms = 0; if (clk_ani++ == 1) { /* Draw animation picture every 200 ms*/ clk_ani = 0; switch(pic) { case 0: GLCD_bitmap (0, 0, 320, 240, gImage_ren001); break; case 1: GLCD_bitmap (0, 0, 320, 240, gImage_ren002); break; case 2: GLCD_bitmap (0, 0, 320, 240, gImage_ren003); break; case 3: GLCD_bitmap (0, 0, 320, 240, gImage_ren004); break; case 4: GLCD_bitmap (0, 0, 320, 240, gImage_ren005); break; case 5: GLCD_bitmap (0, 0, 320, 240, gImage_ren006); break; case 6: GLCD_bitmap (0, 0, 320, 240, gImage_ren007); break; case 7: GLCD_bitmap (0, 0, 320, 240, gImage_ren008); break; case 8: GLCD_bitmap (0, 0, 320, 240, gImage_ren009); break; case 9: GLCD_bitmap (0, 0, 320, 240, gImage_ren010); break; case 10: GLCD_bitmap (0, 0, 320, 240, gImage_ren011); break; case 11: GLCD_bitmap (0, 0, 320, 240, gImage_ren012); break; case 12: GLCD_bitmap (0, 0, 320, 240, gImage_ren013); break; case 13: GLCD_bitmap (0, 0, 320, 240, gImage_ren014); break; case 14: GLCD_bitmap (0, 0, 320, 240, gImage_ren015); break; case 15: GLCD_bitmap (0, 0, 320, 240, gImage_ren016); break; case 16: GLCD_bitmap (0, 0, 320, 240, gImage_ren017); break; case 17: GLCD_bitmap (0, 0, 320, 240, gImage_ren018); break; } if (pic++ &gt; 17) pic = 0; } } if (Clock1s) { /* Blink LED every 1 second */ Clock1s = 0; if (!off) { /* Calculate 'num': 0, 1, ... , LED_NUM-1, LED_NUM-1, ... , 1, 0, 0, .*/ num += dir; if (num == LED_NUM) { dir = -1; num = LED_NUM-1; } else if (num &lt; 0) { dir = 1; num = 0; } Reg8(0x78000000) = ~led_mask[num]; /* Turn on LED with index 'num' */ } else { Reg8(0x78000000) = LED_ALL; /* Turn off all LEDs */ } off = !off; } }} (七)实验效果（详见视频） 1.在LCD上显示一张图片 2.在LCD上显示多张图片，加入键盘按键功能，制成电子相册，用键盘按键翻页循环显示； 3.在LCD上显示一张动态图片（GIF图）。 (八)实验总结 这是嵌入式系统的最后一次实验，我们也第一次接触到了课堂上讲的ARM开发板。我被ARM丰富的功能所吸引，相较前几次的实验板，它的显示屏更加清晰而且支持16位真彩显示。进行了初步的调试、简单功能测试的验证性实验后，我们开始进行自主设计的实验。实验任务一比较简单，通过把例程当中的图片修改为自己想要的图片即可完成。而实验任务二则比较复杂，在前面keyboard键盘扫描实验中得到启示，要想实现按键切换，需要引入中断。而刚开始我对于实验要求有所误解，以为是按下不同的键显示不同的照片，而老师的要求是按下同一个键实现照片的切换。因为按键只有十六个，照片多的话就不能实现功能了，而且还有其他功能可能会需要键盘。而在修改了程序以后发现第一张照片不显示，经过调试发现，原来是因为置位是给标志变量置了0，而下一次运行时直接加一就跳过了第一张图片，将置位改为-1即可解决这一问题。在GIF显示任务中，刚开始使用中断来实现播放GIF，但是每一帧之间会有一个黑屏，而把它放到主函数当中就不会出现这种情况。经过向老师请教，需要在子函数中关掉一个指令，这样才能避免每次刷新屏幕时的黑屏。由于人眼的视觉暂留效应，将每帧的间隔定位200ms时就能显得比较流畅，之前刷新的时间太长，就会导致GIF图片播放卡顿。而且原始GIF图的质量也会影响流畅度，若是原始图片本身帧数就低，那么播放出来的效果就也不好，所以要从这两个方面来优化图片显示效果。 这学期的嵌入式实验最大的收获就是能够把自己编写的代码在真正的硬件上跑起来，实现一个个简单的功能。这也是我们专业最重要的能力之一。我学会了嵌入式系统的简单运行和调试方法，也进一步锻炼了自己的代码能力。在半个学期的实验中虽然也会碰到各种各样的困难，但是在大家的讨论与思考当中都得到了解决。虽然实验结束了，但是我的学习之旅不会结束，在后面，我也会自己进行单片机与嵌入式系统的练习，并且利用寒假的时间学习一下51单片机的内容，预习一下下学期要进行的树莓派实验的内容，做好承前启后的工作。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"嵌入式实验报告4 5","date":"2019-12-17T08:44:00.000Z","path":"2019/12/17/嵌入式实验报告4-5/","text":"大三上嵌入式实验报告4 5 (一)实验目的 较全面掌握RL78/G13系列嵌入式微控制器的程序设计技术。 利用基础模块设计实验的积累，完成较为复杂的综合实验任务。 (二)实验要求 第四次： 在前三周工程的基础上，学习并调通例程文件夹里RL78_FunctionDemoCodenew例程，在第3次工程基础上，添加完成在LCD循环显示不同的界面：1、个人信息（或自己设计的显示内容，键盘可以输入，修改后的内容参与新一轮的循环显示），2、代表交大的图片，3、谢谢+“笑脸”图片；实验后写好实验报告下次实验提交（电子版），实验报告包括实验步骤（必要时截图），附上所添程序段并标明位置，运行结果拍图或视频、工程文件。 第五次： 新建工程，要求设计一个菜单并在液晶上显示（例如：秒表、个人信息、图片循环显示），通过按键选择并启动菜单项，实现第2-4次实验所有功能。实验后写好实验报告下次实验提交（电子版），实验报告包括实验步骤（必要时截图），附上所添程序段并标明位置，运行结果拍图或视频、工程文件。 (三)程序分析 1.实现输入信息、循环播放 使用了一个标志变量mydisplay，初始化置其值为0。在主循环刚开始再加入一个循环，做输入循环，循环条件为mydisplay=0在这个循环内可以实现前面几次实验所提到的功能。包括显示姓名班级学号、定时计数、还有输入日期（包括日期的删除修改等等）。在确认输入完毕以后按下16键，置mydisplay为1，跳出输入循环。此时程序进入主循环，由于标志变量mydisplay=1，在每次执行到输入循环位置时，都不进如循环，实现笑脸、交大图片、个人信息的循环播放。其中，个人信息（包括输入的日期）用数组实现，对日期的输入即为对数组的修改，在循环播放时调用的是同一个数组，因此实现了输入信息加入循环的要求。 程序流程图如下： 2.实现菜单选择 前面的实验虽然实现了功能，但是其本身还有一些小问题，比如说日期只能输入一次，加入循环以后就不能修改内容。因此我定义了一个菜单界面，在菜单界面可以选择修改信息，定时计数，循环播放。在修改、计数界面可以进行前面几次实验的定时、修改信息等等功能；在循环播放界面可以实现第四次实验的循环播放图片功能，而且个人信息保留为最后一次修改的内容。 在菜单界面按1进入修改、计数界面，按2进入循环播放界面。在另外两个子界面按16即可退出。 为了保证程序的可读性，我把两个子界面的功能封装为两个子函数void setdate() 和void Loop_display()，在主函数中直接调用即可实现功能。 程序流程图如下： (四)程序代码 1.实现输入信息、循环播放 1)输入日期循环 12345678910111213141516171819202122232425while (mydisplay==0) { lcd_display(0,\" 任泽华 \" \" 自动化71班 \" \" 2171411498 \"); lcd_display(48,date); Keyboard_scan(); if(num_keyboard==14){sflag=1;} if(sflag==1)num_10 = num/10; else {num=0;num_10=0;} if(bflag==0 &amp;&amp; num_10==10){ R_PCLBUZ0_Start(); bflag=1; delaya();R_PCLBUZ0_Stop();} if(num_keyboard==13){bflag=0; num=0;num_keyboard=0;sflag=0;} if(num_keyboard!=0) display(); if(num_keyboard==13){bflag=0; num=0;num_keyboard=0;sflag=0;} leddispaly();//delayb(1000);//delayb(1000);NOP();WDTE = 0xAC;if(num_keyboard==16) {num_keyboard=0; mydisplay=1;break;} } 2)循环显示（主循环） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 while (1U) { while (mydisplay==0) { //此处为（1）中的输入信息部分 } lcd_write(0x01,0); LcdFill_REC(); delayb(1000); delayb(1000); WDTE = 0xAC; lcd_displayth(0,string); delayb(1000); delayb(1000); WDTE = 0xAC; LcdClear(); //Clear Graph; lcd_write(0x01,0); delayb(1000); delayb(1000); WDTE = 0xAC; LcdFill_REC2(); delayb(1000); delayb(1000); WDTE = 0xAC; LcdClear(); //Clear Graph; lcd_write(0x01,0); delayb(1000); delayb(1000); LcdFill_REC3(); delayb(1000); delayb(1000); WDTE = 0xAC; LcdClear(); //Clear Graph; lcd_write(0x01,0); delayb(1000); delayb(1000); lcd_display(0,\" 任泽华 \" \" 自动化71班 \" \" 2171411498 \"); lcd_display(48,date); delayb(1000); delayb(1000); lcd_write(0x01,0); delayb(1000); delayb(1000);} 3)半屏显示笑脸的子函数 12345678910111213141516171819202122232425262728293031void lcd_displayth(unsigned char pos, void *str){ unsigned char *p, *p1; unsigned char i,lenth; if(pos &gt; 63) return; p = p1 = (unsigned char *)str; lenth = 0; while(*p1) { lenth++; p1++; if(lenth &gt;= 64 - pos) break; } if((pos%16)!=0) CursorSet(pos); for(i = pos; i - pos &lt; lenth; i++) { if(i == 0) lcd_write(0x80+4, 0); else if(i == 8) lcd_write(0x90+4, 0); else if(i == 16) lcd_write(0x88+4, 0); else if(i == 24) lcd_write(0x98+4, 0); lcd_write(*p++, 1); delay(200); }} 2.实现菜单选择 1)主循环 123456789101112131415 while (1U) { lcd_display(0,\" 菜 单 \"\"1.键盘输入 定时\"\"2.循环显示图片 \"\"3.按16退出 \");//\"\"); Keyboard_scan(); switch(num_keyboard){ case(1):mydisplay=0;setdate();break; case(2):Loop_display();break;} } 2)输入日期的子函数 12345678910111213141516171819202122232425262728void setdate(){ while (mydisplay==0) { num_keyboard=0; lcd_display(0,\" 任泽华 \" \" 自动化71班 \" \" 2171411498 \"); lcd_display(48,date); Keyboard_scan(); if(num_keyboard==14){sflag=1;} if(sflag==1)num_10 = num/10; else {num=0;num_10=0;} if(bflag==0 &amp;&amp; num_10==10){ R_PCLBUZ0_Start(); bflag=1; delaya();R_PCLBUZ0_Stop();} if(num_keyboard==13){bflag=0; num=0;num_keyboard=0;sflag=0;} if(num_keyboard!=0) display(); if(num_keyboard==13){bflag=0; num=0;num_keyboard=0;sflag=0;} leddispaly(); //delayb(1000); //delayb(1000); NOP(); WDTE = 0xAC; if(num_keyboard==16) {num_keyboard=0; mydisplay=1;lcd_write(0x01,0);break;} }} 3)循环显示子函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void Loop_display(){ while(1) { Keyboard_scan();if(num_keyboard==16){num_keyboard=0; LcdClear();break;} lcd_write(0x01,0); LcdFill_REC(); delayb(1000); delayb(1000); WDTE = 0xAC; Keyboard_scan();if(num_keyboard==16){num_keyboard=0;LcdClear(); break;} lcd_displayth(0,string); delayb(1000); delayb(1000); WDTE = 0xAC; Keyboard_scan();if(num_keyboard==16){num_keyboard=0;LcdClear(); break;} LcdClear(); //Clear Graph; lcd_write(0x01,0); delayb(1000); delayb(1000); WDTE = 0xAC; Keyboard_scan();if(num_keyboard==16){num_keyboard=0;LcdClear(); break;} LcdFill_REC2(); delayb(1000); delayb(1000); WDTE = 0xAC; Keyboard_scan();if(num_keyboard==16){num_keyboard=0; LcdClear();break;} LcdClear(); //Clear Graph; lcd_write(0x01,0); delayb(1000); delayb(1000); LcdFill_REC3(); delayb(1000); delayb(1000); WDTE = 0xAC; Keyboard_scan();if(num_keyboard==16){num_keyboard=0;LcdClear(); break;} LcdClear(); //Clear Graph; lcd_write(0x01,0); delayb(1000); delayb(1000); lcd_display(0,\" 任泽华 \" \" 自动化71班 \" \" 2171411498 \"); lcd_display(48,date); delayb(1000); delayb(1000); lcd_write(0x01,0); delayb(1000); delayb(1000); Keyboard_scan();if(num_keyboard==16){num_keyboard=0;LcdClear(); break;} }} (五)实验效果（详见视频） (六)实验总结 在刚开始我第四次实验的功能是轮流播放笑脸、交大图片以后停在输入日期界面不动，等输入完成以后继续轮流播放，到此处以后仍然不动。老师说这并不是实验要实现的功能。经过思考与讨论，我决定采用双重循环的方式，通过标志变量的修改实现输入与循环的切换。第五次实验当中有一个小问题，就是在循环显示图片的时候不能同步实现对键盘的扫描，无法按键退出。我想到的办法是每幅图片播放完成以后扫一次键盘，这样就能实现按键的响应。 本次实验是瑞萨开发板的最后一次实验，这几周对于瑞萨开发板的学习让我收获良多。瑞萨也是我接触到的第一个嵌入式系统开发板，刚刚接触一个全新的软件，确实有些困难，按着老师的教程和视频一步步建立自己的第一个工程。其实这都是涉足一个新领域所必然经历的，经过几次实验，我对于这个软件的一些功能已经有了一些了解，也可以在读懂例程的基础上进行一些修改，加入自己的功能。我明白了在实际的工程当中，有时在一开始就完完全全搞懂一个东西是不现实的，应该先做起来，动手去运行一些例程代码，修改一些参数观察输出情况。然后在他人工作的基础上增加一些自己的东西。这对于新手来说是一个很快掌握一项技能的好方法。在老师的耐心指导和与同学们的探讨中，我逐渐学会了如何写代码，如何打断点调试，出了问题要怎么排查。这个过程虽然痛苦，但是真正把问题想明白了以后的心情是非常开心的。看着自己一行行敲出来的代码可以实现一个小小的功能，心里也会有小小的成就感。 就像老师说的，我们这些实验虽然是验证型的，也就是重复做别人做过的东西，但是我们正是在不断地实验中发现自己的短板，磨练自己的代码能力与思维能力。从这个方面来说，我认为这次的实验对我来说是很有意义的。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"数字信号处理实验和作业","date":"2019-12-13T04:00:00.000Z","path":"2019/12/13/数字信号处理实验和作业/","text":"大三上数字信号处理实验报告+大作业（综述论文） 第一次实验 基于时域分析技术的语音识别问题 语音是一种典型的、易于获取的一维时序信号。语音信号处理及识别技术是数字信号处理课程的重要应用板块。时间序列分析、快速傅里叶变换、滤波器设计等多项数字信号处理的教学内容在语音识别核心技术中均占有重要地位。 本次实验面向孤立字语音识别基本任务，由时域角度进行探讨、分析、解决。 本文将通过能识别数字 0～9 的语音识别系统的实现过程详细阐述基于 KNN、随机森林等算法的特定孤立词识别的相关原理和关键技术。 在信号采集部分，首先通过编程方式运用 audiorecorder 函数进行了语音信号的采集并建立了班级语音信号库。在预处理部分，我们对语音信号进行了批量处理：运用汉明窗函数进行分帧加窗处理，短时时域特性分析、 基于双门限法的端点检测。基于时域分析提取的特征向量，本文选择了 KNN、随机森林等分类器进行了孤立字语音识别。最后进行了实验对比及量化分析。 运用 KNN，最后的识别准确度为 55%左右；运用随机森林，最后的识别准确度为 20%左右；运用隐马尔可夫模型，最后的识别准确度为 20%左右。综上，KNN 算法有更好的识别效果。 实验报告1原文：实验1 第二、三次实验 基于 MFCC 和 DTW 的频域语音识别问题 本次实验面向孤立字语音识别基本任务，由频域角度进行探讨、分析、解决。 本文将通过能识别数字 0～9 的语音识别系统的实现过程详细阐述基于 MFCC、DTW 的特定孤立词识别的相关原理和关键技术. 在信号采集部分，首先通过编程方式运用 audiorecorder 函数进行了语音信号的采集并建立了班级语音信号库。在预处理部分，我们对语音信号进行了批量处理：进行预加重滤波处理;运用汉明窗函数进行分帧加窗处理，短时时域特性分析并对该特定时段的语音信号进行离散时间傅里叶（DTF）变换，得到相应的频谱结果; 求取Mel 倒谱系数和 MFCC 系数，运用模板匹配法、动态时间规整（DTW）进行分类识别。 通过实验对比、量化分析及改进，本系统的语音识别平均准确率大致为 48%。 实验报告2 3原文：实验2 3 综述大作业 心电信号的处理与分类方法综述 在现代心脏疾病的诊断中，往往会使用心电图进行辅助诊疗手段。国内外对于心电信号的处理与分类方法进行了许多研究。概述了心电信号的一般特征和处理与识别的一般过程，回顾了心电信号预处理与特征提取的主要方法及其主要的发展。重点讨论了三种心电信号的分类算法：统计模式识别分类法、神经网络分类法、结构模式识别分类法。并且介绍了几种方法的发展状态和未来的研究方向。 大作业原文：综述","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"算法","slug":"算法","permalink":"https://renzehua1998.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"matlab","slug":"matlab","permalink":"https://renzehua1998.github.io/tags/matlab/"}]},{"title":"自动控制上实验报告","date":"2019-12-06T05:29:00.000Z","path":"2019/12/06/自动控制上实验报告/","text":"大三上自控上实验报告 基于NI ELVIS平台和LabVIEW软件的直流电机控制系统设计 一、实验目的 了解直流电机转速测量与控制的基本原理。 掌握LabVIEW图形化编程方法，编写直流电机转速控制系统程序。 熟悉PID参数对系统性能的影响，通过PID参数调整掌握PID控制原理。 二、实验设备与器件 ​ 计算机、NI ELVIS II多功能虚拟仪器综合实验平台、LabVIEW软件、万用表、12V直流电机、光电管，电阻、导线。 三、实验原理 ​ 直流电机转速测量与控制系统的基本原理是：通过调节直流电机的输入电压大小调节电机转速；利用光电管将电机转速转换为一定周期的光电脉冲、采样脉冲信号，获取脉冲周期。将脉冲的周期变换为脉冲频率，再将脉冲频率换算为电机转速；比较电机的测量转速与设定转速，将转速偏差信号送入PID控制器，由PID控制器输出控制电压，通可变电源输出作为直流电机的输入电压，实现电机转速的控制。原理框图、检测与控制硬件电路图如图1和图2所示： 图1 电机转速测量与控制原理框图 图2 电机转速测量与控制硬件电路图 ​ 直流电机转速控制设计中特别需要考虑的问题： 电机启动的“死区”问题。电机刚上电时速度为0，光电检测脉冲周期测量为0，那么脉冲频率测量为无限大，该怎么办? 一个办法：设定转速的“虚拟下限”。 可变电源输出初始电压一定要调为0，避免烧坏直流电机。还要避免电源短接。 需要设置合适参数值：PID参数、转速下限、设定转速上限、可变电源的电压输出范围、数据采集的采样率等，而所有这些参数都需要根据所用的直流电机来考虑，低速电机与高速电机是完全不同的。 采样率（Sample Rate）的设置与待读取样本（Samples to Read）设置。连续采集中,要使ELVIS数据采集平台的FIFO缓存与计算机内存这两处缓存一直不溢出, 必须保证USB总线的数据转移速率大于数据采集速率，同时程序必须尽快读取计算机内存中的数据。采样率设置一般建议为乃奎斯特频率的10倍或更高；待读取样本（Samples to Read）设置为 采样率数值的1/10到1/5。 PID控制算法可利用LabVIEW PID工具包中现成PID函数，也可以自行设计。PID参数调整采用试凑法。 四、实验过程 在实验板上搭建出电机转速光电检测电路 ​ 将光电管、直流电机安装在实验板上的合适位置，使得直流电机的圆片恰好在光电管之中，用导线将光电管与相应阻值的电阻相连，并将电路与相应的接口相连。 应用Lab VIEW软件设计实现对直流电机转速的检测与PID控制 ​ SP为期望转速输出，是用户通过转盘输入期望的转速；PV为实际测量得到的电机转速，通过光电开关测量马达转速可以得到；MV为PID输出控制电压，将其接到“模拟DBL”模块，实现控制电源产生所需的直流电机控制电压。通过不断地检测马达转速与期望值对比产生偏差，通过PID控制器产生控制信号，实现对直流电机转速的控制。 任务一： 使用NI ELVIS可变电源提供的电源能力，驱动直流电机旋转，并通过改变电压改变其运行速度。 程序框图： 界面： 通过改变电压值，观测到电动机转速发生变化。 任务二： 通过光电开关测量直流电机的转速。 调用例程，测量结果如下： 将输入输出整合，程序框图如下： 输出界面如下： 可以实现输入电压、转速测量的同时控制。 任务三： 通过编程将 可变电源所控制的电机和转速测量整合在一起，基于计算机实现一个转速自动控制系统。 ​ LabVIEW编写的程序如下图所示： （1） 当 、 、时 转速上升： 转速下降： （2）Kc不合适 当 、 、 时 Kc大了有超量 当 、 、时 Kc小了调节时间变长 （3）Td,min不合适 当 Td,min有震荡 当时 Td,min小了调节效果不好 （4）Ti,min不合适 当时 Ti,min小了有超调 当、Ti,min = 0.1000、时 Ti,min大了调节时间变得很慢 五、结果分析 ​ 经过多次调试可以发现，当时，系统调节时间短且不会出现超调，效果最佳。调试结果见上图（1）。 六、思考题 ​ 如果已知马达最高转速为800r/min，采样率设置为1kS/s够吗？ 假如采样率为1kS/s，待读取样本为100，每次采集到的波形时间为多长？ 假如采样率为1kS/s，为了每次一屏显示为1s的波形，待读取采样应该设置为多长？ 答： ​ 周期，故采样率足够； ​ 波形时间； ​ 待读取采样应该设置为。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"控制","slug":"控制","permalink":"https://renzehua1998.github.io/tags/%E6%8E%A7%E5%88%B6/"},{"name":"LabVIEW","slug":"LabVIEW","permalink":"https://renzehua1998.github.io/tags/LabVIEW/"}]},{"title":"嵌入式实验报告3","date":"2019-11-28T13:21:00.000Z","path":"2019/11/28/嵌入式实验报告3/","text":"大三上嵌入式实验报告3 (一)实验目的 通过对各接口模块参考示例程序的学习，了解其工作原理，并能根据实验要求修改或扩充示例程序及功能，掌握处理器各接口模块的使用和编程方法。 (二)实验要求 在前两周工程的基础上，学习并调通例程文件夹里Sample_Buzzle_100LG和Sample_Timer&amp; LED_100LG例程，然后在第2次实验内容基础上添加秒表功能，在数码管上设计显示秒表，通过键盘实现“启动”、从1开始记到10（数码管LED上依次显示1~10），计时到10时启动蜂鸣器，停止计时，数码管LED上显示10；实验后写好实验报告下次实验提交（电子版），实验报告包括实验步骤（必要时截图），附上所添程序段并标明位置，运行结果拍图或视频、工程文件。 (三)程序分析 1.定时中断 A.定时子程序 12345678910R_TAU0_Create(); //创建定时器R_TAU0_Channel0_Start(); //Channel 0通道开始计时R_TAU0_Channel0_Stop(); //Channel 0通道结束计时在R_TAU0_Create();中，通过修改参数改变分频的倍数，实现不同间隔的定时。void R_TAU0_Create(void){ TAU0EN = 1U; /* supplies input clock */TPS0 = _0005_TAU_CKM0_FCLK_5 | _0000_TAU_CKM1_FCLK_0 | _0000_TAU_CKM2_FCLK_1 | _0000_TAU_CKM3_FCLK_8;_0005_TAU_CKM0_FCLK_5中，5时实现1秒定时，6时实现2秒定时。 B.在timer_user中写入中断程序： 12345678__interrupt static void r_tau0_channel0_interrupt(void){ /* Start user code. Do not edit comment generated here */ num = num+1; if(num&gt;100) num=100; WDTE = 0xAC; /* End user code. Do not edit comment generated here */} C. 在主循环中，当按下14号键时，开始计时 12345 if(num_keyboard==14){sflag=1;} if(sflag==1)num_10 = num/10; else {num=0;num_10=0;} if(bflag==0 &amp;&amp; num_10==10){ R_PCLBUZ0_Start(); bflag=1; delaya();R_PCLBUZ0_Stop();} D. 按下13号键时，重新归零 1if(num_keyboard==13){bflag=0; num=0;num_keyboard=0;sflag=0;} 2.蜂鸣器 A.蜂鸣器子程序 1234R_PCLBUZ0_Start(); //开始鸣响for(i=0;i&lt;2000;i++) //延时for(j=0;j&lt;1000;j++);R_PCLBUZ0_Stop(); //结束鸣响 B.主循环中，按下14号键，计时结束后进行蜂鸣器鸣响，delaya（）为一个自定义延时函数，让蜂鸣器鸣响一段时间以指示计时结束。 12345if(num_keyboard==14){sflag=1;}if(sflag==1)num_10 = num/10;else {num=0;num_10=0;}if(bflag==0 &amp;&amp; num_10==10) { R_PCLBUZ0_Start(); bflag=1; delaya();R_PCLBUZ0_Stop();} C.delaya()子函数 123456void delaya(void){ int i,j; for(i=0;i&lt;800;i++) for(j=0;j&lt;800;j++);} 3.数码管显示 如实验一中的数码管显示，定义leddispaly()函数： 1234567891011121314151617181920212223242526void leddispaly(void){ array_key[0]=num_10%10; //the second char array_key[1]=num_10/10; //the front char if(count&lt;2) { if(count==0)bit_control=1; //from bit4 to bit1 if(count==1)bit_control=0; //testvalue1 = Getcode(array_key[count]); //DIGTAL_PORT = testvalue1; DIGTAL_LED_D4 = ~bit_control; DIGTAL_LED_D3 = ~bit_control; DIGTAL_PORT = Getcode(array_key[count]); DIGTAL_LED_D4 = bit_control; DIGTAL_LED_D3 = ~bit_control; count++; } else { count=0; }} 4.Lcd显示屏、键盘扫描同前两次实验 5.主函数 123456789101112131415161718192021222324252627282930313233void main(void){ hdwinit(); R_PCLBUZ0_Create(); R_TAU0_Create(); R_TAU0_Channel0_Start(); R_MAIN_UserInit(); lcd_init(); num_keyboard=0; /* Start user code. Do not edit comment generated here */ while (1U) { lcd_display(0,\" 任泽华 \" \" 自动化71班 \" \" 2171411498 \"); lcd_display(48,date); Keyboard_scan(); if(num_keyboard==14){sflag=1;} if(sflag==1)num_10 = num/10; else {num=0;num_10=0;} if(bflag==0 &amp;&amp; num_10==10){ R_PCLBUZ0_Start(); bflag=1; delaya();R_PCLBUZ0_Stop();} if(num_keyboard==13){bflag=0; num=0;num_keyboard=0;sflag=0;} if(num_keyboard!=0) display(); if(num_keyboard==13){bflag=0; num=0;num_keyboard=0;sflag=0;} leddispaly(); NOP(); WDTE = 0xAC; } /* End user code. Do not edit comment generated here */} (四)实验效果（详见视频） (五)实验总结 这次实验实现了要求的功能，对于中断、定时有了初步的认识。利用中断和定时功能可以完成计时。同时也可以利用蜂鸣器来提醒计时结束。这次实验也修复了之前实验中代码的一些bug，让程序可执行性更好。对于端口的配置进行了学习，时间原因没有做得更加完善，没有通过端口定义来生成代码实现功能，不过新的工程已经在完善当中，相信下一次可以通过自己新建工程来实现功能，而不是拷贝例程的端口代码到自己的端口文件。 另外，在自己的电脑上运行cubesuite+时发现代码生成器丢失了，经过查阅老师提供的学习资料了解到需要在一开始进行设置。在接上板子以后，发现提示要安装驱动，在与同学的交流中也找到了解决方案。这说明善于通过各种方式学习是很重要的，有时候想不明白的问题多看相关资料，多与老师同学交流，才能达到更好的效果。 第三次视频 第三次改进","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"微机原理实验报告","date":"2019-11-23T08:00:00.000Z","path":"2019/11/23/微机原理实验报告/","text":"大三上微机原理课程实验报告 1.8259中断控制实验 1.1实验目的 1.掌握8259中断控制器的工作原理; 2.学习8259的应用编程方法; 3.掌握8259级联方式的使用方法。 1.2实验设备 PC机一台，TD-PITE实验装置- -套。 1.3实验内容及步骤 1.中断控制器8259简介 在Intel 386EX芯片中集成有中断控制单元(ICU) ，该单元包含有两个级联中断控制器，一个 为主控制器，一个为从控制器。该中断控制单元就功能而言与工业上标准的82C59A是一致的，操作方法也相同。从片的INT连接到主片的IR2信号上构成两片8259的级联。 在TD-PITE实验系统中，将主控制器的IR6、IR7以及从控制器的IR1开放出来供实验使用， 主片8259的IR4供系统串口使用。8259的内部连接及外部管脚引出如图2-3-1所示。 表2-3-1列出了中断控制单元的寄存器相关信息。 初始化命令字1寄存器(ICW1) 说明见图2-3-2所示。 初始化命令字2寄存器(ICW2)说明见图2-3-3所示。 初始化命令字3寄存器(ICW3) 说明，主片见图2-3-4，从片见图2-3-5。 初始化命令字4寄存器(ICW4) 说明见图2-3-6。 操作命令字1寄存器(OCW1) 说明见图2-3-7。 操作命令字2寄存器(OCW2) 说明如图2-3-8所示。 操作命令字3寄存器(OCW3) 说明如图2-3-9所示。 查询状态字(POLL) 说明如图2-3-10 所示。 在对8259进行编程时，首先必须进行初始化。一般先使用CLI指令将所有的可屏蔽中断禁止，然后写入初始化命令字。8259有--个状态机控制对寄存器的访问，不正确的初始化顺序会造成异常初始化。在初始化主片8259时，写入初始化命令字的顺序是: ICW1、 ICW2、ICW3、 然后是ICW4,初始化从片8259的顺序与初始化主片8259的顺序是相同的。 系统启动时，主片8259已被初始化，且4号中断源(IR4) 提供给与PC联机的串口通信使用，其它中断源被屏蔽。 2.8259单中断实验 实验接线图如图2-3-1 1所示，单次脉冲输出与主片8259的IR7相连，每按动一次单次脉冲，产生一次外部中断，在显示屏.上输出一个字符“7” 实验步骤 (1)按图2-3-11 连接实验线路; (2)编写实验程序，经编译、链接无误后装入系统; (3)运行程序，重复按单次脉冲开关KK1 +,显示屏会显示字符“7” 以说明响应了中断。 源程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970;=========================================================; 文件名: INT1.ASM; 功能描述: 8259中断实验，中断源为主片8259的IRQ7; 每产生一次中断输出显示一个字符6;=========================================================SSTACK SEGMENT STACK DW 32 DUP(?)SSTACK ENDSCODE SEGMENT ASSUME CS:CODESTART: PUSH DS MOV AX, 0000H MOV DS, AX MOV AX, OFFSET MIR7 ;取中断入口地址 MOV SI, 003CH ;中断矢量地址 MOV [SI], AX ;填IRQ7的偏移矢量 MOV AX, CS ;段地址 MOV SI, 003EH MOV [SI], AX ;填IRQ7的段地址矢量 CLI POP DS ;初始化主片8259 MOV AL, 11H OUT 20H, AL ;ICW1 MOV AL, 08H OUT 21H, AL ;ICW2 MOV AL, 04H OUT 21H, AL ;ICW3 MOV AL, 01H OUT 21H, AL ;ICW4 ;初始化从片8259 ;MOV AL,11H ;OUT 0A0H,AL ;MOV AL,30H ;OUT 0A1H,AL ;MOV AL,02H ;OUT 0A1H,AL ;MOV AL,01H ;OUT 0A1H,AL ;MOV AL,0FFH ;OUT 0A1H,AL MOV AL, 6FH ;OCW1 OUT 21H, AL STIAA1: NOP JMP AA1 MIR7: STI CALL DELAY MOV AX, 0136H INT 10H ;显示字符 MOV AX, 0120H INT 10H MOV AL, 20H OUT 20H, AL ;中断结束命令 IRET DELAY: PUSH CX MOV CX, 0F00HAA0: PUSH AX POP AX LOOP AA0 POP CX RET CODE ENDS END START 结果拍照 按动一次按钮显示一个6 PS：将“7”改为了“6”。 3.8259级联实验 实验接线图如图2-3-12所示，KK1 +连接到主片8259的IR7. 上， KK2+连接到从片8259的IR1上，当按一-次KK1 +时，显示屏上显示字符“M7”，按- -次KK2+时，显示字符“S1”。编写程序。 实验步骤 (1)按图2-3-12 连接实验线路; (2)输入程序，编译、链接无误后装入系统; (3)运行程序,按动KK1+或KK2+,观察实验结果，验证实验程序的正确性; (4)若同时按下FKK1 +和KK2+,观察实验结果，解释实验现象。. 源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394;=========================================================; 文件名: INTcas1.ASM; 功能描述: 8259级联中断实验，中断源为主片8259的IR7，; 从片8259的IR1。从片8259通过主片8259的IR2; 进行级联。; 主片每产生一次中断输出显示一个字符M7，从片; 每产生一次中断输出显示一个字符S1。;=========================================================SSTACK SEGMENT STACK DW 32 DUP(?)SSTACK ENDSCODE SEGMENT ASSUME CS:CODESTART: PUSH DS MOV AX, 0000H MOV DS, AX MOV AX, OFFSET MIR7 ;取中断入口地址 MOV SI, 003CH ;中断矢量地址 MOV [SI], AX ;填IRQ7的偏移矢量 MOV AX, CS ;段地址 MOV SI, 003EH MOV [SI], AX ;填IRQ7的段地址矢量 MOV AX, OFFSET SIR1 MOV SI, 00C4H MOV [SI], AX MOV AX, CS MOV SI, 00C6H MOV [SI], AX CLI POP DS ;初始化主片8259 MOV AL, 11H OUT 20H, AL ;ICW1 MOV AL, 08H OUT 21H, AL ;ICW2 MOV AL, 04H OUT 21H, AL ;ICW3 MOV AL, 01H OUT 21H, AL ;ICW4 ;初始化从片8259 MOV AL, 11H OUT 0A0H, AL ;ICW1 MOV AL, 30H OUT 0A1H, AL ;ICW2 MOV AL, 02H OUT 0A1H, AL ;ICW3 MOV AL, 01H OUT 0A1H, AL ;ICW4 MOV AL, 0FDH OUT 0A1H,AL ;OCW1 = 1111 1101 MOV AL, 6BH OUT 21H, AL ;主8259 OCW1 STIAA1: NOP JMP AA1 MIR7: CALL DELAY MOV AX, 014DH INT 10H ;M MOV AX, 0137H INT 10H ;显示字符7 MOV AX, 0120H INT 10H MOV AL, 20H OUT 20H, AL ;中断结束命令 IRETSIR1: CALL DELAY MOV AX, 0153H INT 10H ;S MOV AX, 0131H INT 10H ;显示字符1 MOV AX, 0120H INT 10H MOV AL, 20H OUT 0A0H, AL OUT 20H, AL IRET DELAY: PUSH CX MOV CX, 0F00HAA0: PUSH AX POP AX LOOP AA0 POP CX RET CODE ENDS END START 结果拍照 （1） 重复按单次脉冲开关KK1＋，显示屏会显示字符“M7” （2） 当按一次KK1＋时，显示屏上显示字符“M7”，按一次KK2＋时，显示字符“S1” （3） 同时按下KK1＋和KK2＋，程序仅响应主片的中断。这是由于程序中写的控制字ICW4=0A1H，对应的嵌套模式处为0，选择全嵌套模式。全嵌套模式下当接受到同级的中断请求时，不会响应从片的中断请求。 2.8254定时/计数器应用实验 2.1实验目的 1.掌握8254的工作方式及应用编程; 2.掌握8254典型应用电路的接法。 2.2实验设备 PC机一台，TD-PITE 实验装置一套，示波器一台。 2.3实验内容 1.计数应用实验。编写程序,应用8254的计数功能,使用单次脉冲模拟计数,使每当按动'KK 1+’5次后，产生一次计数中断，并在屏幕上显示一个字符‘M'。 2.定时应用实验。编写程序，应用8254的定时功能，产生一个1ms 的方波。 2.4实验原理 8254是Intel 公司生产的可编程间隔定时器。是8253 的改进型，比8253具有更优良的性能。8254具有以下基本功能: (1)有3个独立的16位计数器; (2)每个计数器可按二进制或十进制(BCD) 计数; (3)每个计数器可编程工作于6种不同工作方式; . (4)8254每个计数器允许的最高计数频率为10MHz(8253为2MHz); 8254 有读回命令(8253 没有)，除了可以读出当前计数单元的内容外,还可以读出状态寄存器的内容; (6)计数脉冲可以是有规律的时钟信号，也可以是随机信号。计数初值公式为:n=fclki/ fouti.其中fclki是输入时钟脉冲的频率，fouti是输出波形的频率。图2-5-1是8254的内部结构框图和引脚图，它是由与CPU的接口、内部控制电路和三个计数器组成。8254的工作方式如下述: (1)方式0:计数到0结束输出正跃变信号方式。 (2)方式1:硬件可重触发单稳方式。 (3)方式2:频率发生器方式。 (4)方式3:方波发生器。 (5)方式4:软件触发选通方式。 (6)方式5:硬件触发选通方式。 8254的控制字有两个:一个用来设置计数器的工作方式，称为方式控制字;另一个用来设置读回命令，称为读回控制字。这两个控制字共用-一个地址，由标识位来区分。控制字格式如表2-5-1所示。 2.5实验步骤 1.计数应用实验 编写程序,将8254的计数器0设置为方式3,计数值为十进制数4,用单次脉冲KK1 +作为CLK0时钟，OUTO连接MIR7,每当KK1 +按动5次后产生中断请求，在屏幕上显示字符“M”。 实验步骤： (1)实验接线如图2-5-2所示; (2)编写实验程序，经编译、链接无误后装入系统; (3)运行程序，按动KK1+产生单次脉冲，观察实验现象; (4)改变计数值，验证8254的计数功能。 源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768;=========================================================; 文件名: A82541.ASM; 功能描述: 通过对计数器0进行计数，计数初值为4，; 当计数满后，产生正跳变触发中断，中断; 程序显示M(每按5次输出一个M);=========================================================A8254 EQU 06C0HB8254 EQU 06C2HC8254 EQU 06C4HCON8254 EQU 06C6HSSTACK SEGMENT STACK DW 32 DUP(?)SSTACK ENDSCODE SEGMENT ASSUME CS:CODE, SS:SSTACKSTART: PUSH DS MOV AX, 0000H MOV DS, AX MOV AX, OFFSET IRQ7 ;取中断入口地址 MOV SI, 003CH ;中断矢量地址 MOV [SI], AX ;填IRQ7的偏移矢量 MOV AX, CS ;段地址 MOV SI, 003EH MOV [SI], AX ;填IRQ7的段地址矢量 CLI POP DS ;初始化主片8259 MOV AL, 11H OUT 20H, AL ;ICW1 MOV AL, 08H OUT 21H, AL ;ICW2 MOV AL, 04H OUT 21H, AL ;ICW3 MOV AL, 01H OUT 21H, AL ;ICW4 MOV AL, 6FH ;OCW1 OUT 21H, AL ;8254 MOV DX, CON8254 MOV AL, 10H ;计数器0，方式0 OUT DX, AL MOV DX, A8254 MOV AL, 04H OUT DX, AL STIAA1: NOP JMP AA1 IRQ7: MOV DX, A8254 MOV AL, 04H OUT DX, AL MOV AX, 014DH INT 10H ;显示字符M MOV AX, 0120H INT 10H MOV AL, 20H OUT 20H, AL ;中断结束命令 IRET CODE ENDS END START 结果拍照 按动一次按钮显示一个M。 2.定时应用实验 编写程序，将8254的计数器0设置为方式3,用信号源1MHz作为CLK0时钟, OUT0为波形输出1ms方波。 实验步骤： (1)接线图如图2-5-3所示; (2)根据实验内容，编写实验程序，经编译、链接无误后装入系统; (3)运行实验程序，用示波器测试OUTO输出，验证程序功能。 按照图接线，将实验程序编译、链接、装入系统，运行程序，OUT0输出方波。根据8254工作原理绘制波形图如图： 8254方波 3.8255并行接口实验 3.1实验目的 1.学习并掌握8255的工作方式及其应用; 2.掌握8255典型应用电路的接法。 3.2实验设备 PC机一台，TD-PITE实验装置一套。 3.3实验内容 1.基本输入输出实验。编写程序，使8255 的A口为输入，B口为输出，完成拨动开关到数据灯的数据传输。要求只要开关拨动，数据灯的显示就发生相应改变。 2.流水灯显示实验。编写程序,使8255的A口和B口均为输出，数据灯D7D0由左向右，每次仅亮-一个灯，循环显示，D15D8与D7~D0正相反，由右向左，每次仅点亮-一个灯，循环显示。 3.4实验原理 并行接口是以数据的字节为单位与I/O设备或被控制对象之间传递信息。CPU和接口之间的数据传送总是并行的，即可以同时传递8位、16位或32位等。8255 可编程外围接口芯片是Intel公司生产的通用并行I/O接口芯片,它具有A、B、C三个并行接口，用+5V单电源供电，能在以下三种方式下工作:方式0--基本输入/输出方式、方式1--选通输入/输出方式、方式2--双向选通工作方式。8255的内部结构及引脚如图2-6-1所示，8255工作方式控制字和C口按位置位/复位控制字格式如图2-6-2所示。. 3.5实验步骤 1.基本输入输出实验 本实验使8255端口A工作在方式0并作为输入口，端口B工作在方式0并作为输出口。用一组开关信号接入端口A,端口B输出线接至- -组数据灯上，然后通过对8255芯片编程来实现输入输出功能。具体实验步骤如下述: (1)实验接线图如图2-6-3所示，按图连接实验线路图; (2)编写实验程序，经编译、连接无误后装入系统; (3)运行程序，改变拨动开关，同时观察LED显示，验证程序功能。 源程序 12345678910111213141516171819202122232425262728293031323334;=========================================================; 文件名: A82551.ASM; 功能描述: A口为输入，B口为输出，将读入的数据输出显示; IOY1;=========================================================SSTACK SEGMENT STACK DW 32 DUP(?)SSTACK ENDSCODE SEGMENT ASSUME CS:CODE, SS:SSTACKSTART: MOV DX, 0646H MOV AL, 90H OUT DX, AL AA1: MOV DX, 0640H IN AL, DX CALL DELAY MOV DX, 0642H OUT DX, AL JMP AA1 DELAY: PUSH CX MOV CX, 0F00HAA2: PUSH AX POP AX LOOP AA2 POP CX RET CODE ENDS END START 结果拍照 流水灯按照开关的开闭被选择点亮。 2.流水灯显示实验 使8255的A口和B口均为输出，数据灯D7D0由左向右，每次仅亮一个灯，循环显示，D15D8与D7~D0正相反，由右向左，每次仅点亮一个灯，循环显示。实验接线图如图2-6-5所示。实验步骤如下所述: (1)按图2-6-5连接实验线路图; (2)编写实验程序，经编译、链接无误后装入系统; (3)运行程序，观察LED灯的显示，验证程序功能; (4)自己改变流水灯的方式，编写程序。. 源程序： 123456789101112131415161718192021222324252627282930313233343536373839;=========================================================; 文件名: A82552.ASM; 功能描述: A口为输出，B口为输出，流水灯显示;=========================================================SSTACK SEGMENT STACK DW 32 DUP(?)SSTACK ENDSCODE SEGMENT ASSUME CS:CODESTART: MOV DX, 0646H MOV AL, 80H OUT DX, AL MOV BX, 8001HAA1: MOV DX, 0640H MOV AL, BH OUT DX, AL ROR BH, 1 MOV DX, 0642H MOV AL, BL OUT DX, AL ROL BL, 1 CALL DELAY CALL DELAY JMP AA1 DELAY: PUSH CX MOV CX, 0F000HAA2: PUSH AX POP AX LOOP AA2 POP CX RET CODE ENDS END START 结果拍照 流水灯依次被点亮。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}]},{"title":"嵌入式实验报告2","date":"2019-11-19T07:22:00.000Z","path":"2019/11/19/嵌入式实验报告2/","text":"大三上嵌入式实验报告2 LCD四行分别显示：姓名、学号、班级、年-月-日（通过键盘设定年月日） （一）头文件 123456789#include \"r_cg_macrodriver.h\"#include \"r_cg_cgc.h\"#include \"r_cg_port.h\"#include \"r_cg_wdt.h\"/* Start user code for include. Do not edit comment generated here */#include \"r_cg_lcd.h\"#include \"r_cg_KeyScan.h\"/* End user code. Do not edit comment generated here */#include \"r_cg_userdefine.h\" 说明：在LCD例程的基础上，增加了key&amp;LED例程当中包括的库函数，在工程文件夹中加入\"r_cg_KeyScan.h\"文件和r_cg_KeyScan.c文件，以达到实现键盘输入的目的。 （二）全局变量 12345678/* Start user code for global. Do not edit comment generated here */unsigned int i;extern volatile uint8_t num_keyboard;unsigned char date[16]=\"_ 年 月 日 \";unsigned int x=0;unsigned char pre=' ';unsigned int flag=0;/* End user code. Do not edit comment generated here */ 类似于实验一中的全局变量num_keyboard为键盘输入的值。 Date数组为第四行显示年月日的部分。 X为对年月日输入位置的计数变量 Flag为延时使用的变量，可以通过display（）函数中对其值的变化范围进行限制，可以实现键盘输入的响应时间。 经过实验发现，若flag循环数小于20，则过于灵敏，在按一次按键时可能会输入多个数字；若循环数过大，则键盘的延时会增大，不利于输入。故在此将循环数取为25。 Pre初始化为一个空格字符，在运行时做中间变量存储显示的值。 i为源例程程序当中的变量，为主程序中原有的一个计数变量，在这里不做使用，特此说明。 （三）端口定义 将key&amp;LED例程当中的端口定义粘贴过来即可。 （四）子函数 1234void R_MAIN_UserInit(void);void display();void getnext();void getpre(); void R_MAIN_UserInit(void);函数是原始定义的初始化函数 void display();是进行输入、显示的主要函数 void getnext();和void getpre();分别是获取下一个该输入的位置和获取上一个输入的位置（要避开已有的“年 月 日”） （五）主程序 123456789101112131415161718192021222324252627void main(void){ hdwinit(); R_MAIN_UserInit(); lcd_init(); num_keyboard=0; /* Start user code. Do not edit comment generated here */ //lcd_init( ); //LcdFill_Level(); while (1U) { //for(i = 0;i &lt; 2000; i++) lcd_display(0,\" 任泽华 \" \" 自动化71班 \" \" 2171411498 \"); lcd_display(48,date); Keyboard_scan(); if(num_keyboard!=0) display(); NOP(); WDTE = 0xAC; } /* End user code. Do not edit comment generated here */} 程序说明： 在LCD例程的基础上，增加了key&amp;LED例程中的键盘模块。 在while循环中，首先播放固定的内容，即姓名学号；再播放键盘输入模块（年月日）。 增加键盘输入，改变（年月日）模块的参数，实现键盘输入。 （六）Display（）函数 12345678910111213141516171819202122232425262728293031323334353637383940void display(){ //if(num_keyboard!=0）flag++； flag++; if(flag&gt;25) { if(num_keyboard&gt;10) { switch(num_keyboard) { case(11): { getpre(); date[x]=' '; break; } case(13): { date[x]=pre; getpre(); pre=date[x]; date[x]=95; break; } } } else { date[x]=num_keyboard+47; x++; getnext(); if(x!=0) date[x]=95;//显示_指示下一位输入位置 } flag=0; num_keyboard=0; }} 这是键盘输入显示的主要部分，首先通过flag实现延时，避免过于灵敏。通过键盘输入的参数进行选择，定义键盘的顺序110分别对应字符09。在输入后下一位显示“_”指示当前的输入位。另外定义了删除键和选择位置键，它们对应的按键分别是11、13。 （七）Getnext（）和getpre（）函数 1234567891011121314151617181920void getnext(){ switch(x) { case(4):x=x+2;break; case(8):x=x+2;break; case(12):x=0;break; default:break; }}void getpre(){ switch(x) { case(6):x=x-3;break; case(10):x=x-3;break; case(0):x=11;break; default:x--; }} 获取下一个该输入的位置和获取上一个输入的位置 （避开已有的“年 月 日”） （八）实验照片： 输入日期：","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"嵌入式实验报告1","date":"2019-11-10T12:50:00.000Z","path":"2019/11/10/嵌入式实验报告1/","text":"大三上嵌入式实验报告1 调试完成视频例程 123456789101112131415void main(void){ R_MAIN_UserInit(); /* Start user code. Do not edit comment generated here */ while (1U) { P4.1=0; P4.3=1; delay(1000); P4.1=1; P4.3=0; delay(1000); } /* End user code. Do not edit comment generated here */} 修改了一部分功能，实现了两个LED灯轮流闪烁 数码管显示学号 更改了display()函数，使其能够实现输入三位学号的功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void dispaly(void){ counter++; if(counter&gt;300) { if (num_keyboard!=0) { num[n_count]=num_keyboard%10; n_count++; if(n_count&gt;=3) { n_count=0; } counter=0; for(ii=0;ii&lt;200;ii++) { ; } } } num_keyboard=0; if(count&lt;3) { if(count==0) { DIGTAL_LED_D4 = 1; DIGTAL_LED_D3 = 0; DIGTAL_LED_D2 = 0; } else if(count==1) { DIGTAL_LED_D4 = 0; DIGTAL_LED_D3 = 1; DIGTAL_LED_D2 = 0; } else if(count==2) { DIGTAL_LED_D4 = 0; DIGTAL_LED_D3 = 0; DIGTAL_LED_D2 = 1; } DIGTAL_PORT = Getcode(num[count]); count++; } else { count=0; } }/* End user code. Do not edit comment generated here */ 实验拍照：（学号后三位498）","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"电子线路设计上实验报告3","date":"2019-11-07T15:02:00.000Z","path":"2019/11/07/电子线路设计上实验报告3/","text":"大三上电子线路设计上实验报告3 ——单片机播放《bad apple》动画（带延时功能） 一、硬件原理图 (一)数码管 我采用的是7SEG-MPX2-CA型两位数字显示的数码管，可以显示0~99一共100个数字，由ABCDEFG DP八个输入控制，其电位分别由单片机的P3.0~P3.7接出，并行受到单片机的控制。1，2端分别接Q1,Q2两个晶体管和电源作为驱动。两个晶体管的控制信号分别由单片机的P2.6、P2.7口接出。在与老师的交流中我了解到，虽然仿真时不接驱动也可以实现，但是在实际操作中，外加驱动是必不可少的，单片机只能提供控制信号，而数码管的能量要靠驱动获得。 (二)Lcd显示屏 Lcd 显示屏由128x64个像素组成，型号为AMPIRE128x64。Lcd显示屏的8，7，6，2，1口分别接单片机的P2.0~P2.4口；9~16口分别接单片机的P1.0~P1.7口；17口接电源。由单片机产生并行信号把图片显示在屏幕上，经过设定显示的内容、延时等等，就可以实现动画效果。 在老师的例程中，我探究如何把图片转换为像素文件，在Image2Lcd软件中，将比例为128x64比例的图片导入，但是最开始，我的图片显示出现了问题，呈现一种多个图片重复叠加的效果，在尝试之后发现应当把扫描方式改为数据水平，字节垂直；下面勾选“字节内象素数据反向”。最后呈现的结果如下图所示： (三)键盘 键盘用五个可复位按键开关组成，分别用于实现倒计时复位/视频暂停、倒计时开始/视频重新播放、停止计时、计时加一、计时减一的功能。其中第一个按键接单片机的P2.5口，第二~第五分别接单片机的P1.4~P1.7口，用于输入控制信号。 (四)SD卡模拟器 这是一个SD卡模拟器MMC，可以模拟外接的存储卡。其中的内容由SD.mmc提供。由于视频数据比较大而单片机的空间有限，只需要在播放时从外部读取每一帧的数据即可，该元件就是实现了这个功能。其CLK、DO、DI、CS口分别接单片机的P1.0~P1.3口，用于输入数据。 (五)时钟电路 单片机必备的计时电路，由晶振、电容等等元件组成，生成时钟信号，分别接单片机的XTAL1、XTAL2、EA口。 (六)单片机AT89C52 电路中最重要的器件，本实验中采用AT89C52单片机，其中引脚与外部的连接在前面已经介绍，在本例中的主要作用是依据键盘输入的信号，控制数码管和lcd显示屏输出内容。包括开始计时、暂停计时、计时数增减、暂停播放视频、从头播放视频等等。其中MMC、键盘、时钟是输入信号，lcd、数码管是输出设备。 二、软件实现流程 (一)主函数部分main.c 主要利用了计时当中key()函数中全局变量jishu、bz的变化，在播放动画时，若键盘有输入，jishu的值也会变化，此时通过条件语句判断，如果jishu不为0，跳出循环（暂停）。若bz为1，播放动画的帧序号变量SD_ADDR置零，实现重复播放。 播放动画部分 主要函数为dispicture、dispictureb、SdReadBlock 作用分别是：显示LCD上半部分、显示LCD下半部分、读取SD卡文件。 其中SdReadBlock函数在文件SD.c中，SD.c为从网上搜索的读取SD卡方法的例程，在研究清楚其具体作用后，我将它放入了自己的工程中，并进行了调用。 倒计时部分 主要函数为display()、dis()、key() 分别的作用是：获取数码管显示的数字信息、进行数码管显示、读取按键内容。 可以看出，key()函数的主要作用就是通过读入按键的信息，改变全局变量的值，在数码管例程中，它的作用是改变数码管的值，那么我也可以把它们应用到动画播放当中，从而实现动画播放当中的控制，包括暂停，重播等等。与倒计时配合，可以达到预期效果。 (二)SD卡读取数据部分SD.c 此部分为例程引用，是一个单独的部分，对于它的功能进行了探究，它的作用是从SD卡中读取数据，并且通过四根引线传入单片机当中。 (三)头文件SD.h 起初考虑过把所有的内容都放到一个c文件当中，但是考虑到程序的可读性和修改的方便，同时为了区分我的工作内容和外部引用，我把它们分了开来。其实多个代码文件构成一个工程，共同实现一个功能，这是所有单片机开发者必须学会的操作。我借此练习了一下多个程序文件之间连接调用的方法。通过查阅资料，我了解到，正如学习C语言是要用到的头文件，我也可以自己定义一个头文件，这样就可以实现外部的函数引用。 刚开始我的程序报错了，原因是没有在外部引用的c文件中也包含该头文件，在修改以后就实现了外部库函数的调用。 视频见：“计时播放视频.mp4”工程文件见“lib3”文件夹 三、实验总结 通过这半个学期的电子线路设计实验，我着实学到了许多。忽然想到一句话：“纸上得来终觉浅，绝知此事要躬行”。在课堂上学到的东西很多，但是大部分如果不用的话很快就会忘记，但是这个实验中学到的许多知识却是记忆犹新。 有许多操作，许多电子线路、数字逻辑、单片机原理、接口技术等等的知识，虽然以前在课堂上学过，但是却不太记得。在调试实验电路时，我遇到问题，会从网上论坛、课本等等渠道去寻求解答。在实在解决不了问题时，我会和同学老师讨论。在这样的氛围下，我把之前不会的、不扎实的知识又重新学习巩固了一遍。 让我印象深刻的是第二次实验，我做了一个放烟花的电路，其中控制电路用到了晶体管。虽然模拟电子技术当中反反复复的学过，但是真正应用的时候，还是又这样那样的问题。遇到了二极管不亮的情况，返回去排查电路，应用模电知识，我发现是晶体管工作在了截至区的缘故。 还有就是在应用Image2Lcd软件时，刚开始显示的图片是重叠的。经过探索，我发现是扫描方式没有选对。这样经过探究错误、发现问题、解决问题的过程，让我对于像素表示图像的原理有了一定的认识。 最后一次实验也是我一直想做的，之前看到b站好多大佬用单片机播放bad apple动画，我都很羡慕，期望有一天能自己实现。现在在仿真软件上勉强实现了一下，还加入了一些小功能。不过其中很大一部分代码不是我的原创，是从各种例程当中改过来的。当然，实际的芯片和仿真软件也会有差别，所以说我要做的还有很多，在即将到来的嵌入式实验中，我可以进一步在实体芯片上再次尝试实现播放bad apple。 在应用单片机时，并行、串行、总线等概念时时出现，这些内容也在微机原理与嵌入式系统的课程中反复出现，我要学的还有很多。虽然现在能实现一个简单的功能，但是我能感觉到自己对于这些概念的理解还有欠缺，所以在之后要再次进行深入的学习。 非常感谢老师的悉心指导！ 四、做的不太成功的另一个作品 该部分实现结果不太理想，故没有放到正文中，不过还是把它写在报告里面。 视频文件见“another_播放速度控制.mp4”工程文件见“another”文件夹 原理图： 最大的不同就是加入了一个BCD码转七段数码管的元件7448.通过输入对应延时量的BCD码，改变动画播放延时的大小，从而控制动画播放的速度。 一些不同的器件： 键盘： PB0~PB3分别接单片机的P1.4~P1.7和7448的7、1、2、6口，输入的是需要延时的BCD码。 7448： 只是显示键盘输入BCD码的十进制表示，其实与单片机没有直接联系，本来我想通过单片机输出信号控制它，但是在播放动画的同时控制它会报错，查阅资料后发现加入一个锁存器会解决这一问题。 部分代码： 相交正式作品，这个比较简单，没有定时的部分，最后延时函数传入的参数是四位BCD码转换成的十进制数，从而实现了对延时的控制，进一步改变了播放速度。但是在仿真中，速度改变并不明显。 五、附录 (一)原理图 (二)程序代码 1)Main函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302#include &lt;REGX52.H&gt;#include \"SD.h\"#include &lt;intrins.h&gt; //数码管段码端口#define PP P3//共阳极数码管段码unsigned char code SEG7[]={/*0,1,2,3,4,5,6,7,8,9,*/0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,};//数码管显示缓冲unsigned char num[]={1,2};//数码管位码端口sbit q1=P2^6;sbit q2=P2^7;//复位开始停止加1减1按键sbit k1=P2^5;sbit k2=P1^4;sbit k3=P1^5;sbit k4=P1^6;sbit k5=P1^7;//----------------------------------------------------unsigned long SD_ADDR=0;unsigned int count;unsigned char xdata DATA[512];sbit E = P2^0;sbit RW = P2^1;sbit RS = P2^2;sbit CS2 = P2^3;sbit CS1 = P2^4; //端口定义#define DataPort P0 /*12864判忙 */bit Chek_Busy(void){ DataPort = 0xff; RW = 1; RS = 0; E = 1; E = 0; return (bit)(DataPort &amp; 0x80);}/*------------------------------------------------ 选屏i:0是左屏,1是右屏,2全屏------------------------------------------------*/void Choose_12864(unsigned char i){ switch (i) { case 0: CS1 = 0;CS2 = 1;break; case 1: CS1 = 1;CS2 = 0;break; case 2: CS1 = 0;CS2 = 0;break; default: break; }}/*------------------------------------------------ 写命令------------------------------------------------*/void LCD_Cmd(unsigned char cmd){ while(Chek_Busy()); RW = 0; RS = 0; DataPort = cmd; E = 1; E = 0; }/*------------------------------------------------ 读LCD------------------------------------------------*/unsigned char LCD_Read(){ unsigned char read_data; while(Chek_Busy()); RW = 1;//需进行一次空读 RS = 1; E = 1; E = 0; RW = 1; RS = 1; E = 1; read_data = DataPort; E = 0; return (read_data); }/*------------------------------------------------ 写数据------------------------------------------------*/void LCD_Data(unsigned char dat){ while(Chek_Busy()); RW = 0; RS = 1; DataPort = dat; E = 1; E = 0; }/*------------------------------------------------ 设置地址PAGE:0-7;Y_Address:0-63------------------------------------------------*/void Set_PageY(unsigned char PAGE,unsigned char Y_Address){ LCD_Cmd(0xB8 + PAGE); LCD_Cmd(0x40 + Y_Address);}/*------------------------------------------------ 清屏------------------------------------------------*/void LCD_Clear(void){ unsigned char page,row; Choose_12864(2); for (page = 0xb8; page &lt; 0xc0; page ++) { LCD_Cmd(page); LCD_Cmd(0x40); for (row = 0; row &lt; 64; row ++) { LCD_Data(0x00);//对12864所有地址全部写零 } }}/*------------------------------------------------ 初始化------------------------------------------------*/void LCD_Init(void){ CS2 = 0; CS1 = 0; LCD_Cmd(0x3F);//开显示}/*------------------------------------------------- 显示一幅12864图片-------------------------------------------------*/void Dis_Picture(unsigned char *picture){ unsigned char ii,kk; for (kk = 0; kk &lt; 4; kk ++)//LCD共分7=8页 { Choose_12864(2); Set_PageY(kk,0); Choose_12864(0); for (ii = 0; ii &lt; 128; ii ++) { LCD_Data(*picture); picture ++; if (ii == 63) { Choose_12864(1); } } }}void Dis_Pictureb(unsigned char *picture){ unsigned char ii,kk; for (kk = 4; kk &lt; 8; kk ++)//LCD共分7=8页 { Choose_12864(2); Set_PageY(kk,0); Choose_12864(0); for (ii = 0; ii &lt; 128; ii ++) { LCD_Data(*picture); picture ++; if (ii == 63) { Choose_12864(1); } } }}void delayus(unsigned char t){ while(--t);}void delayms(unsigned char t){ while(t--) { delayus(245); delayus(245); }}//--------------------------------------------------------------------//倒计时模块//延时函数msvoid _delay_ms(unsigned int t){ unsigned int i,j; for(i=0;i&lt;t;i++) for(j=0;j&lt;120;j++);}//数码管显示void dis(){ //------------------ //显示第1位 PP=num[0]; q1=1; _delay_ms(2); q1=0; //显示第2位 PP=num[1]; q2=1; _delay_ms(2); q2=0; }//计时变量unsigned int jishu1s=10;unsigned int jishu1=10;unsigned int jishu2;//开始停止变量unsigned int bz;//显示控制void dispaly(){ num[0]=SEG7[jishu1%100/10]; //显示个位 num[1]=SEG7[jishu1%10]; //显示小数位}//按键处理void key(){ if(k1==0){jishu1=jishu1s;while(k1==0);}//复位 if(k2==0){bz=1;while(k2==0);}//开始 if(k3==0){bz=0;while(k3==0);}//停止 if(bz==0) { if(k4==0){if(jishu1s&lt;99)jishu1s=jishu1s+1;jishu1=jishu1s;while(k4==0);} //+1 if(k5==0){if(jishu1s&gt;0 )jishu1s=jishu1s-1;jishu1=jishu1s;while(k5==0);} //-1 }} //----------------------------void main(void){_delay_ms(10); //定时器0配置方式1 16 TMOD=0x01; //使能定时器0 ET0=1; //定时器的初值 TH0=(65536-50000)/256; TL0=(65536-50000)%256; //停止开启定时器0 TR0=1; EA=1; LCD_Init(); LCD_Clear(); SdInit(); DATA[0]=255;; DATA[1]=1; DATA[2]=2; DATA[3]=3; DATA[511]=0xf0; while(1) { dispaly();//显示控制 dis(); //显示 key();//按键 if(jishu1==0) { while(1) { while(!SdReadBlock(DATA,SD_ADDR,512)); SD_ADDR+=512; Dis_Picture(DATA); while(!SdReadBlock(DATA,SD_ADDR,512)); Dis_Pictureb(DATA); SD_ADDR+=512; delayms(100); key();//按键 if(jishu1!=0) break; if(bz==1) SD_ADDR=0; } } } } //----T0 计数 void Time0() interrupt 1{ //重装初值50ms; TH0=(65536-50000)/256; TL0=(65536-50000)%256; //开始 if(bz==1) { jishu2=jishu2+1; //到达1s if(jishu2==20) { jishu2=0; if(jishu1&gt;0)jishu1=jishu1-1;//减1s if(jishu1==0)bz=0;//结束 } } } 2)导入存储卡文件的SD.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &lt;REGX52.H&gt;#include \"SD.h\"sbit ACC0=ACC^0;sbit ACC1=ACC^1;sbit ACC2=ACC^2;sbit ACC3=ACC^3;sbit ACC4=ACC^4;sbit ACC5=ACC^5;sbit ACC6=ACC^6;sbit ACC7=ACC^7;//定义SD卡需要的4根信号线sbit SD_CLK = P1^0;sbit SD_DI = P1^2;sbit SD_DO = P1^1;sbit SD_CS = P1^3;//写一字节到SD卡,模拟SPI总线方式void SdWrite(unsigned char DATA){ ACC=DATA; SD_CLK=0; SD_DI=ACC7; SD_CLK=1; SD_CLK=0; SD_DI=ACC6; SD_CLK=1; SD_CLK=0; SD_DI=ACC5; SD_CLK=1; SD_CLK=0; SD_DI=ACC4; SD_CLK=1; SD_CLK=0; SD_DI=ACC3; SD_CLK=1; SD_CLK=0; SD_DI=ACC2; SD_CLK=1; SD_CLK=0; SD_DI=ACC1; SD_CLK=1; SD_CLK=0; SD_DI=ACC0; SD_CLK=1; SD_DI=1;//在空闲状态下DI需为高电平 }//从SD卡读一字节,模拟SPI总线方式unsigned char SdRead(){ SD_CLK=0; SD_CLK=1; ACC7=SD_DO; SD_CLK=0; SD_CLK=1; ACC6=SD_DO; SD_CLK=0; SD_CLK=1; ACC5=SD_DO; SD_CLK=0; SD_CLK=1; ACC4=SD_DO; SD_CLK=0; SD_CLK=1; ACC3=SD_DO; SD_CLK=0; SD_CLK=1; ACC2=SD_DO; SD_CLK=0; SD_CLK=1; ACC1=SD_DO; SD_CLK=0; SD_CLK=1; ACC0=SD_DO; return ACC;}//检测SD卡的响应unsigned char SdResponse(){ unsigned char i=0,response; while(i&lt;=8) { response = SdRead(); if(response==0x00) break; if(response==0x01) break; i++; } return response;} //发命令到SD卡void SdCommand(unsigned char command, unsigned long argument, unsigned char CRC){ SdWrite(command|0x40); SdWrite(((unsigned char *)&amp;argument)[0]); SdWrite(((unsigned char *)&amp;argument)[1]); SdWrite(((unsigned char *)&amp;argument)[2]); SdWrite(((unsigned char *)&amp;argument)[3]); SdWrite(CRC);}//初始化SD卡unsigned char SdInit(void){ int delay=0, trials=0; unsigned char i; unsigned char response=0x01; SD_CS=1; for(i=0;i&lt;=9;i++) SdWrite(0xff); SD_CS=0; //Send Command 0 to put MMC in SPI mode SdCommand(0x00,0,0x95); response=SdResponse(); if(response!=0x01) { return 0; } while(response==0x01) { SD_CS=1; SdWrite(0xff); SD_CS=0; SdCommand(0x01,0x00ffc000,0xff); response=SdResponse(); } SD_CS=1; SdWrite(0xff); return 1; }//往SD卡指定地址写数据,一次最多512字节unsigned char SdWriteBlock(unsigned char *Block, unsigned long address,int len){ unsigned int count; unsigned char dataResp; //Block size is 512 bytes exactly //First Lower SS SD_CS=0; //Then send write command SdCommand(0x18,address,0xff); if(SdResponse()==00) { SdWrite(0xff); SdWrite(0xff); SdWrite(0xff); //command was a success - now send data //start with DATA TOKEN = 0xFE SdWrite(0xfe); //now send data for(count=0;count&lt;len;count++) SdWrite(*Block++); for(;count&lt;512;count++) SdWrite(0); //data block sent - now send checksum SdWrite(0xff); //两字节CRC校验, 为0XFFFF 表示不考虑CRC SdWrite(0xff); //Now read in the DATA RESPONSE token dataResp=SdRead(); //Following the DATA RESPONSE token //are a number of BUSY bytes //a zero byte indicates the MMC is busy while(SdRead()==0); dataResp=dataResp&amp;0x0f; //mask the high byte of the DATA RESPONSE token SD_CS=1; SdWrite(0xff); if(dataResp==0x0b) { return 0; } if(dataResp==0x05) return 1; return 0; } return 0;}//从SD卡指定地址读取数据,一次最多512字节unsigned char SdReadBlock(unsigned char *Block, unsigned long address,int len){ unsigned int count; //Block size is 512 bytes exactly //First Lower SS SD_CS=0; //Then send write command SdCommand(0x11,address,0xff); if(SdResponse()==00) { //command was a success - now send data //start with DATA TOKEN = 0xFE while(SdRead()!=0xfe); for(count=0;count&lt;len;count++) *Block++=SdRead(); for(;count&lt;512;count++) SdRead(); //data block sent - now send checksum SdRead(); SdRead(); //Now read in the DATA RESPONSE token SD_CS=1; SdRead(); return 1; } return 0;} 3)头文件SD.h 123unsigned char SdInit(void);unsigned char SdReadBlock(unsigned char *Block, unsigned long address,int len);unsigned char SdWriteBlock(unsigned char *Block, unsigned long address,int len);","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"电子线路设计上实验报告2","date":"2019-10-15T12:11:00.000Z","path":"2019/10/15/电子线路设计上实验报告2/","text":"大三上电子线路设计上实验报告2 一、方波三角波发生器 1.电路图： 工程文件：Square&amp;triangular wave.pdsprj 2.用到的器件： 图中器件 中文名 英文名 1 固定电阻 RES 2 稳压二极管 DIODE-ZEN 3 电容 CAP 4 电位器 POT-HG 5 理想运放 OP1P 6 电源地 GND 7 示波器 OSCILLOSCOPE 3.实验过程： 调用器件库中的元件，如图连接电路，点击运行，示波器显示出方波和三角波 调节电位器，示波器显示的方波三角波的频率发生改变 4.遇到的问题： 1.把运放为uA741无法显示波形，怀疑是参数不匹配造成的，有待进一步调整 2.初始没有扰动的情况下没有波形，因为这是仿真环境，不会有噪声信号，稍微移动一下电位器的位置，人工引入扰动才能产生方波和三角波。 5.改进： 把uA741改为理想运放可以避免不起振的结果，在器件库中一些参数的设置可能导致了无法起振，当然，在实际工作中可以选用uA741且由于空间中存在扰动信号，不需要拨动电位器也可以起振。（视频：方波三角波） 二、小型电子声光礼花器 1.电路图 改进前： 工程文件：Fireworks.pdsprj 改进后： 工程文件：Fireworks_plus.pdsprj 2.用到的器件 图中器件 中文名 英文名 1 固定电阻 RES 2 二极管 1N4001 3 电容 CAP 4 电位器 POT-HG 5 极性电容 CAP-ELEC 6 电源地 GND 7 电源 +5V 8 晶体管 NPN 9 扬声器 SPEAKER 10 时基集成电路555 NE555 11 十进制集成电路计数器 4017 12 集成电双向模拟开关 4066 13 发光二极管 LED（三色） 14 示波器 OSCILLOSCOPE 3.实验过程 原理 电路分两部分：模拟礼花发光电路、模拟礼花爆炸发声电路 时基集成电路555构成方波发生器，方波信号一路送至十进制集成电路计数器4017做触发信号，每次的结果使其Q1~Q6之一为“1”，有二极管电路传输至集成电双向模拟开关4066控制端，使它们单独或组合导通，方波信号通过其驱动的三极管饱和导通，点亮相应的发光二极管。 黄色发光二极管的作用：指示电路的工作情况 方波信号经过一个微分电路驱动三极管，三极管在方波上升沿导通，电压按指数规律减小，会产生忽亮渐暗的效果，可以调节电阻和电容的数值来调节变化快慢。 由电路可知，Q0~Q7亮起时分别对应如下颜色： Q0 红、Q1 绿、Q2 蓝、Q3 红+绿、Q4 红+蓝、Q5 绿+蓝、Q6 红+绿+蓝 几种颜色交替出现产生多彩效果，不同原色混合成其他颜色。 Q7 端为“1”时，复位，循环出现 模拟声音电路由另一时基集成电路完成，复位端接出微分电路，即方波上升沿起与之后一段时间，可以保持高电平，产生的震荡信号去掉扬声器和LED同步工作，发出类似礼花爆炸的声音。（视频：改进前） 4.遇到的问题 方波不方，有杂波 三个发光二极管常亮 扬声器没有声音 声音和礼花不匹配 5.改进 可以看出，改进后的电路去掉了后面的晶体管电路（视频：改进后） 借助示波器的展示，A（黄波形），B（蓝波形）端口分别接到控制红灯和绿灯的双向模拟开关的后端，C（红波形），D（绿波形）端口分别接到两个时基集成电路555 端口，可以看到，输出波形正常。这就说明前面的电路运行正常，可以正常产生控制二极管亮灭的信号，那么就在后面的三极管电路中排查。 进一步分析可知，晶体管始终饱和导通，经过与老师的交流了解到，这与软件本身的参数设置有关。 （视频：调试1） 如图所示，用电压表测得的发光二极管阴极电压基本不变，在整个过程中始终饱和导通。 （视频：调试2） 在改进电路后，发光二极管亮灭是阴极的电压发生了明显的变化，说明改进很成功，二极管可以实现明暗的变化。 说明：将后面的晶体管电路去掉，这样会导致发光二极管的亮灭颠倒，但这却不影响整体的效果，因为整个循环中的环节，二极管的明暗正好是互补的。这样做还有一个好处，那就是节约成本，电路图中的三个二极管只是为了说明关系，真正的电路中会有成百上千个，这样简化电路之后，会大大地节约成本。 6.补充 对于电路的扬声器没有声音的情况，是扬声器参数没有调节正确的结果，在根据电路调节合适的参数后，可以发出较清晰的“砰砰”声。 对于方波不方的问题，经过分析，是电路中其他环节对波形的影响造成的，属于系统误差，不影响系统的正常运行，但是长此以往可能对于器件会有一定的损耗，这也是之后研究优化的方向。 而对于声音不匹配的问题，可以通过调节两个电位器来动态地调节，这样也就保证了二者的匹配。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"电子线路设计上实验报告1","date":"2019-09-23T12:54:00.000Z","path":"2019/09/23/电子线路设计上实验报告1/","text":"大三上电子线路设计上实验报告1 一、例程1 1.电路图： 2.用到的器件： 图中器件 中文名 英文名 1 固定电阻 RES 2 发光二极管 LED（可选择颜色） 3 直流电源 BATTERY 3.实验过程： 调用器件库中的元件，按照要求连接电路，点击运行，二极管被点亮（0.pdsprj） 4.学到的东西： 1.元器件库的位置，刚开始在黑底的编辑窗口找不到P标志，后来发现应该是在白底的窗口才能找到。 2.连线的方法，只要鼠标放到管脚上面就可以连接。 3.元器件的旋转方法，右键点击然后选择选择就好，经过同学提醒发现一个快捷键ctrl和+或者-，可以实现顺时针、逆时针的旋转。 二、例程2 1.电路图： 2.用到的器件： 图中器件 中文名 英文名 1 固定电阻 RES 2 二极管 DIODE 3 电容 定值无极性电容（CAP）有极性电容（CAPACITOR POL） 4 集成定时器 555 5 喇叭（蜂鸣器） SPEAKER（BUZZER） 6 按钮 BUTTON 7 电源 VCC GND 3.实验过程 输出声音见文件夹下的 蜂鸣.mp4（1.pdsprj）蜂鸣器发出了蜂鸣声。 4.学到的东西 学会了VCC和 GND的放置方法，在左边侧栏选择terminals即可，需要注意的是，添加电源和电源地之后要再次双击修改参数，比如说是VCC还是VPP。 三、例程3 1.电路图： 2.用到的器件： 图中器件 中文名 英文名 1 固定电阻 RES 2 发光二极管 LED（可选择颜色） 3 电容 定值无极性电容（CAP）有极性电容（CAPACITOR POL） 4 晶振 CRYSTAL 5 单片机 AT89C51（时钟频率：11.0592） 6 电源 POWER（VCC GND） 3.程序： 12345#include&lt;reg51.h&gt;void main(void){ P1=0xfe;} 4.实验过程 点击运行，发光二极管被点亮。（2.pdsprj） 5.学到的东西： 1.学到了如何在建立工程的时候添加单片机部件，在刚开始选错单片机后后续操作会比较麻烦。 2.学会了怎样在keil当中编辑程序并且把它导入到Proteus当中，当时建立了.c文件以后忘记了把它添加到工程里面，直接运行以后发现什么也没有，要注意敲完代码以后一定要记得添加到工程里面。 3．要记得选择勾选“创建二进制文件”的按钮 四、例程4 1.电路图： 2.用到的器件： 图中器件 中文名 英文名 1 发光二极管 LED（可选择颜色） 2 单片机 AT89C51（时钟频率：11.0592） 3 电源 POWER（VCC GND） 3.实验过程： 实验程序老师在说明文件当中给出，此处不予列出。工程文件3.pdsprj 点击运行，发光二极管依次被点亮，形成“跑马灯”的效果。见 跑马灯.mp4 4.学到的东西： 学到了复杂程序的调试方法，粘贴代码时出了一点小问题，通过下方的编译提示找出了出问题的位置并进行了改正。 五、例程5 1.电路图： 2.用到的器件： 图中器件 中文名 英文名 1 固定电阻 RES 2 发光二极管 LED（可选择颜色） 3 电容 定值无极性电容（CAP）有极性电容（CAPACITOR POL） 4 晶振 CRYSTAL 5 滑线变电阻 POT-HG 6 电阻排 RES中选RESPACR 7 液晶 LM016L 单片机 AT89C51（时钟频率：11.0592） 电源 POWER（VCC GND） 3.实验过程 实验程序老师在说明文件当中给出，此处不予列出。工程文件4.pdsprj 点击运行，液晶屏显示出想要显示的信息，此处为姓名学号。 4.学到的东西： 1.在此例中，我学到了跨接线的接法，在左边工具栏点击wire label model，可以对指定线路进行编号，相同编号认为相连接。 2.这是同学碰到的问题，程序编译正确，电路图也找不到错误，经过搜索发现是在电路图上面应该相连的位置出现了节点，原因是连过了头。所以在连接线路的时候一定要注意不要产生这样的“虚接点” 注：上述例程工程文件在lib1文件夹内，2、3、4.pdsprj相关程序文件在里面的AT89C51文件夹下，名字相同；下方补充练习工程文件为在mylib文件夹内的song.pdsprj，它的程序在该路径下AT89C51文件夹下，happybirthday.hex和jiaoaodeshaonian.hex 六、补充练习 1.电路图： 2.用到的器件： 名称 编号 大类 子类 型号/标称值 数量 80C51 U1 Microprocessor_Ics 80C51_family AT89C51 1 石英晶体 X1 Miscellaneous CRYSTAL 12MHz 1 电阻 R00 Resistors Chip_Resistor_1/8W_5% 10kΩ 1 电容 C00 Capacitors Miniature_Electronlytic 2μ2 1 . C01 C02 Capacitors Ceramic_Disc 33P 2 按键 K0 Switches&amp;Relays Switches BUTTON 1 发声器 LS1 Speakers&amp;Sounders . SOUNDER 1 3.实验过程： 按照电路图连接，在keil里面敲入程序，编译导入Proteus，按下运行键。此时按下按键，音乐开始播放，播放完后再按下按键，音乐重复播放。改变程序里面的与音符、节拍有关的数组，可以播放不同的歌曲。(song.pdsprj)改变定时器参数，可以改变播放顺序。刚开始播放的是《生日快乐》歌，一拍800ms，然后用更快的速度播放《骄傲的少年》，一拍320ms。见生日快乐+骄傲的少年.mp4、骄傲的少年.mp4。不同的程序文件在happybirthday.hex和jiaoaodeshaonian.hex中。 《骄傲的少年》曲谱如下： 此处只选取了前两行内容。 程序如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;reg51.h&gt;sbit K0=P1^0;sbit SOND=P1^7;unsigned char i,j;unsigned char code th[22]={ 0,196,202,208,211,216,220,224,226,229,232,233,236,238,240,241,242,244,244,246,247,248};unsigned char code tl[22]={ 0,12,27,21,7,4,16,12,4,12,9,20,2,8,6,2,22,5,26,1,4,3};unsigned char code s[26]={ 12,12,13,12,15,14,12,12,13,12,16,15,12,12,19,17,15,14,13,0,18,18,17,15,16,15};unsigned char code L[26]={ 4,4,8,8,8,16,4,4,8,8,8,16,4,4,8,8,8,8,16,8,4,4,8,8,8,16};void main(){ unsigned int t; TMOD =0x10; TH1 =0x3c;TL1=0xb0; IP =0x02; IE =0x8a; while(1){ while(K0==1); while(K0==0); for(i=0;i&lt;26;i++){ if(s[i]==0) {SOND=0; TR0=0;} else {TH0=th[s[i]]; TL0=tl[s[i]]; TR0=1;} j=L[i];TR1=1; while(TR1==1); TR0=0; SOND=0; for(t=0;t&lt;2000;t++);}}}void t0() interrupt 1{ SOND=~SOND; TH0=th[s[i]];TL0=tl[s[i]];}void t1() interrupt 3{ TH1=0x3c;TL1=0xb0; if((j--)==0) TR1=0;} 4.学到的东西： 1.进一步巩固了对于Proteus和keil软件的应用，对于电路图的设计、程序的编译运行调试有了进一步的认识，也提高了自己的上手操作能力。 2.学习了定时器的相关知识，TH1、TL1分别对应着高八位和低八位，定时/计数器初值计算公式： 又得知在此例中，是按方式1工作的，N=16，，1机周=1μs，按照此公式可以设计快放（一拍320ms）时的参数，即TH1 =0xc5;TL1=0x68; 3.对于乐理知识有了一定的了解","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"Python选修课大作业","date":"2019-06-05T10:50:00.000Z","path":"2019/06/05/Python选修课/","text":"大二下Python程序设计实验报告（作业大作业） 选修课平时作业见：作业报告 大作业代码材料见：大作业材料 1.软件功能 1.1背单词 该背单词、查单词小软件可以辅助记忆单词，点击可以选择背诵四级、六级、雅思、托福的单词，并且能够自主选择背诵单词数目。通过给出汉语翻译，使用者输入英文，点击检验，即可查看自己是否答对，错误会附有正确答案。点击新单词即可继续背诵，最后系统会统计正确数与错误数，还有总用时。系统还可以实现自我识别，包括未检验即进行下一步、多次检验等等。 1.2查单词 改背单词、查单词小软件还可以实现简单的查单词任务。通过选择词库可以选择在哪个词库下查单词，点击搜索即可出现释义。如果当前词库没有相应的单词，也会出现“没有该单词”的提示。点击重置即可删除所有操作，包括查单词、背单词等等，可以重新开始运行。 2.软件的运行环境 2.1Python版本： python3.7.0（其它python3版本安装xlrd库后应该也能运行） 2.2需要的资源名称 xlrd库（读取excel文件） 3.环境搭建说明 3.1解压文件 将提交的作业文件解压 3.2运行软件 1.打开解压后的文件夹，保证几个.xls文件和“背单词软件.py”在同一文件夹下 2.右键点击“背单词软件.py”，选择用idle打开，进行下一步操作 4.软件的设计说明 4.1设计 软件主要分为两个模块：背单词和记单词。在tkinter模块下进行，分别进行了标签、文本框、按钮等等的设计，通过几个函数的调用，最终实现了期望的效果。 4.2实现思路 1.背单词部分：输入背单词的个数，将其设为全局变量。将词库导入，用随机数的模块随机选择一个单词，输出其意思，再把其内容于输入的单词对比，如果一样输出正确，不一样输出错误并且输出正确答案。点击新单词，清除原始内容开始新的查找。最后记录并输出正确与错误个数，输出时间。再次点击“下一个”或点击“重置”重置。 2.查单词部分：选择对应词库，输入对应单词，用循环分别与词库中的词对比，如果有一样的单词就输出其意义，若没有就输入提示信息表示没有找到。再次点击清除原始内容开始下一次查找，点击“重置”回复原状。 4.3算法 1.背单词部分：用全局变量表示背单词个数、正确个数、错误个数、背诵开始、结束时间、当前词库，所有函数可以自由调用。使用选择结构与标志变量来判断当前应该进行的操作，防止误操作。通过按钮来调用不同的函数，包括装载词库、选择背诵单词数、开始背下一个单词、检验是否正确、重置。计时功能通过结束时间减开始时间来确定。每次点击下一个单词时，加入一行命令自动清除之前的输出。背完规定个数安装选择结构自动重置或者点击“重置”来重置。 2.查单词部分：用全局变量来装载词库，利用标志变量来判断是否找到对应单词，将找到的单词输出或者输出提示信息。加入一行命令，在每一次输出后再次查找时自动清除之前输出的内容。通过“重置”按钮调用重置命令从头开始装载词库、搜索。 4.4创新 1.通过标志变量的引入与选择结构的应用来实现错误操作时输出提示信息防止错误操作，提高了软件的健壮性。 2.在每次进行新输入时自动清除之前内容，一轮背诵进行完成后自动重置参数，不需要点击“重置”，节约了时间，避免的反复选择，带来了便捷。 3.在一轮背诵进行完成后，通过在词义栏输出提示信息提示使用者查看正确率与完成时间，节约了空间也节约了运行内存，不用再次定义新的函数。 4.在答错时，在“正确”栏输出正确答案，保证使用者能更好地进行记忆。 5．词库外部导入，可以实时更新，也可以引入新的词库，这大大提高了软件应用的广泛性，可以根据使用需要灵活选择。 4.5使用的技巧 全局变量、标志变量、选择结构的结合，实现错误输入的辨别与提示、自动重置的实现。利用time模块来实现计时。利用random模块随机选择词汇。 4.6知识的综合运用 全局变量、标志变量、选择结构、tkinter模块、random模块、time模块、tkinter.messagebox的showinfo弹窗模块、xlrd模块（外部导入）、excel文件的调用、函数的调用、控件位置大小等属性的设置、列表推导式、循环结构。 5.软件使用说明 5.1背单词 点击四个按钮之一，选择背诵词汇的类型 在背诵个数后面输入背单词的个数，点击确定（不输入默认背十个） 点击新单词开始背诵，点击检验查看是否正确 4.正确输出√，错误输出×并输出正确答案，点击重置重新开始 5.检验后再检验，或者未检验直接点击下一个，会输出错误的提示信息 6.背完后会提示背完，点击检验可以查看正确率和时间 7.点击“新单词”即可自动重置，不改变词库与单词数进行下一轮 5.2查单词 点击四个按钮之一选择查询词库 输入单词点击查找，出现词义 清除之前的内容再次点击搜索，即可在当前词库搜索 点击其他词库即可在其他词库搜索本单词 点击重置，所有内容清空重新开始查询 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245import tkinter as tk #生成窗口import xlrd #读取excel文件import randomimport timefrom tkinter.messagebox import showinfo #弹窗window = tk.Tk()window.title('背单词') #设置标题、长宽window.geometry('500x700')# ————————以下是窗口的内容————————l1 = tk.Label(window, text='请选择单词类型', # 标签的文字 bg='blue', # 背景颜色 font=('Arial', 12), # 字体和字体大小 width=15, height=2) # 标签长宽l1.place(x=20,y=30) # 固定窗口位置#以下为全局变量的定义与初始化n=10 #背诵单词数(默认为10个)num=0 #背过的单词数cor=wro=0 #正确/错误的单词数_new_=1 #判断是否应该按键的标志变量_test_=0 #同上 def load(file_name): #装载单词与意思 data = xlrd.open_workbook(file_name) #读取excel文件 table = data.sheet_by_name('Sheet1') #读取工作表 words=table.col(0, start_rowx=0, end_rowx=None) #读取一列 words=[x.value for x in words] #将其变为纯字符串列表 meaning=table.col(1, start_rowx=0, end_rowx=None) meaning=[x.value for x in meaning] #同上 global wordlist wordlist=[[a,b] for a,b in zip(words,meaning)] #生成以\"由词+义构成的列表\"为元素的列表 t1.delete('1.0','end') #清除之前的内容 t1.insert('insert',file_name[0:4]) #显示当前背诵单词的类别 def newword(): #开始背下一个单词 global word global _test_ global _new_ global num global time_start global time_end if num==0: #判断是否应该开始计时 t4.delete('1.0','end') time_start=time.time() #记录开始时间 if num&lt;n: #判断是否应该继续背 num&lt;n就继续背 if _new_==1: word=random.choice(wordlist) #随机取一个单词 t2.delete('1.0','end') t5.delete('1.0','end') t6.delete('1.0','end') e.delete(0,'end') t2.insert('insert',word[1]) #把单词显示在文本框内 _new_=0 _test_=1 else: showinfo(title='提示', message='请输入答案并检验')#不应当执行当前操作提示 else: t2.delete('1.0','end') t5.delete('1.0','end') t6.delete('1.0','end') t2.insert('insert','恭喜你背完了！点击检验查看正确率与时间')#结束提示 e.delete(0,'end') time_end=time.time() #记录结束时间 _new_=0 _test_=1 def test(): #输入单词 global _new_ global _test_ global num global cor global wro global time_end if num&lt;n : if _test_==1: var=e.get() #读取输入的单词 if var==word[0]: t5.insert('insert','√') #如果答对，显示√，否则显示×，并显示正确答案 cor+=1 else: t6.insert('insert','×') s=str(word[0]) t5.insert('1.0',s) wro+=1 num+=1 _new_=1 _test_=0 else: showinfo(title='提示', message='请点击新单词进行测试')#不应当执行当前操作提示 else: t2.delete('1.0','end') t5.delete('1.0','end') t6.delete('1.0','end') t5.insert('insert',str(cor)) #输出正确与错误的个数 t6.insert('insert',str(wro)) t2.insert('insert','请点击新单词开始下一轮背诵') #提示开始下一轮背诵 t4.insert('insert',str(time_end-time_start)[0:6]+'秒') #输出用时 _new_=1 _test_=0 num=cor=wro=0 #参数重置def reset(): #重置所有内容，恢复默认 global wordlist global num global cor global wro global _new_ global _test_ global n t1.delete('1.0','end') t2.delete('1.0','end') t4.delete('1.0','end') t5.delete('1.0','end') t6.delete('1.0','end') t8.delete('1.0','end') e.delete(0,'end') e2.delete(0,'end') e3.delete(0,'end') wordlist=[] num=cor=wro=0 _new_=1 _test_=0 n=10def search(): #搜索相关单词 key=e3.get() t8.delete('1.0','end') #清除之前输出的内容 flag=0 #标志变量 for x in wordlist: if x[0]==key: t8.insert('1.0',x[1]) #查到输出 flag=1 if flag==1: pass else: t8.insert('1.0','该字典没有相关释义，请更换字典') #未查到输出提示信息def defnum(): #设置背诵单词数（默认为10个） global n n=int(e2.get())def CET_4(): #点击相应的按钮更换当前背诵单词类别 file_name='四级词汇.xls' load(file_name)def CET_6(): file_name='六级词汇.xls' load(file_name)def IELTS(): file_name='雅思词汇.xlsx' load(file_name)def TOEFL(): file_name='托福词汇.xlsx' load(file_name)t1=tk.Text(window,font=('Arial', 12),width=8,height=1) #显示当前单词类别t1.place(x=200,y=40)b1 = tk.Button(window, #四级单词按钮 text='四级词汇', # 显示在按钮上的文字 font=('Arial', 12), # 字符格式 width=10, height=2, # 按钮宽高 command=CET_4) # 点击按钮式执行的命令b1.place(x=50,y=100) # 按钮位置b2 = tk.Button(window,text='六级词汇',font=('Arial', 12),width=10, height=2,command=CET_6) #六级单词按钮 b2.place(x=150,y=100) b3 = tk.Button(window,text='雅思词汇',font=('Arial', 12),width=10, height=2,command=IELTS) #雅思单词按钮b3.place(x=250,y=100) b4 = tk.Button(window,text='托福词汇',font=('Arial', 12),width=10, height=2,command=TOEFL) #托福单词按钮b4.place(x=350,y=100) l2=tk.Label(window,text='词义：',font=('Arial', 12),width=6,height=2) #词义提示标签l2.place(x=40,y=200)t2=tk.Text(window,font=('Arial', 12),width=35,height=3) #显示词义t2.place(x=100,y=195)l3=tk.Label(window,text='单词：',font=('Arial', 12),width=6,height=2) #单词输入提示标签l3.place(x=40,y=300)e=tk.Entry(window,font=('Arial', 12),width=20) #单词输入文本框e.place(x=100,y=310)b5=tk.Button(window,text='检验',font=('Arial', 12),width=5,height=1,command=test) #检验按钮b5.place(x=300,y=305)b6=tk.Button(window,text='新单词',font=('Arial', 12),width=5,height=1,command=newword) #新单词按钮b6.place(x=380,y=305)l4=tk.Label(window,text='用时：',font=('Arial', 12),width=6,height=2) #用时提示标签l4.place(x=40,y=500)t4=tk.Text(window,font=('Arial', 12),width=15,height=1) #用时输出文本框t4.place(x=100,y=510)l5=tk.Label(window,text='正确：',font=('Arial', 12),width=6,height=2)#正确提示标签l5.place(x=40,y=400)t5=tk.Text(window,font=('Arial', 12),width=15,height=1) #正确输出文本框t5.place(x=100,y=410)l6=tk.Label(window,text='错误：',font=('Arial', 12),width=6,height=2)#错误提示标签l6.place(x=250,y=400)t6=tk.Text(window,font=('Arial', 12),width=10,height=1) #错误输出文本框t6.place(x=310,y=410)b7=tk.Button(window,text='重置',font=('Arial', 12),width=5,height=1,command=reset)#重置按钮b7.place(x=300,y=505)l7=tk.Label(window,text='背诵个数：',font=('Arial', 12),width=8,height=2)#背诵个数提示标签l7.place(x=320,y=30)e2=tk.Entry(window,font=('Arial', 12),width=2) #背诵个数输入文本框e2.place(x=400,y=40)b8=tk.Button(window,text='确定',font=('Arial', 12),width=3,height=1,command=defnum)#（背诵个数输入）确定按钮b8.place(x=430,y=35)b9=tk.Button(window,text='搜索',font=('Arial', 12),width=3,height=1,command=search)#搜索按钮b9.place(x=40,y=600)e3=tk.Entry(window,font=('Arial', 12),width=15) #搜索输入文本框e3.place(x=100,y=610)l8=tk.Label(window,text='意思：',font=('Arial', 12),width=5,height=2) #（搜索中）单词意思提示标签l8.place(x=260,y=550)t8=tk.Text(window,font=('Arial', 12),width=18,height=3) #（搜索）单词意思输出文本框t8.place(x=260,y=590)#———————以上是窗口的内容—————————window.mainloop()","tags":[{"name":"选修课","slug":"选修课","permalink":"https://renzehua1998.github.io/tags/%E9%80%89%E4%BF%AE%E8%AF%BE/"},{"name":"Python","slug":"Python","permalink":"https://renzehua1998.github.io/tags/Python/"}]},{"title":"哈工大人工智能暑期学校作业","date":"2019-06-05T10:50:00.000Z","path":"2019/06/05/哈工大人工智能暑期学校作业/","text":"大二下暑假哈工大人工智能暑期学校《高性能机器学习》课程结课作业 Report on Paper “Adaptive Deep Reuse: Accelerating CNN Training on the Fly” 参考文章链接 1.Summary of the paper (1)Main problems &amp; motivation This paper raises a method called “Adaptive Deep Reuse” in CNN training mainly to avoid the unnecessary calculation. As the experimental results show, in real operation of CNN training, there are many similarities among the images. The repetition of the same calculation will significantly cost lots of time and resources. If we can reuse the same calculation results, we will save a huge amount of unnecessary calculation and improve the time of CNN training. The mainly point is how to efficiently find the similar items. But there are also other points we should concern. We know that CNN training includes two kinds of propagations: forward and backward, they have some different method in training period. And as most people concerned, the accuracy of the result is also needed to be noticed in the training period. In addition, the new method must be suitable to most of the conditions we might face in real training. So how to find the same or similar neural vectors; whether the method of adaptive deep reuse useful in the backward propagation; how to reduce the errors and save time in this new training method; and how to make this method useful in different conditions of Convolution Neural Networks is the main questions this paper tries to solve. (2)Method the authors used i.How to find the same or similar neural vectors As above, we notice that there are many similarities among the images and the neural vectors. The most direct method we can think of is clustering. But the paper doesn’t use the commonest clustering method: k-means. We use another clustering method called: LSH(Locality-Sensitive Hashing). We define a parameter called “remain ratio”, which uses the number of the remain group to divide the original number of the neural vectors. This parameter describes the clustering level. Then we use a function which contains a random vector (v) to measure the input (x), if v·x&gt;0, the result is 1, else the result is 0. We use several random vectors to form a gather of vector, when we calculate the v·x one-by-one, we will be able to get a bit vector called “ID”, just as the ID number of the neuron vector. If two of the vectors’ “ID” are same, we call them in a same cluster. From this method, we can find the similar neural vectors. The range of clustering can of course be different. We use three range of clustering to suit different situations: single-input level, single-batch level and across-batch level. ii.Whether the method of adaptive deep reuse useful in the backward propagation As we know, the backward propagation takes 2/3 of the whole training period. It is important to prove that the method we developed in part 1 is suitable for the backward propagation. If the answer is yes, we can use this method in both of two propagations and save a huge amount of calculations. There is a very simple rule we have learned before, which is called “chain rule”. That is, in a direct way, a method to determine the derivative of complex function. We have this kind of function during the forward propagation: y=x·W+b, when we do the backward propagation, we must solve two results: Weight Gradient (the weight’s partial respect to the loss function) and the input’s partial respect to the loss function. By using the chain rule, we can get the results we want, so we prove that the new method is useful in the backward propagation. iii.How to reduce the errors and save time in this new training method There is a common rule in natural word: we can’t have our cake and eat it. Reducing errors and saving time are two part that we cannot achieve the best at the same time. As the paper writes, although the time complexity of this new method can achieve a pretty low level, the accuracy also get lower. So we should make a decision on whether reduce the calculations or increase the accuracy of the new method. If we have a better equipment to do this training, the computation overhead might not be concerned, then we can achieve both of the two goals. So while training, based on our hardware, we can make a trade-off between accuracy and the computation overhead. iv.How to make this method useful in different conditions of CNN The paper comes up with two strategies to make this method suitable for different models of CNN. For the first one, we try to make sure that at beginning, the length (L) of the sub-vector is as large as possible, and the number of hashing functions (H) is as small as possible. But still make sure that the errors is acceptable. While in the end, let L be the as large as we can and H be as small as we can. In this way, we can save many unnecessary calculations at the beginning, and get the much accurate result in the end. There must be some rules set to make sure that the “L” and “H” are suitable during the training. And when to change them is also a important thing we should considered. We choose the exact time that when the loss function get it’s lowest point to change the parameters of “L” and “H”. The paper also set some limitations to guarantee that it makes shorter time cost and more accurate result. The second strategy is simpler than the first one. We use the parameter “CR” to express if we choose reuse or not. When CR=1, it shows that we use reuse, and when it comes to 0, it shows we don’t use it. During the training period, “L” and “H” do not change any more. We choose the suitable value of L and H, and set CR=1 at first. When the loss function achieves its lowest point, we let CR=0 and train it again. (3)The experimental settings From the paper, the authors choose three different networks called: CifarNet, AlexNet and VGG-19. Their ranges of layers and the datasets they used are different. Firstly, we test the similarity of the neural vectors, the result shows that all of them have a huge number of similarities, so we can use the deep reuse method to simplify the training period. We also find that the smaller the clustering granularity is, the more similarities we might find among the vectors, while it will cost more calculation overhead. To study each parameters’ influence on the results we use control variable method. The paper finds that when the remain ratio (rc) and H don’t change, the smaller the L is, the higher accuracy the result get. When L do not change, the larger the H is, the higher accuracy the result get and rc get larger, but it will also cause more calculations. And CR=1 (reuse the neural vectors) cost less calculations than CR=0, while the accuracy get shorter. The strategies we use as above may get different conditions. We test three strategies, the first strategy is that we don’t change the parameters of “L” and ”H”, the second strategy is that we change L and H to adapt the training period, the third strategy is the second one in (2) iv. The result is that the second one can get more time saving than the third one, and the first one is less than the other strategies. (4)A brief summary of the findings of the work Through this paper, the authors come up with a new method called adaptive deep reuse. This new method can significantly save the similar calculation through finding the similar neural vectors. They use LSH to find the similar vectors and reuse the same calculation results. They also prove that this method can also be used in the backward propagation. Then they optimize the strategy of choosing the parameters. Then they design several experiments to prove that this new method can significantly speed up the CNN training period. 2.Advantages of the method/system compared to other alternative methods This paper come up with a new method to optimize the structure of CNN. In the past research, people always focus on the weight redundancy, and try to reduce the calculation in the convolutional layers. While this paper tries to reduce the calculation at a much earlier time: the input layer (the input picture or the activation map). By using this, we can reduce a huge amount of calculations at a very early time. Some research use rounding to reduce the calculation[1], although this method won’t reduce the accuracy of the final classification result, this method will cause unpredictable mistakes during training, which is uncontrollable. If we have to make a more accurate result, this method will not be suitable. This paper reuse the similar items in the input layer, can control the errors by define the parameter of “L”, ”H” and ”CR”. It gives us a pretty controllable way to limit the errors according to our demand. Another research also uses hashing[2] like this paper. They using hashing in the convolutional layers, that is also effective, but compared to this paper, the method doesn’t save the repetitive calculations at the very beginning, which will also cause time waste. The other study focus on reduce the superfluous weight, it is useful to save time because there are plenty of unnecessary weight among the neural networks, if we can remove them, the speed of training will of course raises. But this method had a shortcoming: the backward propagation (BP) is very complexed, and we should develop some extra strategies to solve this problem. [3] In this paper, we prove that this method can also be used in the BP problems. So we will save many energy by not focus on the extra strategies in solving the BP problems. Many researches use the sparsity of the layers to reduce the unnecessary calculations, but this method require a very sparse activation map. When it becomes complexed these methods will not be able to simplify the training period. So the method this paper uses is more general than those methods in this aspect. 3.The limitations of the method/system There are four main method to solve this problem[4]: Network pruning and thinning, Tensor decomposition, knowledge transfer and Fine module design. We know that there are many redundant parameters in convolutional layers and fully connected layers. The adaptive deep reuse method cannot remove these redundant parameters, it can just simplify the similar calculations at a very early stage. But it doesn’t come up with a method to solve pruning. In this method, we have to make a trade-off between accuracy and the computation overhead. The more accurate results we make, the more computational expense we should pay. We can’t reduce the calculation and reduce the errors at the same time. It is the limitation caused by the neural network itself. This paper only focuses on reducing the calculation of each iteration, don’t pay attention to reduce the iterations number. It’s true that in reuse we can only reduce the calculation in only one iteration. This is the limitation of the method itself. Only if the input layer must have many similarities that this method can be more effective. If the input become complexed, in another word, don’t have many similar parts, the adaptive deep reuse will not be able to take advantages than other methods. 4.Possible improvements We can see that the adaptive deep reuse can save much computational expense, but it still has limitations. The first limitation is that it cannot remove the redundant parameters. We can add some extra strategies to it when the training comes to the convolutional layers and fully connected layers. This method can make the simplify of the training further. The author mentions another method: enforcing a low-rank structure on the layers. This method is different from the method in this paper. Maybe we can combine two of them to make a better one. The clash between accuracy and the computation overhead limits our training on the neural network. We can select the parameters more rational so that both of them can achieve an ideal level. But the clash still exists, the only thing we can do is making it smaller. We don’t focus on reducing the iterations number of the network. Maybe next time we can add some other method like large-batch data parallelism, importance sampling, etc. For many conditions the inputs have a huge amount of similarities, so we don’t have to worry about the limitation of the inputs. But when we really face with this situation, we can use some other method to treat this picture, then pick out the main information in it. REFERENCES [1] S. Gupta, A. Agrawal, K. Gopalakrishnan, and P. Narayanan, “Deeplearning with limited numerical precision,” inInternational Conferenceon Machine Learning, 2015, pp. 1737–1746. [2] [6] R. Spring and A. Shrivastava, “Scalable and sustainable deep learningvia randomized hashing,” inProceedings of the 23rd ACM SIGKDDInternational Conference on Knowledge Discovery and Data Mining.ACM, 2017, pp. 445–454. [3] S. V. Kamarthi and S. Pittner, “Accelerating neural network trainingusing weight extrapolations,”Neural networks, vol. 12, no. 9, pp. 1285–1299, 1999. [4] LIN Jing-Dong, WU Xin-Yi, CHAI Yi, YIN Hong-Peng. Structure Optimization of Convolutional NeuralNetworks: A Survey.Acta Automatica Sinica, 2019,XX(X): X−X","tags":[{"name":"选修课","slug":"选修课","permalink":"https://renzehua1998.github.io/tags/%E9%80%89%E4%BF%AE%E8%AF%BE/"},{"name":"神经网络","slug":"神经网络","permalink":"https://renzehua1998.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"概率统计上机题","date":"2019-06-05T10:50:00.000Z","path":"2019/06/05/概率统计上机/","text":"大二下概率统计上机实验报告（大作业） 概率统计上机实验题 第一题 一、 对二项分布事件概率的精确计算与用泊松分布和中心极限定理的近似计算进行对比。 （a） p变化，n固定，进行比较。（b）n变化,p固定，进行比较。 123456789101112131415161718192021222324252627282930313233clearn=100;x=1:n;y=1:0.1:n;p=0.2;p1=binopdf(x,n,p);plot(x,p1,'r-','LineWidth',2)%画二项分布的精确分布曲线hold onlambta=n*p;for i=1:n %求泊松分布的近似概率分布 p2(i)=lambta^i*exp(-lambta)/factorial(i);endplot(x,p2,'b-','LineWidth',2)%画泊松分布的近似分布曲线hold onp3=normpdf(y,lambta,sqrt(lambta)*(1-p));plot(y,p3,'g-','LineWidth',2)%画正态分布的近似分布曲线title('n=100,p=0.2时三种情况下的概率曲线') （a） Ps：标准是红色（最细）、泊松是蓝色（最粗）、正态是绿色（中等粗细） 小结：从运行结果来看，在n较大时，p对于两种近似计算的精度影响都比较大，p越大，二者的近似精度都减小（图四），p比较小（约为0.1-0.2左右）时有比较好的近似效果（图一）。从中可以看出小概率二项分布在n比较大时用泊松分布和二项分布都可以较好地近似代替。当p增大而n不变时，对于两种近似计算都会产生较大的误差。 （b） Ps：标准是红色（最细）、泊松是蓝色（最粗）、正态是绿色（中等粗细） 小结：从运行结果可以看出，当p取比较小的值（0.2）时，随着n的增长，两种近似分布对于精确分布的近似效果都变好了。在n比较小（np&lt;5）时，正态分布对于二项分布的近似效果没有泊松分布好，只有当n充分大时，正态分布对于二项分布的近似效果才能更加精确。从中我们也能看出，在做近似时，n越大近似效果越好，在np&lt;5时，用泊松分布近似二项分布比用正态分布近似效果好。 第二题 二、 对正态总体参数的区间估计，进行验证及区间长度的变化情况（注：对一个参数，验证一种情形即可）。 （a） 样本容量固定，置信度变化；（b）置信度固定，样本容量变化。 样本容量固定为8，α=0.05或0.1 源程序：α=0.05 123x=[5.08,4.97,5.12,5.05,4.95,4.9,5.0,5.01];[mu,sigma,muci,sigmaci]=normfit(x,0.05) 运行结果： mu = 5.0100 sigma = 0.0717 muci = 4.9500 5.0700 sigmaci = 0.0474 0.1460 其置信度为95%的置信区间为（4.9500，5.0700） 源程序：α=0.1 123x=[5.08,4.97,5.12,5.05,4.95,4.9,5.0,5.01];[mu,sigma,muci,sigmaci]=normfit(x,0.1) 运行结果： mu = 5.0100 sigma = 0.0717 muci = 4.9620 5.0580 sigmaci = 0.0506 0.1289 其置信度为90%的置信区间为 （4.9620， 5.0580） 样本数为8时 置信度 置信区间 置信区间长度 α=0.1 （4.9620，5.0580） 0.0960 α=0.05 （4.9500，5.0700） 0.1200 b.样本数变为9，α=0.05 123x=[5.08,4.97,5.12,5.05,4.95,4.9,5.0,5.01,5.01];[mu,sigma,muci,sigmaci]=normfit(x,0.05) mu = 5.0100 sigma = 0.0671 muci = 4.9584 5.0616 sigmaci = 0.0453 0.1285 置信度为95%的置信区间变短为（4.9584，5.0616） 置信度α=0.05时 样本数 置信区间 置信区间长度 8 （4.9500，5.0700） 0.1200 9 （4.9584，5.0616） 0.1032 小结： 选取了一组样本的观测值，本体假设参数服从正态总体N(5,0.7)，当样本容量固定，置信度越大，它的置信区间就越小，同样，当置信度固定，样本容量越大它的置信区间会越小。这也符合数理统计中的知识点，置信度和置信区间不能同时优化，而我们所获取的信息越多，我们就越能肯定置信区间。 第三题 三、 自己选一个总体，验证样本k阶矩的观察值随样本容量的增大与总体k阶矩接近程度。 （对k=1,2进行验证） 源程序： 123456789101112131415161718192021m = 1; % 分布的均值v = 2; % 分布的方差mu = log((m^2)/sqrt(v+m^2)); % 公式中的均值参数sigma = sqrt(log(v/(m^2)+1)); % 公式中的方差参数 [M,V]= lognstat(mu,sigma); % 可以验证随机数的均值与方差的正确性 X = lognrnd(mu,sigma,1,1e6); % 产生随机数n=length(X)y=sum(X.^1)/nhist(log(X), 100) % 画出随机数的对数正态分布函数图 运行结果： （a） 选择正态总体，k=1时，一阶矩为1 n = ​ 10000 y = 0.9855 n = 100000 y = 0.9955 n = 1000000 y = 1.0007 n 10000 100000 1000000 y 0.9855 0.9955 1.0007 绝对差值 0.0145 0.0045 -0.0007 （b） K=2 正态总体的二阶矩为3 n = ​ 10000 y = 3.0321 n = 100000 y = 2.9656 n = 1000000 y = 3.0244 n = 10000000 y = 3.0202 n = 100000000 y = 2.9986 n 10000 100000 1000000 10000000 100000000 y 3.0321 2.9656 3.0244 3.0202 2.9986 绝对差值 0.0321 0.0344 0.0244 0.0202 0.0014 小结： 实验中选择了随机数产生正态分布而产生样本，随着样本数量增多，图像越来越符合正态分布，而且样本k阶矩的观察值随样本容量的增大与总体k阶矩接来越接近。 第四题 四、 自己设计一种情形，当样本至少为多少时，产品的合格率才能符合给定的合格率。 合格率服从N（0.96，9），对其进行假设检验，n从0开始增加，在α&lt;=0.05时记录n的值。循环1000次取均值。进行多次运行发现数值稳定在20~21附近。 源程序： 123456789101112131415161718192021for i=1:1000n=1;sig=0;while sig&lt;0.95 x=normrnd(0.96,3,1,n); [h,sig,ci]=ztest(x,0.96,3,0.05,0); n=n+1;endm(i)=n;endmean(m) 运行结果： ans = 21.3680 ans = 21.4210 ans = 20.2820 ans = 20.0780 ans = 20.9050 ans = 21.5140 序号 1 2 3 4 5 6 均值 结果 21.3680 21.4210 20.2820 20.0780 20.9050 21.5140 20.9280 小结：本题假设合格率服从N（0.96，9），按此分布生成n个随机数，对其进行假设检验，n从0开始增加，在α&lt;=0.05时记录n的值。循环1000次取均值。进行多次运行发现数值稳定在20~21附近。一共运行了六次，结果如上表，其平均值为20.9280。所以在假设前提下，样本至少为21时合格率才能在α&lt;0.05的前提下达到要求。 第五题 五、 产生卡方分布的随机数，并在一个坐标图中画出该卡方分布的统计直方图与真实卡方分布图形。 源程序： 12345678910111213141516171819n=100000;k=5;for i=1:nx(i)=chi2rnd(k);end %生成服从以k为自由度卡方分布的n个随机数向量xhist(x,0:3:60) %画x的频数分布直方图hold ony=0:0.1:60;px=chi2pdf(y,k);plot(y,px*3*n,'r-') %画以k为自由度的卡方分布概率密度曲线title('n=5') 运行结果： 小结： 本题首先了确定了采样点数与卡方分布的“n”值（即程序中的k)，按照自由度为k的卡方分布、利用循环生成了n个随机数。接下来，画出频数直方图。然后，画出自由度为k的卡方分布的概率密度曲线。对k从1～30取了4个离散值，得出四个不同图样。分析可得，k值越小，样本的中心值越小；k值越大，样本的中心值越大。同时，k值越大，频数直方图与概率密度曲线的拟合度越高；k值越小，拟合度越低。 感想与体会： 本学期的概率统计与随机过程课程马上就要结束了，也是时候借着这样的一个机会来总结一下我一个学期学习的心得体会。 在刚开始接触概率论部分时，它给我的感觉就像是高中学的概率部分的内容，利用排列组合或者几何概型来计算概率。包括事件的独立性、随机事件等等看似朴实的概念，却是概率论这门课的基石。贝叶斯公式是我接触的第一个公式，在查阅资料后我发现，它在工程、经济等等各行各业都有着重要的用处。其实，概率统计在我们平时的学习中有许多的体现，在系统地学习了这门课以后，我对于事物的看法也有了变化。大一时大学物理实验中做数据处理，方差要除以（n-1）当时感觉很奇怪，因为这与高中学的除以n不同，查阅资料也没有得出什么结果。在学习了概率统计以后我知道了因为这些数据都是样本随机变量的观测值，而样本的方差做这样的定义是为了让它的期望刚好等于总体的方差，即总体的方差是它的无偏估计量。而在电路、模电实验当中示波器中波形有时会产生噪声，学了概率统计以后知道了看似没有规律的噪声信号也是符合某种规律的，只有掌握了其内在的分布规律才能想办法把它去除 。 看似很好理解的概率统计概念其实是有理论支撑的，中学时只有一个模糊的概念，就是频率的极限是概率，但是却没有想一想这是为什么，只是认为它是真理罢了。在大数定律的学习中，我才发现，看似简简单单的道理，其背后都是有严格的证明的，人类现如今的成就，建立在这些看似简简单单的“真理”上，而这些理论背后是无数科学家的努力。在假设检验与参数估计章节，我接触了许许多多的工程与生活实际，利用概率统计的知识可以用了估计未知的随机变量的参数、估计其分布区间；也可以来检验某种说法是否正确，这也是把纯理论应用到了实际生活中。任何学科都有其应用的范围，而向概率统计这种基础学科更是应用在了方方面面。 随机过程是一门全新的学科，随机过程的理论产生于本世纪初期，是应物理学、生物学、管理科学等方面的需要而逐步发展起来的。目前，在自动控制、公用事业、管理科学等方面都有广泛的应用。由此看来，随机过程与我的专业关系密切。在刚接触这个学科的时候发现，虽然它应用了概率统计的知识，是在概率统计的基础上发展起来的，但它也有自己完整的一套理论。在实际应用中会用到极深的数学功底，动辄多重积分也是一个难点，不过在计算机发展至今的现在，许多复杂的计算不需要人来进行，所以说这在一定方面来说也促进了随机过程的发展。在学习时也应该作为重点而不是一带而过，正如老师所说的，许多在以后非常重要的知识，在刚开始学习的时候可能仅仅提了一下，而作为自动控制专业的学生，学好随机过程是非常重要的。 在之前接触到的许多文学、科普作品中，概率论给我的感觉，就像是宇宙最神秘的宝藏。因为在量子力学还没有发展的过去，决定论盛行，甚至还有“拉普拉斯妖”的假说。但是人们后来发现，完完全全精确地预言未来是做不到的。未来仅仅是一连串的概率，我们能做的，就是尽可能地增大自己希望发生的事情的概率。人类是渺小的，却也是强大的。渺小到无法完完全全掌握哪怕一个原子的精确参数，强大到能够用概率论去改变世界，去预测未来。 有一个微信公众号叫做“概率论”，其实是一个文艺号。但是仔细想想，我们的生活何尝不是由概率组成，茫茫人海中人和人的相遇也是一次观测下的小概率事件啊。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"matlab","slug":"matlab","permalink":"https://renzehua1998.github.io/tags/matlab/"}]},{"title":"偏振光的观察与研究","date":"2018-12-07T14:48:00.000Z","path":"2018/12/07/大物仿真实验报告/","text":"大二上大物实验下仿真报告存档 一、实验简介 光的偏振是指光的振动方向不变，或电矢量末端在垂直于传播方向的平面上的轨迹呈椭圆或圆的现象.光的偏振最早是牛顿在1704～1706年间引入光学的；光的偏振这一术语是马吕斯在1809年首先提出的，并在实验室发现了光的偏振现象;麦克斯韦在1865~1873年间建立了光的电磁理论,从本质上说明了光的偏振现象 .按电磁波理论,光是横波，它的振动方向和光的传播方向垂直.自然光是各方向的振幅相同的光，对自然光而言，它的振动方向在垂直于光的传播方向的平面内可取所有可能的方向，没有一个方向占有优势.若把所有方向的光振动都分解到相互垂直的两个方向上，则在这两个方向上的振动能量和振幅都相等.线偏振光是在垂直于传播方向的平面内，光矢量只沿一个固定方向振动. 部分偏振光可以看作自然光和线偏振光混合而成，即它有某个方向的振幅占优势。圆偏振光和椭圆偏振光是光矢量末端在垂直于传播方向的平面上的轨迹呈圆或椭圆。起偏器是将非偏振光变成线偏振光的器件；检偏器是用于鉴别光的偏振光状态的器件. 利用光的偏振现象在物理学方面可测量材料的厚度和折射率，可以了解材料的微观结构。利用偏振光的干涉现象在力学上检测材料压力分布，应用于建筑工程学方面可以检测桥梁和水坝的安全度。 二、实验原理 1．偏振光的概念和产生： 2. 改变偏振态的方法和器件： 常见的起偏或检偏的元件构成有两种： 1.光学棱镜：如尼科耳棱镜、格兰棱镜等，它是利用光学双折射的原理制成的； 2.偏振片：它是利用聚乙烯醇塑胶膜制成，它具有梳状长链形结构分子，这些分子平行排列在同一方向上，此时胶膜只允许垂直于排列方向的光振动通过，因而产生线偏振光. 马吕斯定律：马吕斯在1809年发现，完全线偏振光通过检偏器后的光强可表示为I1 = I0 cos2α，其中的a是检偏器的偏振方向和入射线偏振光的光矢量振动方向的夹角： 3．波晶片：又称位相延迟片，是从单轴晶体中切割下来的平行平面板，由于波晶片内的速度vo ,ve 不同，所以造成o光和e光通过波晶片的光程也不同.当两光束通过波晶片后o光的位相相对于e光多延迟了Δ=2π(n0-n1)d/λ，若满足(ne-no)d=±λ/4，即Δ=±π/2我们称之为λ/4片，若满足(ne-no)d=±λ/2，即Δ=±π，我们称之为λ/2片，若满足(ne-no)d=±λ，即Δ=2π我们称之为全波片。 3．借助检偏器和λ/4波晶片检验光的5种偏振态： 只用检偏器（转动）： 对于线偏光可以出现极大和消光现象。 对于椭圆偏光和部分偏光可以出现极大和极小现象。 对于圆偏光和非偏光各方向光强不变。 用λ/4波晶片和检偏器（转动） ： 对于非偏光（自然光）各方向光强不变。 对于圆偏光出现消光现象（原因）。 对于部分偏光仍出现极大和极小现象。 对于椭圆偏光，当把λ/4波晶片的快慢轴放在光强极大位置时出现消光现象（原因）。 检验偏振光的光路 三、实验仪器 偏振光观察与研究的实验装置包括一下几个部分： 光源（可发出多种类型激光） 偏振片 波晶片（λ/2和λ/4波长） 光屏 光源： 双击实验桌上光源小图标弹出光源的调节窗体。单击调节窗体的光源开关可以切换光源开关状态；可以选择光源发出光的类型，包括自然光、椭圆偏振光、圆偏振光、线偏振光、部分偏振光。光源默认发出是自然光。 ​ (光源的实物照片) （实验中的光源） 偏振片： 双击桌面上偏振片小图标，弹出偏振片的调节窗体。初始化时偏振片的旋转角度是随机的，用户使用时需要手动去校准。最大旋转范围为360°，最小刻度为1°。可以通过点击调节窗体中旋钮来逆时针或顺时针旋转偏振片。：表示顺时针旋转；：表示逆时针旋转。旋转的最小刻度单位为1°。当鼠标按住选择不放，则偏振片则会不停的旋转，直到鼠标松开。 ​ （偏振片的实物照片） （实验中的偏振片） （实验中放大的偏振片读数盘） 波晶片： 分为λ/2λ和λ/4波长波晶片，双击桌面上波晶片小图标，弹出波晶片的调节窗体。初始化时波晶片的旋转角度是随机的，用户使用时需要手动去校准。最大旋转范围为360°，最小刻度为1°。可以通过点击调节窗体中旋钮来逆时针或顺时针旋转偏振片。：表示顺时针旋转；：表示逆时针旋转。旋转的最小刻度单位为1°。当鼠标按住选择不放，则偏振片则会不停的旋转，直到鼠标松开。 ​ （波晶片的实物照片） （实验中的波晶片） （实验中放大的波晶片读数盘） 光屏： 双击实验桌上光屏小图标弹出光屏的调节窗体。可以显示光圈，此光圈会根据光源、偏振片已经波晶片之间关系自动调节亮度。并且可以读出当前光强值(最大值为100)。 （光屏的实物照片） （实验中的光屏） （实验中光屏的正面图） 四、实验内容 1. 研究λ/4波片对偏振光的影响： 本实验所用仪器有：光源、偏振片(2个)、λ/4波片、光屏等。 ​ 光路图 （1）按光路图使偏振片A和B 的偏振轴正交(消光)。然后插入一片λ/4波片C(实际实验中要使光线尽量穿过元件的中心)。 （2）以光线为轴先转动C使消光，然后使B转过360°观察现象。 （3）再将C从消光位置转过15、30、45、60、75、90°，每次都将B转过360，观察实验现象。 2. 研究λ/2波片对偏振光的影响： 本实验所用仪器有：光源、偏振片(2个)、λ/2波片、光屏等。 ​ 光路图 1：使偏振片A和B的偏振轴正交(消光)，并在B和A之间再插入一个λ/2波片C。 2：以光线为轴先转动将λ/2波片C转动任意角度破坏消光现象，再将B转动360°，观察消光现象。 五、实验过程与数据处理 1. 研究λ/4波片对偏振光的影响 数据表格 过程截图 现象描述：波片C转动的角度为90⁰的整数倍时，转动B可以观察到消光现象，其他情况下转动B虽然光强会变化，但是看不到消光。 2. 研究λ/2波片对偏振光的影响： 数据表格 过程截图 现象描述：C波片从消光状态开始转动某一角度θ，调节B的角度θ’，当θ’=2θ时，可以观察到消光现象。 六、实验结论与误差分析 结论： 线偏振光通过λ/4波片后出射的光线取决于波片与振动方向的夹角，夹角为90⁰的整数倍时，出射光仍为偏振光；夹角为45⁰时，出射光为圆偏振光；夹角为其他值时，出射光为椭圆偏振光。 λ/2波片与入射线偏振光振动方向的夹角决定了出射光振动方向转过的角度，出射光转动的角度为二者夹角的二倍。 误差分析： 对于仿真实验，可以最小程度的减小误差，从而达到理想状态。 七、思考题 1.为什么自然光通过任何波片后，透射光仍为自然光？ 答：因为自然光沿各个方向振动相等，其相位差完全随机，将其附加一个相位差后，仍为随机的，所以透射光仍为自然光。 2.如何利用一个光源区分偏振片、λ/4波片、λ/2波片 答：用线偏振光源，转动光学仪器，发生消光的是偏振片，利用偏振片研究，光线透过波片再经过偏振片，如果转动波片会有没有消光的情况的就是λ/4波片，总是有消光的就是λ/2波片（需要适当转动波片）。","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}]},{"title":"数据结构实验4——无向图最短路径搜索","date":"2018-12-01T08:32:00.000Z","path":"2018/12/01/数据结构实验4/","text":"大二上数据结构实验1内容，使用C语言实现无向图最短路径搜索 一、实验题目和要求 实验题目：无向图最短路径搜索 （一）实验目的：掌握 Dijkstra 算法的原理。 （二）基本要求：熟练掌握图的操作。 （三）内容提要： 1）下图为校内知名建筑物示意平面图（其中“传送门”用于增加网络复杂度），以边表示建筑物间的路径，各条路径上方的数字表示路径长度。 2）针对该图进行构建数据结构和算法，通过键盘输入任意两建筑物的名称，可查询建筑物间的最短路径长度，并输出最短路径。 注：1）用无向网表示校园内的各建筑的平面图，将平面图看作一张带权无向图，为此图选择适当的数据结构。 2）Dijkstra 算法是典型的单源最短路径算法，用于计算节点间的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。本次实验采用此算法求图中两点间的最短路径。 【输入样例】 北门 南门 【输出样例】 74 北门-&gt;传送门3-&gt;腾飞塔-&gt;图书馆-&gt;传送门2-&gt;南门 二、按不同功能分析各程序模块 (一)包含库函数、定义常量、变量类型 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define FALSE 0#define TRUE 1#define ERROR 0#define OK 1#define OVERFLOW -1#define MAX_CHAR_LEN 20#define INFINITY 1000 //最大值#define MAX_VERTEX_NUM 13//最大顶点个数 (二)图的存储结构定义 123456789typedef enum {DG,DN,UNG,UDN} GraphKind;typedef int ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];typedef struct{ char * vex[MAX_VERTEX_NUM];//顶点向量 AdjMatrix arcs; //邻接矩阵 int vexnum,arcnum; //当前顶点数，弧数 GraphKind kind; //图的种类}MGraph; (三)迪杰斯特拉算法求最短路径 1234567891011121314151617181920212223242526272829303132333435void ShortestPath_DIJ(MGraph G,int v0, int vm,int P[MAX_VERTEX_NUM][MAX_VERTEX_NUM],int D[]){ int v,w,min,i,j; int Final[MAX_VERTEX_NUM]; for(v=0;v&lt;G.vexnum;++v) { Final[v]=FALSE;D[v]=G.arcs[v0][v]; for(w=0;w&lt;G.vexnum;++w) P[v][w]=FALSE; if(D[v]&lt;INFINITY){P[v][v0]=TRUE;P[v][v]=TRUE;} } D[v0]=0;Final[v0]=TRUE; //for(i=1;i&lt;G.vexnum;++i) while(Final[vm]==0) { min=INFINITY; for(w=0;w&lt;G.vexnum;++w) { if(!Final[w]) if(D[w]&lt;min){v=w;min=D[w];} } Final[v]=TRUE; for(w=0;w&lt;G.vexnum;++w) { if(!Final[w]&amp;&amp;(min+G.arcs[v][w]&lt;D[w])) { D[w]=min+G.arcs[v][w]; for(j=0;j&lt;G.vexnum;++j) { P[w][j]=P[v][j]; }//P[w]=P[v]; P[w][w]=TRUE; } } }} (四)主函数（输入查找的起点终点，输出最短路径） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int main(){ char x1[MAX_CHAR_LEN],x2[MAX_CHAR_LEN]; scanf(\"%s %s\",x1,x2); MGraph G; G.vex[0]=\"北门\"; G.vex[1]=\"饮水思源\"; G.vex[2]=\"腾飞塔\"; G.vex[3]=\"图书馆\"; G.vex[4]=\"教学主楼\"; G.vex[5]=\"活动中心\"; G.vex[6]=\"南门\"; G.vex[7]=\"西迁馆\"; G.vex[8]=\"传送门2\"; G.vex[9]=\"传送门3\"; G.vex[10]=\"传送门1\";G.vex[11]=\"传送门4\";G.vex[12]=\"宪梓堂\"; G.vexnum=MAX_VERTEX_NUM; int i,j; for(i=0;i&lt;MAX_VERTEX_NUM;i++) for(j=0;j&lt;MAX_VERTEX_NUM;j++) G.arcs[i][j]=INFINITY; G.arcs[0][1]=18;G.arcs[1][2]=19;G.arcs[2][3]=23;G.arcs[3][4]=15;G.arcs[4][5]=21;G.arcs[5][6]=30; G.arcs[6][8]=21;G.arcs[3][8]=4;G.arcs[7][8]=43;G.arcs[6][7]=20;G.arcs[6][12]=14;G.arcs[4][12]=8; G.arcs[11][12]=4;G.arcs[3][10]=4;G.arcs[1][10]=27;G.arcs[0][9]=22;G.arcs[2][9]=4;G.arcs[2][11]=32; for(i=0;i&lt;MAX_VERTEX_NUM;i++) for(j=i+1;j&lt;MAX_VERTEX_NUM;j++) if(G.arcs[i][j]!=INFINITY) G.arcs[j][i]=G.arcs[i][j]; int v0,vm; for(v0=0;v0&lt;MAX_VERTEX_NUM;v0++) if(strcmp(G.vex[v0],x1)==0) break; for(vm=0;vm&lt;MAX_VERTEX_NUM;vm++) if(strcmp(G.vex[vm],x2)==0) break; int D[MAX_VERTEX_NUM]; for(i=0;i&lt;MAX_VERTEX_NUM;i++) D[i]=INFINITY; int P[13][13]; ShortestPath_DIJ(G,v0,vm,P,D); printf(\"%d\\n\",D[vm]); char *p; int m; m=v0; printf(\"%s-&gt;\",G.vex[m]); P[vm][m]=0; while(m!=vm) { for(i=0;i&lt;13;i++) if(G.arcs[m][i]!=INFINITY&amp;&amp;P[vm][i]==TRUE) { printf(\"%s\",G.vex[i]); if(i!=vm) printf(\"-&gt;\");break; } m=i;P[vm][i]=FALSE; } return 0;} 三、思路分析 用邻接矩阵存储图的边信息 输入起点终点，判断它们的编号，传入求路线的函数中 用dijkstra算法求从起点到任意一点的最短路径——一种优化方法，只求到所输入的终点为止——一次循环得出一个节点的最短路径，更新最短路径长度数组（确定为最短的节点对应final数组为true），并更新记录经过节点的矩阵 输出终点对应的路径长度，用循环依次筛选对应路径（该节点与当前位置相邻且对应于经过节点矩阵那行的对应位置为true），输出路径上的节点。循环完一次后当前位置进1，且把经过的路径对应矩阵中元素置为false（防止回溯） 四、运行结果分析 题目要求用例： 自己测试的用例： 根据画图分析，运行结果正确。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"https://renzehua1998.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构实验3——树的遍历操作及基于霍夫曼树的编码/译码","date":"2018-11-28T15:29:00.000Z","path":"2018/11/28/数据结构实验3/","text":"大二上数据结构实验1内容，使用C语言实现树的遍历操作及基于霍夫曼树的编码/译码 一、实验题目和要求 实验题目：树的遍历操作及基于霍夫曼树的编码/译码 （一）实验目的：掌握结构体、指针及二叉树的生成、遍历等操作，掌握霍夫曼编码/译码的原理。 （二）基本要求：熟练掌握树的操作。 （三）内容提要： 1）通过键盘输入一段字符(长度&gt;=20)，构建霍夫曼树； 2）根据该树求每个字符的编码，并对该段字符串进行编码； 3）将得到的编码进行译码； 4）基于该霍夫曼树，实现非递归的先序遍历算法，输出该树所有的节点、节点的权值、节点的度和节点所在的层数； 5）基于该霍夫曼树，实现基于队列的层序遍历算法，输出该树所有的节点、节点的权值、节点的度和节点所在的层数。 注：在实现时要求霍夫曼树的左右孩子的大小关系满足，左孩子节点权值小于右孩子节点权值。 二、按不同功能分析各程序模块 (一)包含库函数、定义常量、变量类型 1234567#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#define MAXSTRLEN 256//输入字符串的最大长度#define STACK_INIT_SIZE 100//栈的储存空间初始分配量#define STACKINCREMENT 10//栈的存储空间分配增量 (二)构建哈夫曼树、栈、队列的结构、操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495typedef struct HTNode//哈夫曼树{ unsigned int weight; unsigned int parent, lchild,rchild; struct HTNode *Parent,*Lchild,*Rchild; unsigned int degree; unsigned int depth;}HTNode,*HuffmanTree;typedef char **HuffmanCode;//哈夫曼编码表typedef struct//栈{ HuffmanTree *base; HuffmanTree *top; int stacksize;}SqStack;int InitStack(SqStack&amp;S)//构造空栈{ S.base=(HuffmanTree*)malloc(STACK_INIT_SIZE*sizeof(HuffmanTree)); if(!S.base)exit(-1); S.top=S.base; S.stacksize=STACK_INIT_SIZE; return 1;}int GetTop(SqStack S,HuffmanTree&amp;e)//读取栈顶元素{ if(S.top==S.base)return 0; e = *(S.top-1); return 1;}int Push(SqStack&amp;S,HuffmanTree e)//进栈{ if(S.top-S.base&gt;=S.stacksize) { S.base=(HuffmanTree*)realloc(S.base,(S.stacksize+STACKINCREMENT)*sizeof(HuffmanTree)); if(!S.base)exit(-1); S.top=S.base+S.stacksize; S.stacksize+=STACKINCREMENT; } *S.top++=e; return 1;}int Pop(SqStack&amp;S,HuffmanTree &amp;e)//出栈{ if(S.top==S.base)return 0; e=*--S.top; return 1;}int StackEmpty(SqStack S)//判断为空栈{ if(S.top==S.base) return 1; else return 0;}typedef struct QNode//队列{ HuffmanTree data; struct QNode *next;}QNode,*QueuePtr;typedef struct//队列头尾指针{ QueuePtr Front; QueuePtr Rear;}LinkQueue;int InitQueue(LinkQueue &amp;Q)//构造空队列{ Q.Front=Q.Rear=(QueuePtr)malloc(sizeof(QNode)); if(!Q.Front) exit(-1); Q.Front-&gt;next=NULL; return 1;}int EnQueue(LinkQueue &amp;Q,HuffmanTree e)//入队{ QueuePtr p; p=(QueuePtr)malloc(sizeof(QNode)); if(!p) exit(-1); p-&gt;data=e;p-&gt;next=NULL; Q.Rear-&gt;next=p; Q.Rear=p; return 1;}int DeQueue(LinkQueue &amp;Q,HuffmanTree &amp;e)//出队{ QueuePtr p; if(Q.Front==Q.Rear)return 1; p=Q.Front-&gt;next; e=p-&gt;data; Q.Front-&gt;next=p-&gt;next; if(Q.Rear==p)Q.Rear=Q.Front; free(p); return 1;}int QueueEmpty(LinkQueue Q)//判断队列是否为空{ if(Q.Front==Q.Rear) return 1; else return 0;} (三)构建哈夫曼树、求编码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void Select(HuffmanTree HT,int n,int *s1,int *s2)//选择两个最小结点{ int i; int min1,min2; int S1,S2; min1=INT_MAX; min2=INT_MAX; for(i=1;i&lt;=n;i++) if(HT[i].parent==0){ if(HT[i].weight&lt;=min1){ min1=HT[i].weight; S1=i; } } for(i=1;i&lt;=n;i++) if(HT[i].parent==0&amp;&amp;i!=S1){ if(HT[i].weight&lt;=min2){ min2=HT[i].weight; S2=i; } } if(min2&lt;=min1){ int temp; temp=S1; S1=S2; S2=temp; } *s1=S1; *s2=S2;}void HuffmanCoding(HuffmanTree &amp;HT,HuffmanCode &amp;HC,int *w,int n)//构建哈夫曼树，求哈夫曼编码{ if(n&lt;=1) return; int m; m=2*n-1; HT=(HuffmanTree)malloc((m+1)*sizeof(HTNode)); HuffmanTree p; int i; int s1,s2; for(p=HT+1,i=1;i&lt;=n;++i,++p,++w) { *p={*w,0,0,0,NULL,NULL,NULL,0,0}; } for(;i&lt;=m;++i,++p) { *p={0,0,0,0,NULL,NULL,NULL,0,0}; } for(i=n+1;i&lt;=m;++i) { Select(HT,i-1,&amp;s1,&amp;s2); HT[s1].parent=i; HT[s2].parent=i; HT[i].lchild=s1; HT[i].rchild=s2; HT[i].weight=HT[s1].weight+HT[s2].weight; HT[s1].Parent=&amp;HT[i]; HT[s2].Parent=&amp;HT[i]; HT[i].Lchild=&amp;HT[s1]; HT[i].Rchild=&amp;HT[s2]; }//构建霍夫曼树 HC=(HuffmanCode)malloc((n+1)*sizeof(char*)); char cd[n]; cd[n-1]='\\0'; int start,c,f; for(i=1;i&lt;=n;++i) { start=n-1; for(c=i,f=HT[i].parent;f!=0;c=f,f=HT[f].parent) { if(HT[f].lchild==c) { cd[--start]='0'; } else cd[--start]='1'; } HC[i]=(char*)malloc((n-start)*sizeof(char)); strcpy(HC[i],&amp;cd[start]); }//求哈夫曼编码} (四)编码、解码 123456789101112131415161718192021222324252627282930int getcode(HuffmanCode &amp;code,char* str,HuffmanCode HC,char* word)//编码{ int i,j; printf(\"\\n编得的码为：\"); for(i=0;str[i]!='\\0';i++) { j=0; while(str[i]!=word[j]) j++; //printf(\"%s\",HC[j+1]); code[i]=HC[j+1]; printf(\"%s\",code[i]); } code[i]=NULL; return 1;}int encode(HuffmanCode code,HuffmanCode HC,char* word)//解码{ int i,j; printf(\"\\n解得的码为：\"); for(i=0;code[i]!=NULL;i++) { j=1; while(strcmp(code[i],HC[j])) j++; //printf(\"%d\",j); printf(\"%c\",word[j-1]); } return 1;} (五)两种遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293void Depth(HuffmanTree T)//求哈夫曼树节点的深度（所在层数）{ int i=1; HuffmanTree p; p=T; while(p-&gt;Parent!=NULL) { p=p-&gt;Parent;i++; } T-&gt;depth=i;}void Degree(HuffmanTree T)//求哈夫曼树节点的度{ if(T-&gt;lchild&amp;&amp;T-&gt;rchild) T-&gt;degree=2; else if(!T-&gt;lchild&amp;&amp;!T-&gt;rchild) T-&gt;degree=0; else T-&gt;degree=1;}void Visit(HuffmanTree p,HuffmanCode HC,char *word,int n)//输出该节点、节点的权值、节点的度和节点所在的层数。{ Depth(p); Degree(p); int i,start; HuffmanTree f,c; char a; char *b; if(p-&gt;degree==0) { b=(char*)malloc((n*sizeof(char))); b[n-1]='\\0'; start=n-1; for(c=p,f=p-&gt;Parent;f!=NULL;c=f,f=f-&gt;Parent) { if(f-&gt;Lchild==c) b[--start]='0'; else b[--start]='1'; } i=1; while(strcmp(HC[i],&amp;b[start])){i++;} //printf(\"%d \",i); a=word[i-1]; printf(\"\"); printf(\"存的是字符%c \",a); } else printf(\"存的不是字符 \"); printf(\"权值：%d 度：%d 层数：%d\\n\",p-&gt;weight,p-&gt;degree,p-&gt;depth);}int PreTraverse(HuffmanTree HT,HuffmanCode HC,int n,char *word)//先序遍历{ int m; m=2*n-1; HuffmanTree p; p=HT; SqStack s; InitStack(s); Push(s,p); while(!StackEmpty(s)) { Pop(s,p); Visit(p,HC,word,n); if(p-&gt;Rchild) Push(s,p-&gt;Rchild); if(p-&gt;Lchild) Push(s,p-&gt;Lchild); } return 1;}int LevelTraverse(HuffmanTree HT,HuffmanCode HC,int n,char *word)//层序遍历{ int m; m=2*n-1; HuffmanTree p; LinkQueue Q; InitQueue(Q); p=HT; Visit(p,HC,word,n); while(p||!QueueEmpty(Q)) { if(p-&gt;Lchild) { Visit(p-&gt;Lchild,HC,word,n); EnQueue(Q,p-&gt;Lchild); } if(p-&gt;Rchild) { Visit(p-&gt;Rchild,HC,word,n); EnQueue(Q,p-&gt;Rchild); } DeQueue(Q,p); } return 1;} (六)主函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int main(){ HuffmanTree HT; HuffmanCode HC; char str[MAXSTRLEN]; printf(\"请输入一串长度大于20字符\\n\"); gets(str); int num; //不同字符种数 char *word; //所有出现的字符 int *weight; //存放字符权值的数组 int a[128]={0}; int i,j; for( i=0;str[i]!='\\0';i++ ) { if ( str[i] &lt; 127 ) a[str[i]]++; else a[127]++; } for( i=0,num=0;i&lt;128;i++ ) if ( a[i] &gt; 0 ) num++; word=(char*)malloc(num*sizeof(char*)); weight=(int*)malloc(num*sizeof(int*)); for( i=0,j=0;i&lt;128;i++ ) if ( a[i] &gt; 0 ) { word[j]=(char)i; weight[j]=a[i]; j++; } word[j]='\\0'; printf(\"总共的字符种类：%s\",word); printf(\"\\n每个字符出现的次数：\"); for(i=0;i&lt;num;i++) { printf(\"%c：%d \",word[i],weight[i]); } printf(\"\\n\"); HuffmanCoding(HT,HC,weight,num); printf(\"对应的哈夫曼编码为：\"); for(i=1;i&lt;num+1;i++) { printf(\"%c：%s \",word[i-1],HC[i]); } HuffmanCode code; code=(HuffmanCode)malloc((num+1)*sizeof(char*)); getcode(code,str,HC,word); encode(code,HC,word); printf(\"\\n\"); HuffmanTree T; T=&amp;HT[num*2-1]; printf(\"先序遍历结果为：\\n\"); PreTraverse(T,HC,num,word); printf(\"层序遍历结果为：\\n\"); LevelTraverse(T,HC,num,word); printf(\"\\n\"); return 0;} 三、思路分析 在本实验中，使用getchar（）从键盘输入一个字符串，建立一个长度为128的数组（用于对应ASCII码表），用于存储记录每个字符出现的次数，利用循环即可得到，用word数组存储所有出现的字符，并且将其一一对应到存储节点权值的数组weight中 利用子函数HuffmanCoding（）构建哈夫曼树。先将n个节点分别对应到n个字符上，令其权值为字符出现的次数。用select（）函数每次取出权值最小的两个节点，将其权值相加，作为父节点的权值，小的为左子节点，大的为右子节点。求编码时，由叶子节点向上回溯，如果为左子节点，就为0，否则为1。编码为其倒序输出。 将求得的编码和字符一一对应即可得到编码与解码 先序遍历时，先将根节点压栈，当栈非空时，执行循环：弹出p，访问p指针指向的节点，如果p节点左孩子指针非空，将左孩子压栈，如何p节点右孩子指针非空，将右孩子压栈。即可实现非递归的先序遍历。 层序遍历时，先将根节点入队，访问根节点，当队列非空或p指针非空时，执行循环：如果p的左孩子指针非空，将p的左孩子入队，如果p的右孩子指针非空，将p的右孩子入队，将队列尾节点退队。即可实现非递归的层序遍历。 Ps：select函数：用两个循环分别找到权值数组中最小的两个值，用一个判断保证s1&lt;s2。 visit函数：用一个判断保证当节点度数为0是为字符，依据其编码确定是哪个字符；否则不是字符。再输出节点的度数、深度、权值。 四、运行结果分析 随便输入一组字符运行结果如下： 根据画图分析，运行结果正确。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"https://renzehua1998.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"用双光栅测量微弱振动实验综述报告","date":"2018-11-13T23:50:00.000Z","path":"2018/11/14/大物实验报告/","text":"大二上大物实验下报告存档 一、 实验获得幅频曲线图 二、 设计一个利用本仪器测量微小质量变化的实验 (一) 实验原理 激光垂直入射相隔很近的两个光栅M，N．光栅N保持静止状态，光栅M粘贴于一个在与激光传播方向垂直的方向上做受迫微振动的音叉上．假设光栅M在该方向上的运动速度为v，则通过时间t，入射光的相位改变为 其中，d为光栅常数。 即对于分别从两个光栅出射的同一级衍射光，存在一个多普勒频移，大小为 其中，为M光栅出射的第k级衍射光的圆频率；为N光栅出射的第k级衍射光的圆频率；k为衍射级次． 由于光的频率很高，用光电探测器无法测得，必须由衍射光相干叠加形成光拍．最终光电检测器检测到的光电流为 其中，为光电转换常数；，分别为丽束相干光的能量；，分别为两束相干光的初相位． 拍频即为 其中，v为M光栅移动速度；n。为光栅密度，等于100条／mm． 微弱振动的振幅为 其中，T为音叉振动周期；表示时间 内的拍频波的个数． 由上式可知，只要测得拍频波的个数，就可得到微弱振动的振幅． (二) 实验过程 \\1. 音叉附着质量与音叉振幅关系定性研究 调节驱动频率使音叉谐振，将同一质量的铁丝放置于音叉上不同位置的小孔内，从而改变音叉附着质量．通过示波器上显示的拍频波个数计算出相应情况下的音叉振幅，拟合出音叉振幅大小与音叉附着质量位置关系曲线，如图1所示(A为音叉振幅大小，X为铁丝所在位置与音叉固定端的距离)． 讨论：由图1可知，当音叉谐振时，改变音又的附着质量可以很明显地改变音叉的振幅，且附加的铁丝距离音叉固定端越远，音叉附着质量越大，音叉的振幅越小，说明音叉附着质量与音叉振幅存在某种反比关系． \\2. 音叉附着质量与音叉振幅关系定量研究 调节驱动频率使音叉谐振，用 1／10 000天平测量出质量范围在0．03～0．09 g之间的8段不同质量的铁丝，将它们分别放置于音叉上的同一位置(与音叉固定端距离为5．21 cm)，通过示波器上显示的拍频波个数计算出相应情况下的音叉振幅，得到音又振幅大小与铁丝质量(附着质量)大小的拟合曲线如图2所示A为音叉振幅，m为铁丝质量)． 讨论：由图2可以看出(实心黑点所在位置为实验采集数据)，在音叉谐振的状态下，在音叉的同一位置附着不同质量的物体，改变音叉的附着质量，音叉振幅随附着铁丝质量的增大而减小，且附着物体质量 大小和音叉振幅大小近似存在线性关系，此线性函数关系为： 其中，A为音叉振幅，mm；m为微小物体质量，g． 对于质量位于本实验所采用的质量区间内的微小物体，都可以通过双光栅微弱振动实验测量出振幅，再利用上式计算出质量大小．而对于任意双光栅仪器，也可以采用上述的方法，测量微小物体质量大小． ——摘自《利用双光栅开展设计性实验的探讨》易静 中图分类号：TH744 文献标识码A 文章编号：1006．6853(2009)04—0314—03 三、 查阅“光栅尺”，也称莫尔条纹在工业中是如何进行微小量的测量和控制的。 (一) 莫尔条纹 以透射光栅为例，当指示光栅上的线纹和标尺光栅上的线纹之间形成一个小角度θ，并且两个光栅尺刻面相对平行放置时，在光源的照射下，位于几乎垂直的栅纹上，形成明暗相间的条纹。这种条纹称为“莫尔条纹” (右图所示)。严格地说，莫尔条纹排列的方向是与两片光栅线纹夹角的平分线相垂直。莫尔条纹中两条亮纹或两条暗纹之间的距离称为莫尔条纹的宽度，以W表示。 W=ω /2* sin（θ /2）=ω /θ 。 莫尔条纹 (三) 莫尔条纹具有以下特征： (1)莫尔条纹的变化规律 两片光栅相对移过一个栅距，莫尔条纹移过一个条纹距离。由于光的衍射与干涉作用，莫尔条纹的变化规律近似正(余)弦函数，变化周期数与光栅相对位移的栅距数同步。 (2)放大作用 在两光栅栅线夹角较小的情况下，莫尔条纹宽度W和光栅栅距ω、栅线角θ之间有下列关系。式中，θ的单位为rad，W的单位为mm。由于倾角很小，sinθ很小，则 W=ω /θ 若ω =0．01mm，θ=0.01rad，则上式可得W=1，即光栅放大了100倍。 (3)均化误差作用 莫尔条纹是由若干光栅条纹共用形成，例如每毫米100线的光栅，10mm宽度的莫尔条纹就有1000条线纹，这样栅距之间的相邻误差就被平均化了，消除了由于栅距不均匀、断裂等造成的误差。 (四) 检测与数据处理 电子细分与判向法 光栅测量位移的实质是以光栅栅距为一把标准尺子对位称量进行测量。高分辨率的光栅尺一般造价较贵，且制造困难。为了提高系统分辨率，需要对莫尔条纹进行细分，光栅尺传感器系统多采用电子细分方法。当两块光栅以微小倾角重叠时，在与光栅刻线大致垂直的方向上就会产生莫尔条纹，随着光栅的移动，莫尔条纹也随之上下移动。这样就把对光栅栅距的测量转换为对莫尔条纹个数的测量。 在一个莫尔条纹宽度内，按照一定间隔放置4个光电器件就能实现电子细分与判向功能。例如，栅线为50线对/mm的光栅尺，其光栅栅距为0.02mm，若采用四细分后便可得到分辨率为5μm的计数脉冲，这在工业普通测控中已达到了很高精度。由于位移是一个矢量，即要检测其大小，又要检测其方向，因此至少需要两路相位不同的光电信号。为了消除共模干扰、直流分量和偶次谐波，通常采用由低漂移运放构成的差分放大器。由4个光敏器件获得的4路光电信号分别送到2只差分放大器输入端，从差分放大器输出的两路信号其相位差为π/2，为得到判向和计数脉冲，需对这两路信号进行整形，首先把它们整形为占空比为1：1的方波。然后，通过对方波的相位进行判别比较，就可以等到光栅尺的移动方向。通过对方波脉冲进行计数，可以得到光栅尺的位移和速度 四、 查阅利用测量固体金属的固有频率，如何计算出该金属的杨氏模量。 对于长度L≫直径d、两段自由地做微小横振动的均匀细棒，其振动满足方程 ​ +=0 式中，ρ为棒的密度，S为棒的截面积，J=dS称为惯量矩（取决于截面的形状），E为杨氏模量，y为棒振动的位移，x为位置坐标，t为时间变量。 用分离变量法解方程，令y（x，t）=X(t)T(t)代入方程，有 ​ = 解得该振动方程的通解为 y（x，t）=（B1chKx+B2shKx+B3cosKx+B4sinKx）Acos（ωt+φ） 式中 ​ ω = 称为频率公式。频率公式对任意形状的截面、不同边界条件的试样都是成立的。我们只要用特定的边界条件定出常数K，带入特定截面的惯量矩J，就可以得到具体条件下的计算公式。如果悬线悬挂在试样的节点（处在共振状态的棒中，位移恒为零的位置）附近，则棒的两端均处于自由状态。此时其边界条件为自由端横向作用力F和弯矩M均为零，即 ​ F=- =- EJ=0 弯矩 ​ M=EJ=0 故有 |x=0=0 |x=l=0 |x=0=0 |x=l=0 将通解代入边界条件，可以得到cosKl*chKl=1，可用数值解法求得本征值K和棒长l应满足Kl=0，4.730，7.853，10.996，14.137，。。。 一般将K1l=4.730所对应的频率称为基频频率。 试样在做基频振动时，存在两个节点，它们的位置距离端面为0.224l和0.776l处。将第一本征值K1=代入频率表达式，得到自由振动的固有圆频率（基频） ​ ω = 解出杨氏模量 ​ E=7.8870* 对于直径为d的圆形棒，惯量矩 ​ J=dS=S(= 代入上式可得 ​ E=1.6067 式中，l为棒长，d为棒的直径，m为棒的质量，f为试样共振频率。在国际单位制中杨氏模量E的单位为N. 实际上，E还和试样的直径与长度之比d/l的大小有关，所以乘以一个修正因子R，则有 ​ E=1.6067R 当l≫d时，R≈1；当l≫d不成立时，圆棒的R可查表 ​ 试样R与d/l的关系 d/l 0.01 0.02 0.03 0.04 0.05 0.06 R 1.001 1.002 1.005 1.008 1.014 1.019 当外力频率达到共振频率ωr时，另一悬线处会接收到最大振幅，而固有频率与共振频率之间的关系为fr==，为阻尼系数。对于一般的金属材料，β的最大值只有ω的1%左右，所以可用fr代替f计算。 五、 利用本实验仪器，还可以进行哪方面的研究？ 还可以测量力、光、电学方面的微小变化量，监测分析系统中的微小故障，如用来研究航空航天、船舶、兵器军工、冶金、化工、机械制造、电力、供水等行业设备管理工作的故障诊断。 (1)在桥梁安全监测中的应用 目前, 应用光纤光栅传感器最多的领域当数桥梁的安全监测。斜拉桥斜拉索、悬索桥主缆及吊杆和系杆拱桥系杆等是这些桥梁体系的关键受力构件,其他土木工程结构的预应力锚固体系,如结构加固采用的锚索、锚杆也是关键的受力构件。上述受力构件的受力大小及分布变化最直接地反映结构的健康状况,因此对这些构件的受力状况监测及在此基础上的安全分析评估具有重大意义。 (2)在水位遥测中的应用 在光纤光栅技术平台上研制出的高精度光学水位传感器专门用于江河、湖泊以及排污系统水位的测量。传感器的精度可以到达±0.1%F·S。光纤安装在传感器内部，由于光纤纤芯折射率的周期性变化形成了FBG，并反射符合布拉格条件的某一波长的光信号。当FBG与弹性膜片或其它设备连接在一起时，水位的变化会拉伸或压缩FBG。而且，反射波长会随着折射率周期性变化而发生变化。那么，根据反射波长的偏移就可以监测出水位的变化。 六、 普通光栅与相位光栅的区别 普通光栅：由大量等宽等间距的平行狭缝构成的光学器件称为光栅(grating)。一般常用的光栅是在玻璃片上刻出大量平行刻痕制成，刻痕为不透光部分，两刻痕之间的光滑部分可以透光，相当于一狭缝。精制的光栅，在1cm宽度内刻有几千条乃至上万条刻痕。这种利用透射光衍射的光栅称为透射光栅，还有利用两刻痕间的反射光衍射的光栅，如在镀有金属层的表面上刻出许多平行刻痕，两刻痕间的光滑金属面可以反射光，这种光栅称为反射光栅。 相位光栅：所谓的位相材料是指那些只有空间位相结构，而透明度一样的透明材料，如生物切片、油膜、热塑以及声光偏转池等，他们只改变入射光的相位，而不影响其振幅。位相光栅就是用这样的材料制作的光栅。 区别：普通光栅会同时改变入射光的振幅与相位，而相位光栅只改变入射光的相位。","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}]},{"title":"数据结构实验2——串的模式匹配","date":"2018-11-10T06:58:00.000Z","path":"2018/11/10/数据结构实验2/","text":"大二上数据结构实验1内容，使用C语言实现串的模式匹配 一、实验题目和要求 基于串的模式匹配 （一）实验目的： 通过本次实验，熟练掌握抽象数据类型串的实现，学会使用串及其模式匹配算法解决具体应用问题，从而体会串的特点。 （二）基本要求： 1）将HTML文件按字符顺序读入； 2）基于串的模式匹配算法，设计HTML文件中的信息提取方法，识别HTML文件中每条发帖的发信人ID、发帖时间和发帖IP； 3）在屏幕输出识别得到的每条发帖的发信人ID、发帖时间和发帖IP。 （三）内容提要： 1)用KMP算法实现模式匹配; 2)提示：在文件中，每条发帖的发信人ID之前紧邻的字符串均为“发信人:”、之后均为“(”，发帖时间和发帖IP也有类似的规律。 （四）示例 上图为所提供的HTML文件部分区域截图，其中发信人ID为“Dabo”、发帖时间为“Wed Sep 13 13:15:37 2017”、发帖IP为“202.117.62.94”。 二、按不同功能分析各程序模块 (一)包含库函数、定义常量、变量类型 1234567#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;math.h&gt;#include &lt;afxinet.h&gt;#define MAXSTRLEN 10000//主串最大元素个数#define MAXNEXTLEN 15//next数组最大元素个数 (二)数据结构基础定义（串）、next数组定义 123typedef int Status; typedef char SString[MAXSTRLEN];int next[MAXNEXTLEN]; (三)求next数组的子函数 1234567891011void get_next(SString T,int next[]){ int i=1,j=0; next[1]=0; while(i&lt;MAXNEXTLEN) { if(j==0||T[i]==T[j]) {i++;j++;next[i]=j;} else j=next[j]; }} (四)KMP算法的子函数 123456789101112131415int Index_KMP(SString S,SString T,int pos)//利用模式串T的next函数求T在主串S中第pos个字符后的位置的KMP算法//其中，T非空，1&lt;=pos&lt;=Strlength(S){ int i=pos,j=1; int Tnumber=strlen(T)-1;//T数组元素的个数 while(i&lt;=MAXSTRLEN&amp;&amp;j&lt;=Tnumber) { if(j==0||S[i]==T[j]) {++i;++j;} else j=next[j]; } if(j&gt;Tnumber) return i; else return 0;} (五)主函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263int main(){ int pos=1; int i=0; //把文件里面的信息读取到S数组中 SString S; char ch; FILE *fp; int j=0; if((fp=fopen(\"C:\\\\Documents and Settings\\\\Administrator\\\\桌面\\\\rzh\\\\bbs.html\",\"r\"))==NULL) { printf(\"Open the file failure.\\n\"); exit(0); } while(j&lt;MAXSTRLEN) { if((ch=fgetc(fp))!=EOF) { S[j]=ch; } j++; } fclose(fp); S[j]='\\0'; //查找发信人 char D[]={\"发信人:\"}; //将“发信人：”放入D数组 printf(\"发信人ID为:\"); get_next(D,next); //求D的next数组 i=Index_KMP(S,D,pos); //用KMP算法查找位置 while(S[i]!='(') { printf(\"%c\",S[i]); i++; } //输出查找的内容 printf(\"\\n\"); //查找发帖时间 pos=1; char M[]={\"发信站: 兵马俑BBS (\"}; printf(\"发贴时间为:\"); get_next(M,next); i=Index_KMP(S,M,pos); while(S[i]!=')') { printf(\"%c\",S[i]); i++; } printf(\"\\n\"); //查找发帖IP pos=1; char T[]={\"FROM:\"}; printf(\"发贴IP为:\"); get_next(T,next); i=Index_KMP(S,T,pos); while(S[i]!=']') { printf(\"%c\",S[i]); i++; } printf(\"\\n\"); return 0;} 三、运行结果分析 从交大兵马俑bbs上保存了两个网页分别进行了检验，运行结果如下： 都成功地读取了信息。 网页截图：","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"https://renzehua1998.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构实验1——数学表达式求值","date":"2018-11-01T13:58:00.000Z","path":"2018/11/01/数据结构实验1/","text":"大二上数据结构实验1内容，使用C语言实现数学表达式求值 一、实验题目和要求 数学表达式求值 （一） 实验目的：熟练掌握栈、队列等基本操作及其在实际问题中的应用。 （二）基本要求：实现栈的基本操作，及表达式求值的实现。 （三）内容提要：用户需要输入一个表达式。 （四）实现： ​ 1、实现栈的push、pop基本操作； 2、检测表达式的输入是否是正确的数学表达式； 3、对于正确的数学表达式求取其值。 注：1）数学表达式的判读与求值需支持加减乘除、小括号、中括号、大括号、幂运算。 2）不正确的表达式可能包括：字母、非运算符号、括号不匹配，运算符的排列不符合表达式形式等多种情况。 3）表达式通过.txt文件读取而获得。 二、按不同功能分析各程序模块 (一)包含库函数、定义常量、变量类型 12345678910111213#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;math.h&gt;#include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;fstream&gt; #include&lt;cassert&gt;#define true 1 #define false 0 #define OPSETSIZE 12 using namespace std; typedef int Status; (二)定义运算符优先级表 12345678910111213141516unsigned char Prior[12][12] ={ // 运算符优先级表 // '+' '-' '*' '/' '(' ')' '#' '^' '[' ']' '{' '}' /*'+'*/'&gt;','&gt;','&lt;','&lt;','&lt;','&gt;','&gt;','&lt;','&lt;','&gt;','&lt;','&gt;', /*'-'*/'&gt;','&gt;','&lt;','&lt;','&lt;','&gt;','&gt;','&lt;','&lt;','&gt;','&lt;','&gt;', /*'*'*/'&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;','&lt;','&lt;','&gt;','&lt;','&gt;', /*'/'*/'&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;','&lt;','&lt;','&gt;','&lt;','&gt;', /*'('*/'&lt;','&lt;','&lt;','&lt;','&lt;','=',' ','&lt;',' ',' ',' ',' ', /*')'*/'&gt;','&gt;','&gt;','&gt;',' ','&gt;','&gt;','&gt;',' ','&gt;',' ','&gt;', /*'#'*/'&lt;','&lt;','&lt;','&lt;','&lt;',' ','=','&lt;','&lt;','&lt;','&lt;','&lt;', /*'^'*/'&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;','&gt;','&lt;','&gt;','&lt;','&gt;', /*'['*/'&lt;','&lt;','&lt;','&lt;','&lt;',' ',' ','&lt;',' ','=',' ',' ', /*']'*/'&gt;','&gt;','&gt;','&gt;',' ',' ','&gt;','&gt;',' ',' ',' ','&gt;', /*'{'*/'&lt;','&lt;','&lt;','&lt;','&lt;',' ',' ','&lt;','&lt;',' ','&lt;','=', /*'}'*/'&gt;','&gt;','&gt;','&gt;',' ',' ','&gt;','&gt;',' ',' ',' ','&lt;'}; (三)数据结构基础定义（栈的存储结构定义） 1234567891011121314151617181920212223242526272829303132333435363738394041424344//-------------数据结构基础定义------------typedef struct StackSymbol{ char c; struct StackSymbol *next; }SC; //运算符的节点 typedef struct StackData{ float f; struct StackData *next; }SF; //数字的节点 SC *Push(SC *s,char c) //运算符节点入栈{ SC *p=(SC*)malloc(sizeof(SC)); p-&gt;c=c; p-&gt;next=s; return p; } SF *Push(SF *s,float f) //数字节点入栈{ SF *p=(SF*)malloc(sizeof(SF)); p-&gt;f=f; p-&gt;next=s; return p; } SC *Pop(SC *s) //运算符节点出栈{ SC *q=s; s=s-&gt;next; free(q); return s; } SF *Pop(SF *s) //数字节点出栈{ SF *q=s; s=s-&gt;next; free(q); return s; } (四)子函数定义 （包括两两运算操作、判断字符是否为运算符、判断运算符的优先级、计算表达式） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//------------子函数定义--------------//两两运算操作float Operate(float a,unsigned char theta, float b) { switch(theta) { case '+': return a+b; case '-': return a-b; case '*': return a*b; case '/': return a/b; case '^': return pow(a,b); default : return 0; } }char OPSET[OPSETSIZE]={'+','-','*','/','(',')','#','^','[',']','{','}'}; //运算符数组//判断字符是否为运算符Status In(char Test,char *TestOp){ int Find=false; for (int i=0; i&lt; OPSETSIZE; i++) { if(Test == TestOp[i]) Find= true; } return Find; } //判断字符是哪个运算符Status ReturnOpOrd(char op,char *TestOp){ for(int i=0; i&lt; OPSETSIZE; i++) { if (op == TestOp[i]) return i; }}//判断运算符的优先级a,b分别为两个运算符char precede(char a, char b){ return Prior[ReturnOpOrd(a,OPSET)][ReturnOpOrd(b,OPSET)]; } //计算表达式的函数float Calculate(char* Expression){ // 设OPTR和OPND分别为运算符栈和运算数栈，OP为运算符集合 SC *OPTR=NULL; // 运算符栈，字符元素 SF *OPND=NULL; // 运算数栈，实数元素 char TempData[20]; float Data,a,b; char theta,*c,Dr[]={'#','\\0'}; OPTR=Push(OPTR,'#'); c=strcat(Expression,Dr); //将一个字符串连接到另一个字符串的尾部 strcpy(TempData,\"\\0\");//字符串复制函数 while (*c!= '#' || OPTR-&gt;c!='#')//字符串的两端用#隔开作为一个整体 { if (!In(*c, OPSET)) { Dr[0]=*c; strcat(TempData,Dr); //字符串连接函数 c++; if (In(*c, OPSET)) { Data=atof(TempData); //字符串转换函数(double) OPND=Push(OPND, Data); strcpy(TempData,\"\\0\"); } } else // 不是运算符则进栈 { switch (precede(OPTR-&gt;c, *c)) { case '&lt;': // 栈顶元素优先级低 OPTR=Push(OPTR, *c); c++; break; case '=': // 脱括号并接收下一字符 OPTR=Pop(OPTR); c++; break; case '&gt;': // 退栈并将运算结果入栈 theta=OPTR-&gt;c;OPTR=Pop(OPTR); b=OPND-&gt;f;OPND=Pop(OPND); a=OPND-&gt;f;OPND=Pop(OPND); OPND=Push(OPND, Operate(a, theta, b)); break; default:printf(\"error! \\n\"); return 1; } //switch } } //while return OPND-&gt;f; } //Calculate (五)主函数 包括从txt文件输入表达式、调用计算函数求值、输出 12345678910111213141516171819202122int main(void) { char s[128]; char s1[100] = {0}; int len = 0; FILE *fp = fopen(\"E://math.txt\", \"r\");//用txt文件输入数学表达式 if(NULL == fp) { printf(\"failed to open dos.txt\\n\"); return 1; } while(!feof(fp)) { memset(s, 0, sizeof(s)); fgets(s, sizeof(s) - 1, fp); // 包含了换行符 //printf(\"%s\", s); } fclose(fp); puts(\"该表达式的值为:\"); printf(\"%s\\b=%g\\n\",s,Calculate(s)); system(\"pause\"); return 0;} 三、运行结果分析 (一)基础用例 全部通过 (二)拓展用例 表达式错误 虽然检测到了表达式错误，但是还是运算出了结果，在检测到表达式有问题时，没有跳出返回，而是继续执行，所以出现了错误。 表达式错误 通过 异常 通过 通过 表达式错误 未通过，在定义运算符优先级时，未能考虑到中括号的嵌套问题，导致没有检测出错误，运算出了结果。 通过 通过","tags":[{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"https://renzehua1998.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C语言程序设计大作业——学籍管理系统","date":"2018-06-17T10:30:00.000Z","path":"2018/06/17/C语言程序设计大作业/","text":"大一下C语言程序设计大作业，好像是上网找的，非原创 1.程序设计与分析 要求程序能实现以下基本功能： （1）.提供基本的菜单选项，能根据不同的选项执行不同操作； （2）.对学生信息进行录入，修改，删除、查询等操作； （3）.对学生信息进行统计、排序等操作。 （4）.采用数据类型：整型，浮点型，字符型，指针类型，结构体类型 （5）.核心算法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277#define MAX 10//MAX代表学籍管理系统所能处理的最大学生数量，宏定义后，依据实际情况对程序的对应修改更易进行//实际代码中是将子函数的定义写在了main函数的前面，但此处为了程序结构清晰将main函数写在了前面，因此main函数中没有子函数声明的语句int main(){进行各种类型的变量定义以及初始化，以供后续程序使用定义一个结构体类型，并定义一个该类型的结构体变量用于存储将要录入的学生信息数据：struct Student{char Id[MAX];//学号char name[50];//姓名int clas;//班级float score[4];//三科成绩以及总成绩} student[MAX];定义若干指针变量用于将main函数中的变量地址传递给各子函数，使子函数能够改变main函数中的变量的值定义各种所需变量定义整型变量mingling定义一个变量num来记录总人数的变化并将其初始化为零for(;;){输出主菜单选项输入数字命令并赋值给整型变量mingling判断若mingling=1，执行函数input进行学生信息输入操作若mingling=2，执行函数del进行学生信息删除操作若mingling=3，执行函数selet进行学生信息选择输出操作若mingling=4，执行函数order进行学生信息整体排序操作若mingling=5，执行函数output进行学生信息全体输出操作若mingling=6，执行break语句跳出for循环}return 0；}void input(通过指针引用学生信息、当前学生总人数等数据)//我的源代码中每个子函数都是用了许多指针将结构体中的元素一一引用，此处可以改为利用指向结构体变量的指针，代码会简洁许多{利用指针来引用主函数中的学生信息变量定义整型变量i用作循环定义字符数组panduan[10]用作判断整个学生数据的录入操作是否结束for(i=0;;i++){输出\"Id \"输入学号输出\"class \"输入班级输出\"name \"输入姓名输出\"score1 \"输入成绩1输出\"score2 \"输入成绩2输出\"score3 \"输入成绩3将存储总成绩数据的变量赋值为成绩1，成绩2，成绩3的和利用指针使main函数中记录学生人数的变量num自增1输出\"continue?\"输入命令并赋值给字符数组panduan判断字符串panduan与\"no\"是否相等若相等则执行break语句跳出循环}}void del(通过指针引用学生信息、当前学生总人数等数据){定义字符数组panduan[10]用于在已有学生信息中查找需要删除的对应学生信息定义整型变量h用于判断是否找到了所需删除的学生信息定义字符数组jueding[10]用于判断用户的删除操作是否全部结束定义整型变量i用于进行循环查找所需删除的学生//以下使用num的语句均指通过指针引用main函数中的num变量，为了书写简便，省略了指针引用的过程for(;;){h=0;输入所需删除学生的信息关键字（姓名或学号）for(i=0;i&lt;=num-1;i++){判断字符数组panduan中记录的关键字与第i+1个学生的姓名是否相同若相同{则判断当前的学生信息总数是否为1若为1，则执行break语句跳出循环若不为1，则将第i+1个学生的所有信息依次与后一个学生的所有信息交换，直到将该学生信息交换至所有学生信息的最后一个记录处按序输出num-1个学生的信息利用指针使main函数中记录当前学生总数的变量num自减1h=h+1;}若不相同{判断字符数组panduan中记录的关键字与第i+1个学生的学号是否相同若相同 { 则判断当前的学生信息总数是否为1 若为1，则执行break语句跳出循环 若不为1，则将第i+1个学生的所有信息依次与后一个学生的所有信息交换，直到将该学生信息交换至所有学生信息的最后一个记录处 按序输出num-1个学生的信息 利用指针使main函数中记录当前学生总数的变量num自减1 h=h+1; }若不相同，不执行任何语句}}判断h是否不等于0若不等于0{则输出\"continue?\"输入命令并将命令赋值给字符数组jueding判断字符串jueding与\"no\"是否相等若相等则执行break语句跳出循环}若等于0{则按序输出num个学生的所有信息执行break语句跳出循环}}}void selet(通过指针引用学生信息、当前学生总人数等数据){char panduan1[10],jueding[10];int panduan2,m;//panduan1用于存储输入的关键字，panduan2用于存储输入的关键字转换成对应整型数的数值，jueding用于判断整个选择过程是否结束，m用于判断是否找到了所需查找的学生for(;;){m=0;输入查找关键字并将其赋值给字符数组panduan1将panduan1中的数字字符转换为对应的整型数并将数值赋值给panduan2在当前学生中循环查找学号与panduan1中数字字符串相同的学生，若找到则输出该学生所有信息，并使m++每次循环判断时若当前接受判断的学生学号与panduan1中数字字符串不相同，则继续判断其班级与panduan2存储的数值是否相等，若相等则输出该学生，并使m++循环查找结束后，判断m是否等于0，若为0，则输出\"there is no eligible student\"并执行break语句跳出循环若不为0，则输出\"continue?\"输入命令并将命令字符赋给jueding[10]判断字符串jueding是否与\"no\"相等，若相等则执行break语句跳出循环}}void order(通过指针引用学生信息、当前学生总人数等数据){对当前存在的所有学生信息按照班级从小到大，同一班级内总成绩从大到小进行冒泡排序，排序结束后按序输出所有学生信息}void output(通过指针引用学生信息、当前学生总人数等数据){将当前存在的所有学生信息按数组顺序循环输出} 2.程序设计中存在的问题和解决思路 （1）.由于为了在进行删除操作时比较方便进行输入数据的识别，我把学号和姓名都存储在字符数组中，结果在编写选择函数时由于要求输入班级或学号，而班级是存储在定义为整型的变量中的，因此出现了编写困难。 ​ 解决方法：预处理时包含了头文件stdlib.h，在编写选择函数时调用了atoi()函数，将存储学号信息的字符数组中的数字字符转换为对应的整型数，并将其存储在一个新的整型变量中，以供后续程序判断使用。 （2）.这一版学籍管理系统的学生数据交换方式还可以改进，如果定义一个struct Student jiaohuan的结构体变量用来交换学生数据会简便许多 另外程序中指针的使用也不够熟练，只是起到了在主函数与子函数之间传递地址的作用，没有体现指针简化数据处理的作用，定义了太多指针去指向结构体中的各个元素，若定义为指向结构体变量的指针会好很多 （3）.学籍管理系统的代码和算法优化仍在进行中，这一版不会是最后一版。。。 3.实验收获 ​ 对于程序的设计有了更加清晰的认识，对各种命令和数据类型的使用更加熟练，对于一个完整的学籍管理系统的设计有了清晰的思路。 对指针的运用更加熟练，对指针的作用有了更清晰的认识。（虽然代码中指针的运用比较肤浅，但是程序做完之后的思考和对有关知识的重温使我对指针有了更深的了解） 实际上为了用到所学的全部知识，这一版学籍管理系统用了很多不必要的算法，程序反而复杂了，但相对的因为使用到了这学期的几乎所有知识，所以对知识的掌握也上升了一个层次。 发现实现一定功能的程序其算法的多样性，不同的算法有不同的优点，使用的数据结构也有很大不同。 在编写程序的过程中对本学期的知识进行了系统的整理，巩固了所学的知识，为以后的继续学习打下了一个很好的基础。 4.程序的源代码清单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include \"stdio.h\"#include \"string.h\"#include \"stdlib.h\"#define MAX 10void input(int *ban[MAX],char *ming[MAX],char *hao[MAX],float *fen[MAX][4],int *renshu){int i;char panduan[10];for(i=*renshu;i&lt;MAX;i++){ printf(\"Id \"); scanf(\"%s\",hao[i]); printf(\"class \"); scanf(\"%d\",ban[i]); printf(\"name \"); scanf(\"%s\",ming[i]); printf(\"score1 \"); scanf(\"%f\",fen[i][0]); printf(\"score2 \"); scanf(\"%f\",fen[i][1]); printf(\"score3 \"); scanf(\"%f\",fen[i][2]); *fen[i][3]=*fen[i][0]+*fen[i][1]+*fen[i][2]; printf(\"continue?\\n\"); scanf(\"%s\",panduan); *renshu=*renshu+1; if(strcmp(panduan,\"no\")==0) break;}}void del(int *ban[MAX],char *ming[MAX],char *hao[MAX],float *fen[MAX][4],int *renshu){ int i,q,m,h; float f; char panduan[10],c[10],jueding[10]; for(;;) { h=0; scanf(\"%s\",panduan); for(i=0;i&lt;=*renshu-1;i++) { if(strcmp(ming[i],panduan)==0) { if(*renshu==1) break; for(;i&lt;=*renshu-2;i++) { q=*ban[i];*ban[i]=*ban[i+1];*ban[i+1]=q; strcpy(c,hao[i]);strcpy(hao[i],hao[i+1]);strcpy(hao[i+1],c); strcpy(c,ming[i]);strcpy(ming[i],ming[i+1]);strcpy(ming[i+1],c); for(m=0;m&lt;=3;m++) { f=*fen[i][m];*fen[i][m]=*fen[i+1][m];*fen[i+1][m]=f; } } for(m=0;m&lt;=*renshu-2;m++) { printf(\"%s,%d,%s,%4.1f,%4.1f,%4.1f,%5.1f\\n\",hao[m],*ban[m],ming[m],*fen[m][0],*fen[m][1],*fen[m][2],*fen[m][3]); } *renshu=*renshu-1; h=h+1; } else if(strcmp(hao[i],panduan)==0) { if(*renshu==1) break; for(;i&lt;=*renshu-2;i++) { q=*ban[i];*ban[i]=*ban[i+1];*ban[i+1]=q; strcpy(c,hao[i]);strcpy(hao[i],hao[i+1]);strcpy(hao[i+1],c); strcpy(c,ming[i]);strcpy(ming[i],ming[i+1]);strcpy(ming[i+1],c); for(m=0;m&lt;=3;m++) { f=*fen[i][m];*fen[i][m]=*fen[i+1][m];*fen[i+1][m]=f; } } for(m=0;m&lt;=*renshu-2;m++) { printf(\"%s,%d,%s,%4.1f,%4.1f,%4.1f,%5.1f\\n\",hao[m],*ban[m],ming[m],*fen[m][0],*fen[m][1],*fen[m][2],*fen[m][3]); } *renshu=*renshu-1; h=h+1; } } if(h!=0) { printf(\"continue?\\n\"); scanf(\"%s\",jueding); if(strcmp(jueding,\"no\")==0) break; } else { for(m=0;m&lt;=*renshu-1;m++) { printf(\"%s,%d,%s,%4.1f,%4.1f,%4.1f,%5.1f\\n\",hao[m],*ban[m],ming[m],*fen[m][0],*fen[m][1],*fen[m][2],*fen[m][3]); } break; } }}void selet(int *ban[MAX],char *ming[MAX],char *hao[MAX],float *fen[MAX][4],int *renshu){ char panduan1[10],jueding[10]; int panduan2,i,m; for(;;) { m=0; scanf(\"%s\",panduan1); panduan2=atoi(panduan1); for(i=0;i&lt;=*renshu-1;i++) { if(strcmp(hao[i],panduan1)==0) { printf(\"%s,%d,%s,%4.1f,%4.1f,%4.1f,%5.1f\\n\",hao[i],*ban[i],ming[i],*fen[i][0],*fen[i][1],*fen[i][2],*fen[i][3]); m=m+1; } else if(panduan2==*ban[i]) { printf(\"%s,%d,%s,%4.1f,%4.1f,%4.1f,%5.1f\\n\",hao[i],*ban[i],ming[i],*fen[i][0],*fen[i][1],*fen[i][2],*fen[i][3]); m=m+1; } } if(m==0) { printf(\"there is no eligible student\\n\"); break; } printf(\"continue?\\n\"); scanf(\"%s\",jueding); if(strcmp(jueding,\"no\")==0) break; }}void order(int *ban[MAX],char *ming[MAX],char *hao[MAX],float *fen[MAX][4],int *renshu){ int i,k,q,m; char c[10]; float f; for(k=1;k&lt;=*renshu-1;k++) for(i=0;i&lt;=*renshu-1-k;i++) if(*ban[i]&gt;*ban[i+1]) { q=*ban[i];*ban[i]=*ban[i+1];*ban[i+1]=q; strcpy(c,hao[i]);strcpy(hao[i],hao[i+1]);strcpy(hao[i+1],c); strcpy(c,ming[i]);strcpy(ming[i],ming[i+1]);strcpy(ming[i+1],c); for(m=0;m&lt;=3;m++) { f=*fen[i][m];*fen[i][m]=*fen[i+1][m];*fen[i+1][m]=f; } } for(k=1;k&lt;=*renshu-1;k++) for(i=0;i&lt;=*renshu-1-k;i++) if(*ban[k]==*ban[k+1]) if(*fen[k][3]&lt;*fen[k+1][3]) { q=*ban[i];*ban[i]=*ban[i+1];*ban[i+1]=q; strcpy(c,hao[i]);strcpy(hao[i],hao[i+1]);strcpy(hao[i+1],c); strcpy(c,ming[i]);strcpy(ming[i],ming[i+1]);strcpy(ming[i+1],c); for(m=0;m&lt;=3;m++) { f=*fen[i][m];*fen[i][m]=*fen[i+1][m];*fen[i+1][m]=f; } } for(i=0;i&lt;=*renshu-1;i++) { printf(\"%s,%d,%s,%4.1f,%4.1f,%4.1f,%5.1f\\n\",hao[i],*ban[i],ming[i],*fen[i][0],*fen[i][1],*fen[i][2],*fen[i][3]); } }void output(int *ban[MAX],char *ming[MAX],char *hao[MAX],float *fen[MAX][4],int *renshu){ int i; for(i=0;i&lt;=*renshu-1;i++) { printf(\"%s,%d,%s,%4.1f,%4.1f,%4.1f,%5.1f\\n\",hao[i],*ban[i],ming[i],*fen[i][0],*fen[i][1],*fen[i][2],*fen[i][3]); }}int main(){ int *banji[MAX],*number,i,num,mingling; char *xingming[MAX],*xuehao[MAX]; float *chengji[MAX][4]; struct Student { char Id[10]; char name[50]; int clas; float score[4]; } student[MAX]; num=0; for(i=0;i&lt;=MAX-1;i++) { banji[i]=&amp;student[i].clas; xingming[i]=&amp;student[i].name[0]; xuehao[i]=&amp;student[i].Id[0]; chengji[i][0]=&amp;student[i].score[0]; chengji[i][1]=&amp;student[i].score[1]; chengji[i][2]=&amp;student[i].score[2]; chengji[i][3]=&amp;student[i].score[3]; } number=# for(;;) { printf(\"1.input\\n2.delete\\n3.select\\n4.order\\n5.output\\n6.quit\\nplease input your option\\n\"); scanf(\"%d\",&amp;mingling); if(mingling==1) input(banji,xingming,xuehao,chengji,number); if(mingling==2) del(banji,xingming,xuehao,chengji,number); if(mingling==3) selet(banji,xingming,xuehao,chengji,number); if(mingling==4) order(banji,xingming,xuehao,chengji,number); if(mingling==5) output(banji,xingming,xuehao,chengji,number); if(mingling==6) break; } return 0;}","tags":[{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"C语言程序设计上机题目","date":"2018-06-17T08:30:00.000Z","path":"2018/06/17/C语言程序设计上机题目/","text":"大一下C语言程序设计上机题目，原报告找不到了 · 综合实验7 删除某一个学生的信息 假定程序中已经有三个学生信息了，现在需要删除一个已有学生信息。 要求： 1）必须用数组来存储学生信息，包括学号，班级，姓名，三门课程的成绩； 2）学生在数组中必须是排序的（按照实验5那样进行排序，班级从小到大，同一班级内总成绩从大到小）； 3）删除某一个学生信息，数组必须依然保持有序。 注：程序只需要输入一个待删除学生的学号或者姓名，如果该学生不存在，则输出原有三个学生信息即可。已有的三个学生的信息可以在数组初始化时静态赋值，也可以用语句来进行动态赋值。要求这三个学生的信息必须是： 1001 11 Zhang 99.5 88.5 89.5 1002 12 Yang 77.9 56.5 87.5 1003 11 Liang 92.5 99.0 60.5 输入：学号或者姓名 输出：剩余学生的信息，格式如下（中间用空格隔开，每个学生一行） 学号1 班级1 姓名1 成绩1 成绩2 成绩3 学号2 班级2 姓名2 成绩1 成绩2 成绩3 例如删除的是学号为1001的同学，则程序的输出应为： 1003 11 Liang 92.5 99.0 60.5 1002 12 Yang 77.9 56.5 87.5 · 综合实验8 修改某一个学生的信息 假定程序中已经有三个学生信息了，现在需要修改一个已有学生信息。 要求： 1）必须用数组来存储学生信息，包括学号，班级，姓名，三门课程的成绩； 2）学生在数组中必须是排序的（按照上周第五个作业那样进行排序，班级从小到大，同一班级内总成绩从大到小）； 3）修改某一个学生信息，数组必须依然保持有序。输出也必须排序 注：程序只需要输入一个待修改学生的全部信息。通过学号寻找学生，找到则修改；若没有找到相关学生，则不予修改，直接输出原有学生信息即可。已有的三个学生的信息可以在数组初始化时静态赋值，也可以用语句来进行动态赋值。要求这三个学生的信息必须是： 1001 11 Zhang 99.5 88.5 89.5 1002 12 Yang 77.9 56.5 87.5 1003 11 Liang 92.5 99.0 60.5 输入(中间用空格隔开)：学号1 班级1 姓名1 成绩1 成绩2 成绩3 输出：更新后的学生的信息，格式如下（中间用空格隔开，每个学生一行） 学号1 班级1 姓名1 成绩1 成绩2 成绩3 学号2 班级2 姓名2 成绩1 成绩2 成绩3 学号3 班级3 姓名3 成绩1 成绩2 成绩3 如将学号为1001的同学成绩修改为 55.0 56.0 57.0 则输出应是： 1003 11 Liang 92.5 99.0 60.5 1001 11 Zhang 55.0 56.0 57.0 1002 12 Yang 77.9 56.5 87.5 · 综合实验9 加入查询功能 用户从键盘输入查询要求，在学生信息中查找满足要求的学生，并按班级从小到大，同班级按总成绩从大到小排序显示出来。要求输入，查找过程，排序和输出必须用函数来实现（即加上main函数，程序有5个函数）。因此，学生信息可以考虑两种实现方式：1）用全局量来表示；2）在main函数中定义为局部量，然后以地址传递方式传递给各个子函数。 学生信息如下: 1001 11 Zhang 99.5 88.5 89.5 1002 12 Yang 77.9 56.5 87.5 1003 11 Liang 92.5 99.0 60.5 1004 11 Cai 89.6 56.9 90.5 1005 14 Fu 55.6 67.9 98.9 1006 12 Mao 22.1 45.9 99.2 1007 13 Zhan 35.6 67.9 88.0 用户可以输入的查询格式如下： 1 11 表示查询11班的所有学生； 2 1001-1004 表示查询学号在1001到1004之间的所有学生（包括1001和1004） 3 Zh* 表示查询名字以Zh两个字母开头的所有学生 4 98.0 表示查询总分大于等于98.0的学生 注意：上述输入中前面的数字必须输入，表示查询的类别，数字和后面的内容之间用空格隔开。 输出：查询到学生的信息，格式如下（中间用空格隔开，每个学生一行） 学号1 班级1 姓名1 成绩1 成绩2 成绩3 学号2 班级2 姓名2 成绩1 成绩2 成绩3 学号3 班级3 姓名3 成绩1 成绩2 成绩3 如输入的是 1 12 则输出应是： 1002 12 Yang 77.9 56.5 87.5 1006 12 Mao 22.1 45.9 99.2 · 综合实验10 对已有的学生信息按照姓名先后顺序输出结果，要求用指针实现 编写函数 sort 实现按照姓名的排序，在 main 函数中调用 sort 函数，按照姓名先后输出学生的各项信息。 要求： 1 ） sort 函数自行定义，要求用指针作为参数。 2 ）三个学生的信息在程序中直接赋值。三个学生的信息如下： 1001,11,zhang,99.5,88.5,89.5,277.5 1002,22,li,77.9,56.5,87.5,221.9 1003,11,wang,92.5,99.0,60.5,252.0 程序运行结果如下： 1002,22,li,77.9,56.5,87.5,221.9 1003,11,wang,92.5,99.0,60.5,252.0 1001,11,zhang,99.5,88.5,89.5,277.5 （注意：输出学生信息用逗号分隔，换行输出） · 综合实验11 完整的学籍管理程序 这将是你在本学期学习完程序设计基础课程后的一次大练兵，希望能用所学的知识和前面积累的程序经验实现一个较为完整的系统，尽量全部使用到函数、数组、指针和结构体。为了体现你的学习成果，请用学号命名你的第一版学籍管理系统，比如 2120504001.cpp ，预祝成功！ 重要提示：从提交作业情况来看，格式上要注意：1）注意检查各个单词的拼写，大小写等情况；2）输入时，Id中I是i的大写，并且Id,class等之后没有回车换行；3）continue？之后必须加换行。 为了方便大家调试，下面给出测试用例的输入和输出 一 输入 1 1001 11 zhang 99.5 88.5 89.5 yes 1002 22 li 77.9 56.5 87.5 yes 1003 11 wang 92.5 99.0 60.5 no 2 1002 no 3 1001 yes 11 no 4 5 6 二 输出 1.input 2.delete 3.select 4.order 5.output 6.quit please input your option Id class name score1 score2 score3 continue? Id class name score1 score2 score3 continue? Id class name score1 score2 score3 continue? 1.input 2.delete 3.select 4.order 5.output 6.quit please input your option 1001,11,zhang,99.5,88.5,89.5,277.5 1003,11,wang,92.5,99.0,60.5,252.0 continue? 1.input 2.delete 3.select 4.order 5.output 6.quit please input your option 1001,11,zhang,99.5,88.5,89.5,277.5 continue? 1001,11,zhang,99.5,88.5,89.5,277.5 1003,11,wang,92.5,99.0,60.5,252.0 continue? 1.input 2.delete 3.select 4.order 5.output 6.quit please input your option 1001,11,zhang,99.5,88.5,89.5,277.5 1003,11,wang,92.5,99.0,60.5,252.0 1.input 2.delete 3.select 4.order 5.output 6.quit please input your option 1001,11,zhang,99.5,88.5,89.5,277.5 1003,11,wang,92.5,99.0,60.5,252.0 1.input 2.delete 3.select 4.order 5.output 6.quit please input your option -------------------------------------------------------------------------------- 要求程序能实现以下基本功能： 1 ．提供基本的菜单选项，能根据不同的选项执行不同操作； \\2. 对学生信息进行录入，删除、查询等操作； 3 ．对学生信息进行统计、排序等操作。 程序运行结果如下： （注意：括号内为程序说明，运行时不显示， 下划线部分为输入部分 。学生信息包括学号、班级、姓名和三门课成绩，数据类型和要求同前，基本的三个学生信息同前。输入输出全部采用小写和英文标点 。下面是运行结果的示例，运行结果视具体操作而变 ） （首先输出菜单选项） 1.input 2.delete 3.select 4.order 5.output 6.quit please input your option （提示用户选择操作，根据用户的选择执行不同的功能，如果用户选择 1 ，则完成学生信息的录入） 1 Id 1001 （输入和输出之间用一个空格） class 11 name zhang score1 99.5 score2 88.5 score3 89.5 continue? （询问用户是否继续输入操作） yes （用户选择继续输入） Id 1002 （输入和输出之间用一个空格） class 22 name li score1 77.9 score2 56.5 score3 87.5 continue? （询问用户是否继续输入操作） yes （用户选择继续输入） Id 1003 （输入和输出之间用一个空格） class 11 name wang score1 92.5 score2 99.0 score3 60.5 continue? （询问用户是否继续输入操作） no （用户不再继续输入后显示主菜单选项，供用户选择其他操作） 1.input 2.delete 3.select 4.order 5.output 6.quit please input your option （提示用户选择操作，根据用户的选择执行不同的功能，如果用户选择 2 ，则完成学生信息的删除，要求输入待删除学生的学号或者姓名，如果该学生不存在，则输出原有学生的信息；如果指定删除的学生存在，则删除该学生的信息后，输出其余学生信息；允许用户可以删除多个学生信息，但至少保留一个学生信息） 2 1002 或 li 1001,11,zhang,99.5,88.5,89.5,277.5 1003,11,wang,92.5,99.0,60.5,252.0 continue? （询问用户是否继续输入操作） no （用户不再继续输入后显示主菜单选项，供用户选择其他操作） 1.input 2.delete 3.select 4.order 5.output 6.quit please input your option （提示用户选择操作，根据用户的选择执行不同的功能，如果用户选择 3 ，则完成学生信息的选择，要求输入待选择学生的学号或班级，如果该学生存在，则输出该学生的信息；若学生不存在，则提示用户“ there is no eligible student ”，输出主菜单供用户继续选择；如果有重名的学生或者一个班级有多名同学，则输出全部符合条件的学生信息。） 3 1001 1001,11,zhang,99.5,88.5,89.5,277.5 continue? yes 11 1001,11,zhang,99.5,88.5,89.5,277.5 1003,11,wang,92.5,99.0,60.5,252.0 continue? （询问用户是否继续输入操作） no （用户不再继续输入后显示主菜单选项，供用户选择其他操作） 1.input 2.delete 3.select 4.order 5.output 6.quit please input your option （提示用户选择操作，根据用户的选择执行不同的功能，如果用户选择 4 ，则完成学生信息的排序，要求实现班级和学生总成绩的双重排序，即班级按照从小到大，同一班级内部按照学生总成绩从大到小。注意下面前提是有三条学生信息） 4 1001,11,zhang,99.5,88.5,89.5,277.5 1003,11,wang,92.5,99.0,60.5,252.0 （排序后输出主菜单，允许用户继续选择） 1.input 2.delete 3.select 4.order 5.output 6.quit please input your option （提示用户选择操作，根据用户的选择执行不同的功能，如果用户选择 5 ，则输出当前学生的信息。如果之前排序了就输出排序后的结果，否则原样输出。） 5 1001,11,zhang,99.5,88.5,89.5,277.5 1003,11,wang,92.5,99.0,60.5,252.0 （输出主菜单，允许用户继续选择） 1.input 2.delete 3.select 4.order 5.output 6.quit please input your option （提示用户选择操作，根据用户的选择执行不同的功能，如果用户选择 6 ，则退出程序） 6 （退出程序） · 实验报告提交 注意：实验格式参见讨论区“实验报告模板”，实验报告以学号命名，例如2120504001.doc。 注意：不仅要提交电子版，还要提交纸质打印版。班长收齐后一起交到东2楼236房间即可。注意：最后提交日期另行通知。 实验题目：使用 C 编程实现一个学籍管理系统 （实验内容可以参考如下格式，字体建议采用宋体五号字） 1. 程序设计与分析 （说明：包括程序实现的功能、采用什么数据类型，核心算法等，亦可采用标准的流程图或 N － S 图作为辅助描述） 2. 程序设计中存在的问题和解决思路 （说明：针对编程中出现的主要问题和解决方法简要说明） 3. 实验总结 （说明：通过实验，你有哪些收获？对哪些知识点得到了加强学习，还有哪些需要改进之处等。 ） 4. 源代码清单 （说明：请尽量规范代码书写，注意缩进、换行、变量命名等）","tags":[{"name":"C语言","slug":"C语言","permalink":"https://renzehua1998.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"数学实验报告","date":"2018-06-02T09:50:00.000Z","path":"2018/06/02/数学实验报告/","text":"大一下数学实验报告（书后题目） 做得较好的题目：第四次任务第一题 P15 第一次任务 实验八 练习一 2. ① 实验问题： 某车间有甲·乙·丙三台车床可用于加工零件，这三台车床可用于工作的最多时间分别为700h，800h 和 900h，需要加工的三种零件的数量分别为 300，400 和 500。不同车床加工不同零件所用时间和费用如下表所示，在完成任务的前提下，如何分配加工任务，才能使加工费最少？ 车床名称 加工 单位零件 所需时数 加工 单位零件 所需费用 可用于工作的时数 零件1 零件2 零件3 零件1 零件2 零件3 甲 0.4 0.5 0.5 7 8 8 700 乙 0.8 0.7 0.5 8 7 8 800 丙 0.8 0.6 0.6 7 9 8 900 ②问题分析：该题是一道一般线性规划问题，决策变量个数为 9，限制条件为 3 个不等式和 3 个等式，整理后运用 linprog 函数即可求解。 ③程序设计流程图： 123456789101112131415f=[7,8,7,8,7,9,8,8,8];a=[0.6,0,0,0.5,0,0,0.5,0,0;0,0.4,0,0,0.7,0,0,0.5,0;0,0,0.8,0,0,0.6,0,0,0.6];b=[700,800,900];aeq=[1,1,1,0,0,0,0,0,0;0,0,0,1,1,1,0,0,0;0,0,0,0,0,0,1,1,1];beq=[300,400,500];vlb=[0,0,0,0,0,0,0,0,0];vub=[];[x,fval]=linprog(f,a,b,aeq,beq,vlb,vub) 答案 x = 103.7917 0.0000 196.2083 0.0000 400.0000 0.0000 149.9740 151.1015 198.9245 fval = 8.9000e+003 ④结果分析与结论：所以应当用甲车床生产 104 件零件 1，196 件零件 3；用乙车床生产 400 件零件 2；用丙车床生产 150 件零件 1,151 件零件 2,199 件零件 3. ⑤总结与体会：该题的核心是确定各个变量在矩阵中的位置。第一次做时，因变量位置看错，导致了结果错误，检查改正后结果正常。 实验八 练习一 5. ① 实验问题: 某医院每日至少需要护士人数如下表所示。 班次 时间段 人数 1 6:00~10：00 60 2 10:00~14:00 70 3 14:00~18:00 60 4 :18:00~22:00 50 5 22:00~2:00 20 6 2：00~6:00 30 每班护士在值班开始时向病房报到，连续工作 8h，医院至少需要多少少护士才能满足值班要求？ ②问题分析：本题为一般线性规划问题，决策变量个数为 6，限制条件位 6 个不等式，之后运用 linprog 函数可求解。 ③程序设计流程图： 1234567891011121314151617c=[1,1,1,1,1,1];a(1,:)=[-1,0,0,0,0,-1];a(2,:)=[-1,-1,0,0,0,0];a(3,:)=[0,-1,-1,0,0,0];a(4,:)=[0,0,-1,-1,0,0];a(5,:)=[0,0,0,-1,-1,0];a(6,:)=[0,0,0,0,-1,-1];b=[-60;-70;-60;-50;-20;-30];[c,fval]=linprog(c,a,b) 结果 c = 35.2410 34.7590 28.7310 21.2690 1.1272 28.8728 fval = 150.0000 ④结果分析与结论：所以至少需要 150 个护士才能满足要求。⑤总结与体会：该题是一道简单的一般线性规划问题，确定决策变量个数后即可快速求解。 实验八 练习二 2. ①实验问题：某校学生在大学三年级第一学期必须要选修的课程（必修课）只有一门（2 个学分）;可供限定选修的课程有 8 门，任意选修课程有 10 门。由于一些课程之间忽悠联系，所以可能在选修某门课程中必须同时选修其他课程，这 18 门课程的学分数和要求同时选修课程的相应信息如下表所示。 课程信息表 按学校规定，每个学生每学期选修的总学分不能少于 21 学分，因此，学生必须在上述 18 门课程中至少选修 19 学分，学校同时还规定学生每学期选修任意选修课的学分不能少于 3 学分，也不能超过 6 学分。为了达到要求，试为该学生确定一种选课方案。 ②问题分析：本题是一道 0-1 规划问题，难点主要在于，选了 y 一定要选 x， 但选了 x 可以选 y 也可以不选 y，故本题需要更改计算方式，考虑 X-Y≥0 即可 解决问题。 ③程序设计流程图： 123456c=[-5,-5,-4,-4,-3,-3,-3,-2,-3,-3,-3,-2,-2,-2,-1,-1,-1,-1]; a=[-5,-5,-4,-4,-3,-3,-3,-2,-3,-3,-3,-2,-2,-2,-1,-1,-1,-1;0,0,0,0,0,0,0,0,3,3,3,2,2,2,1,1,1,1; 0,0,0,0,0,0,0,0,-3,-3,-3,-2,-2,-2,-1,-1,-1,-1; -1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0; 0,-1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0; 0,0,0,0,0,0,0,-1,1,0,0,0,0,0,0,0,0,0; 0,0,0,0,0,-1,0,0,0,1,0,0,0,0,0,0,0,0; 0,0,0,-1,0,0,0,0,0,0,1,0,0,0,0,0,0,0; 0,0,0,0,-1,0,0,0,0,0,0,1,0,0,0,0,0,0; 0,0,0,0,0,0,-1,0,0,0,0,0,1,0,0,0,0,0;0,0,0,0,0,-1,0,0,0,0,0,0,0,1,0,0,0,0]; b=[-19;6;-3;0;0;0;0;0;0;0;0];[x,fval]=bintprog(c,a,b);fval=-fvalxmax=x 答案 fval = 35 xmax = 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 ④结果分析与结论：由实验结果可以得出，需要连选前面的 10 门课才可以达到要求。此时的总学分已远远超出学校要求，但仍为最佳方案。 ⑤总结与体会：在做本题时，开始是使用了一般线性规划的方法，但未成功，经过翻书查找，最后确定了该规划的类型以及求解方法。 实验九 3. ①实验问题：某企业在两个相互分离的市场上出售同一产品，两个市场的需求哈密数分别为 p1=18-2*q1,p2=12-q2,其中 p1、p2 分别表示该产品在两个市场上的价格(单位:万元/t)，q1、q2 分别表示该产品在两个市场上的销售总量，即 q=q1+q2。在产销平衡的状态下: (1)如果该企业实行价格差别战略（即 q1≠q2），试确定两个市场上该产品的 销售量和最优价格，使该企业获得最大利润。 (2)如果该企业实行价格差别战略（即 q1=q2），试确定两个市场上该产品的销售量和最优价格，使该企业获得最大利润。 ②问题分析：本题的主要思路是如何编辑一个二元函数，并利用该函数求解最大值。显然，应该以销量为自变量。 ③程序设计流程图： 第一问 1234567891011f='-1*((18-x(1))*x(1)*0.5+(12-x(2))*x(2)-2*((18-x(1))*0.5+(12-x(2)))-5)';x0=[0,0];[x,fmin]=fminsearch(f,x0)fmax=-fminx =10.0001 7.0000 答案 fmin = -52.0000 fmax = 52.0000 第二问 12345f='-1*((18-x)*x*0.5+(12-x)*x-2*((18-x)*0.5+(12-x))-5)';[x,fval]=fminbnd(f,0,100)fmax=-fval 答案 x = 8.0000 fval = -49.0000 fmax = 49.0000 ④结果分析与结论： （1） 企业应分别定价为 10 与 7，此时的最大利润为 52 万元 （2） 企业应定价为 8，此时最大利润为 49 万元 ⑤总结与体会：通过本题，我从对高等数学中如何求多元函数极值有了更深的认识，同时也学会了非线性规划问题的求解技巧。 第二次任务 实验任务 1. ① 实验问题： ② 问题分析：本题仍是一个线性规划问题，不同之处在于决策变量众多，因此，经过研究决定使用表格处理数据。在变量编辑器中直接对矩阵进行编辑。最后结果的列向量中令第 1—9 号为 Xz，10—15 号为 Px，16—24 号为Cy，25—33 号为 Br，34—42 号为 Jj，43—51 号为 Jg，每个矩阵为从上到下按列的顺序编号。 ③ 程序设计流程图： A： B： beq： aeq： [x1,fval1]=linprog(C1,A,B,aeq,beq,vlb,vub) 答案 x1 = 0 0.0000 0.0000 0.0000 0.0000 748.0754 71.2812 0.0000 428.7188 200.0000 200.0000 200.0000 0.0000 500000 21.6938 0.0000 28.3062 0 0 0 0.0000 75.0000 39.1153 25.0000 600.0000 0.0000 175.0000 38.5548 0.0000 34.8411 34.1506 42.4535 0.0000 0.0000 0.0000 0.0000 0.0000 25.0000 0.0000 0.0000 0.0000 31.3100 561.4452 0 215.1589 203.3494 662.5465 0.0000 0.0000 0.0000 0.0000 fval1=1.6425e+03 ④结果分析与结论：结果为 1.6425e+03。 ⑤总结与体会：通过该题，我学会了如何使用表格表示决策变量众多时问题的约束条件。 实验任务 2. ① 实验问题： ② 问题分析：本题仍是一个线性规划问题，不同之处在于决策变量众多，因此，经过研究决定使用表格处理数据。对于变量的编号同 1 ③程序设计流程图： [x2,fval2]=linprog(C2,A,B,aeq,beq,vlb,vub) 答案 x2 = 0 0.0000 0.0000 0.0000 0.0000 800.0000 55.5556 0.0000 444.4444 200.0000 181.2588 135.0000 0.0000 0.0000 175.0000 0.0000 0.0000 0.0000 0.0000 550.0000 0.0000 600.0000 0 315.0000 225.0000 773.7412 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0 0 0 0.0000 12.5176 0.0000 0.000 0.0000 0.0000 0.0000 0.0000 fval2 = 9.6800e+05 ④结果分析与结论：结果为 9.6800e+05。 ⑤总结与体会：通过该题，我学会了如何使用表格表示决策变量众多时问题的约束条件。 第三次任务 实验任务 1. 1 实验问题 2 问题分析：通过循环语句对公式 a 进行计算，得到的结果与原题进行比较 3 程序设计流程图 1234567891011n=50;s=0;for k=1:ns=s+1/(2*k-1)^2;endm=sqrt(8*s);vpa(m,20) 答案： ans = 3.1352202050631281516 4 总结分析和结论：公式 a 与原公式相比较，叠加次数均为 50 时，a 公式精度更高，所以用 a 计算 π 更好。 5 总结和体会：通过这道题目的练习，我学会了利用循环实现对无理数值的近似计算。 实验任务 2. 1 实验问题：基于关系式利用蒙特卡洛方法近似计算 π 2 问题分析：利用 rand（1，2）产生一个二维随机数组，判断它是否在被积函数的积分范围内，用符合条件的点数除以总数乘 4 即为 π 的近似值。 3 程序设计流程图 1234567891011121314151617cs=0;n=500;for i=1:na=rand(1,2);if 1/(1+a(1)^2)&gt;=a(2)cs=cs+1;endendm=4*cs/n 4 总结分析和结论： N 分别为 500 5000 50000 500000 时，算得 π 的近似值分别为 3.15200000 3.15920000 3.14368000 3.14192000 5 总结和体会： 通过计算本题，我学会了如何用概率计算估计确定的值 实验任务 3 1 实验问题 用 MATLAB 完成下列实验任务 （1）求 y=cos x 在 x=0 处的泰勒展开式 （2）计算 cos1 近似值，为使精确度达到 10^(-4),要用多少次多项式代替函数 y=cos x 2 问题分析 利用求泰勒展开式的函数，即可求解。 定义变量 x,n，构造 f1,f2,为其泰勒展开式，f2,f1,差值为其误差，即 cos x 在 x=1 处的泰勒展开式的差值小于 10^（-4），求出此时的 n 3 解题程序 （1） 123syms x;taylor(cos(x),x,0,'order',10) ans = x^8/40320 - x^6/720 + x^4/24 - x^2/2 + 1 （2） 1234567891011121314151617syms x n,for n=5:100f1=taylor(cos(x),x,'order',n)f2=taylor(cos(x),x,'order',n+1)if(subs(f2-f1,x,1)&lt;=10^(-4))fprintf('the answer is %d\\n',n+1)breakendend f1 = x^4/24 - x^2/2 + 1 f2 = x^4/24 - x^2/2 + 1 the answer is 6 4 结果分析 实验结果表明，计算 cos 1 的近似值时为使精确度达到 10^(-4),至少要用 6 次泰勒多项式代替函数 y=cos x 5 总结体会 通过以上分析与实践，学会了利用 matlab 用泰勒公式对近似值求解 ，并且，对不同的展开项数的精确程度有一定认识。 实验任务4 练习2 1 1 题目 完成下面任务 求出函数 f(x)=e(-x2))在 x=0 的泰勒展开式，由此计算 e 的近似值 在精确位数相同的情况下，同函数 f(x)=e^x 在 x=0 的泰勒展开式比较，吗一个计算无理数 e 所需要的选取的项数较多？ 2 问题分析 1）用 matlab 的函数求出泰勒展开式，并由其通项的变化规律求出其指定项数的确定精确度的 e 的近似值。 2）根据 e^x 的泰勒展开式，求出其通项，在选取项数相同的情况下，分析其精确度的差距。若其更精确，则说明 e^x 在同样的展开项数下，更接近 e 的值，即当精确位数相同时，需要的项数较少。 3 解题程序 123syms x;taylor(exp(-x^2),x,0,'order',10) ans = x^8/24 - x^6/6 + x^4/2 - x^2 + 1 123456789101112131415161718he=1ji=1n=5digits(25)for k=1:nji=ji*k*(-1) he=(he+1/ji)endy=vpa(he,20)e=y^(-1) 答案： y = 0.36666666666666666667 e = 2.727272727272727272727273 （2） 1234567891011121314151617he=1ji=1n=30digits(25)for k=1:n ji=ji*k he=he+1/jiende=vpa(he,20) 答案： he = 2.7183 e = 2.7182818284590455349 4 结果分析 当选取相同的项数时，e(-x2))的精确度没有 e^x 高，所以在相同的精确度下，e(-x2))的选取的项数较多。 5 总结体会 学会了一般型函数的泰勒展开的基本方法 用泰勒公式计算无限不循环小数的基本过程 学会了利用构造循环数列来求已知泰勒展开的项数时，求固定精确度的近似值的方法。 第四次任务 实验任务 1 1 题目 2 问题分析 （1）分别以 OB、OA 为 x 轴、y 轴的正方向建立直角坐标系，设在时刻 t，兔子的位置到达点 R（0，at），狗到达点 D（x，y） （2）在这一过程中，兔子与狗跑的时间相同，均为120/8 = 15𝑠，故有狗跑过的路程为15 × 17.0803 = 256.2045m （3）用计算机仿真法绘制狗与兔子的奔跑曲线，令狗的速度方向时时指向兔子，时间间隔取 0.01s，相距 0.1m 时停止。 （4）用计算机仿真法，将第一阶段停止条件设为二者相距30m，此时令 其余条件与前三问相同，当距离小于 0.1m 时停止。通过调整适当的狗的初始速度，使得兔子跑的距离为 120m，此时狗的速度就为最小速度，并求出狗的匀速时间和加速时间，从而得到狗的路程。 由程序得 b=15.41m/s，t1=13.8800s t2=2.2200s 所以狗的路程 3．解题程序 （1）（2） f=inline('120(1-(8/x)^2)-200(8/x)'); b=fzero(f,[1,20]) 或： b=solve('120(1-(8/x)^2)-200(8/x)','x') 答案： b = 17.0803 （3） 12345678910111213141516171819202122232425262728293031c=200; a=8; b=17.0308;n=sqrt(2)/2;dogxb=[];dogyb=[];rabbitxb=[];rabbityb=[];d=0.1;dt=0.1;t=0;dogx=c;dogy=0;rabbitx=0;rabbity=0;while (sqrt((dogx-rabbitx)^2+(dogy-rabbity)^2)&gt;d)t=t+dt;dogx=dogx-b*dt*dogx/sqrt(dogx^2+(a*t-dogy)^2);dogxb=[dogxb,dogx];dogy=dogy+b*dt*(a*t-dogy)/sqrt(dogx^2+(a*t-dogy)^2);dogyb=[dogyb,dogy];rabbity=a*t;rabbityb=[rabbityb,rabbity];endrabbitxb=zeros(length(rabbityb));dogxb=-dogxb;plot(dogxb,dogyb,'r*',rabbitxb,rabbityb,'b*') 将最后一句替换为 12345dogx0=n.*dogxb-n.*dogyb;dogy0=n.*dogxb+n.*dogyb; rabbitx0=-n.*rabbityb;rabbity0=n.*rabbityb; plot(dogx0,dogy0, 'r*', rabbitx0,rabbity0, 'b*') 进行坐标变换即可得到题目要求的追击路线： （4） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859c=-200; a=8; b=15.41;n=sqrt(2)/2; dogxb=[];dogyb=[];rabbitxb=[];rabbityb=[]; d1=30;d2=0.1;dt=0.01;t=0; dogx=c;dogy=0;rabbitx=0;rabbity=0;while (sqrt((dogx-rabbitx)^2+(dogy-rabbity)^2)&gt;d1)t=t+dt;dogx=dogx-b*dt*dogx/sqrt(dogx^2+(a*t-dogy)^2);dogxb=[dogxb,dogx];dogy=dogy+b*dt*(a*t-dogy)/sqrt(dogx^2+(a*t-dogy)^2);dogyb=[dogyb,dogy];rabbity=a*t;rabbityb=[rabbityb,rabbity];endrabbitxb=zeros(length(rabbityb));dogx0=n.*dogxb-n.*dogyb;dogy0=n.*dogxb+n.*dogyb; rabbitx0=-n.*rabbityb;rabbity0=n.*rabbityb; plot(dogx0,dogy0, 'r*', rabbitx0,rabbity0, 'b*') thold ont=0;dogxb=[];dogyb=[];rabbitxb=[];rabbityb=[];while (sqrt((dogx-rabbitx)^2+(dogy-rabbity)^2)&gt;d2)a=a*(0.5)^dt;b=b*1.1^dt;t=t+dt;rabbity=rabbity+a*dt;rabbityb=[rabbityb,rabbity];dogx=dogx-b*dt*dogx/sqrt(dogx^2+(rabbity-dogy)^2);dogxb=[dogxb,dogx];dogy=dogy+b*dt*(rabbity-dogy)/sqrt(dogx^2+(rabbity-dogy)^2);dogyb=[dogyb,dogy];endrabbitxb=zeros(length(rabbityb));dogx0=n.*dogxb-n.*dogyb;dogy0=n.*dogxb+n.*dogyb;rabbitx0=-n.*rabbityb;rabbity0=n.*rabbityb;plot(dogx0,dogy0, 'b', rabbitx0,rabbity0, 'r')rabbityt 运行结果： t = 13.8800 （匀速运动时间） rabbity = 120.0729 （兔子跑的距离） t = 2.2200 （加速时间） 求 s： 1234567syms t;s1=13.88*15.41;s2=int('15.41*1.1^t',t,0,2.22);s=s1+s2 答案：s =251.9896026444088249314017140895 4 结果分析 （1） 狗的最小速度为 17.0803m/s （2）狗的路程为 256.2045m （3）如上图（4）狗的最小速度为 15.41m/s 路程为 251.9896m 路线图如上 5 总结体会 通过这样的一次大型实验，我对于微分方程有了更加深刻的认识，同时也尝试使用 matlab 求微分方程的解析解与数值解，不过就本实验来说用仿真更加便捷。在这个过程中我对于计算机仿真、微分方程求解的能力都有了很大提高。 实验任务 2 1 实验问题 使用计算机仿真方法求解下述问题：在正方形的四个顶点上各有一人，如下图所示，在某一时刻，四人同时出发以匀速按顺时针方向追赶下一个人,如果他们始终保持对准目标,试确定每个人的行进路线。 2问题分析 本题是一个动态追击问题,我们可以通过使追及过程离散化的方法来模拟四人的追及过程,即以极短的时间段 dt 为间隔,逐步分析四人的运动状况。 3 程序设计流程图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879A=[0,0];B=[0,1];C=[1,1];D=[1,0];k=0;dt=0.004;v=1;grid;hold on;axis([0 1 0 1]);while k&lt;10000k=k+1;plot(A(1),A(2),'g.');plot(B(1),B(2),'r.');plot(C(1),C(2),'y.');plot(D(1),D(2),'b.');e1=(B-A)/norm(B-A);A=A+v*dt*e1;e2=(C-B)/norm(C-B);B=B+v*dt*e2;e3=(D-C)/norm(D-C);C=C+v*dt*e3;e4=A-v*dt*e1-D;d4=norm(e4);e4=e4/d4;D=D+v*dt*e4;d1=norm(B-A);d2=norm(B-A);d3=norm(D-C);d4=norm(A-D);fprintf('k=%.0f d1=%.4f d3=%.4f d4=%.4f\\n',k,d1,d2,d3,d4);fprintf('A(%.2f,%.2f) B(%.2f,%.2f) C(%.2f,%.2f) D(%.2f,%.2f)\\n',A(1),A(2),B(1),B(2),C(1),C(2),D(1),D(2)); if d1&lt;=0.005breakendif d2&lt;=0.005breakendif d3&lt;=0.005breakendif d4&lt;=0.005breakendpause(0.01)end 4 结果分析和结论： 5 总结和体会： 通过这次实验，我对于计算机仿真有了更深入的理解，也掌握了更加行之有效的方法。 第五次任务 实验任务 1 题目：下表中，X 是华氏温度，Y 是一分钟内一只蟋 蟀的鸣叫次数，试用多项式模型拟合这些数据， 画出拟合曲线，分析你的拟合模型是否很好？ 观测 序号 1 2 3 4 5 6 7 8 9 10 X 46 49 51 52 54 56 57 58 59 60 Y 40 50 55 63 72 70 77 73 90 93 观测 序号 11 12 13 14 15 16 17 18 19 20 X 61 62 63 64 66 67 68 71 72 71 Y 96 88 99 110 113 120 127 137 132 137 分析过程 上述问题为最佳曲线拟合问题，即确定一条曲线使它和实验数据点最接近，用 polyfit 对其计算五次拟合多项式，存放在 p 中，再用 plot 求其在 x0 的 y0. 解题程序 123456789101112131415161718192021x=[46;49;51;52;54;56;57;58;59;60;61;62;63;64;66;67;68;71;72;71];y=[40;50;55;63;72;70;77;73;90;93;96;88;99;110;113;120;127;137;132;137];plot(x,y,'k','markersize',20);axis([30 100 20 170]);p=polyfit(x,y,5);t=30:1:100;s=polyval(p,t);hold onplot(t,s,'k-','linewidth',2)grid 实验结论 p = 1.0e+04 * -0.0000 0.0000 -0.0002 0.0141 -0.3963 4.4287 随着温度的上升，蟋蟀在单位时间内鸣叫的次数，先下降，再上升，然后接着下降，并在 70 时达到最高点，并且在 45~70 这一段曲线较为准确，当小于 45 时，可明显看出曲线上升的过于剧烈，与实际不符，若增测数据点，可能会有所改善。 分析总结 学会利用 matlab 用最小二乘法和不同次序的多项式对数据进行拟合拟合效果比较好 实验任务 2 ① 实验问题： （1）在下列数据中，W 表示一条鱼的重量，l 表示 它的长度，使用最小二乘准则拟合模型 W=kl3 长度 l( 英寸 ) 14.5 12.5 17.25 14.5 12.625 17.75 14.125 12.625 重量 w( 盎司 ) 27 17 41 26 17 49 23 16 在下列数据中，g 表示一条鱼的身围，使用最 小二乘准则拟合模型W=klg2 长度 l( 英寸 ) 14.5 12.5 17.25 14.5 12.625 17.75 14.125 12.625 重量 w( 盎司 ) 27 17 41 26 17 49 23 16 身围 g（英寸） 9.75 8.375 11.0 9.75 8.5 12.5 9.0 8.5 两个模型哪个拟合数据较好？为什么? ② 问题分析： 与上一题类似，该问题亦是一个典型的曲线拟合问题，故其要点应与上一题类似，即，如何找到一条曲线，使拟合出来的数据与实际数据的偏差较小。 ③程序设计流程图： （1） 123456789101112131415161718192021222324252627l=[14.5 12.5 17.25 14.5 12.625 17.75 14.125 12.625];w=[27 17 41 26 17 49 23 16];a=0;b=0;for i=1:8a=a+l(i)^4;b=b+l(i)*w(i);endA=aB=bq=inv(A)*Bfor i=1:8x(i)=q(1)*l(i)^3;endplot(l,w,'r*--',l,x,'b.--') 123456789101112131415161718192021l=[14.5 12.5 17.25 14.5 12.625 17.75 14.125 12.625]; g=[9.75 8.375 11.0 9.75 8.5 12.5 9.0 8.5]; w=[27 17 41 26 17 49 23 16];plot3(l,g,w,'k.','markersize',25)axis([10 20 7 12 15 55])a=l.*(g.^2)b=inv(a*(a.'))*(a)*(w.')x=10:0.1:20y=7:0.1:13[X,Y]=meshgrid(x,y)Z=b*X.*Y.^2surf(X,Y,Z)shading flat （3）2 中的拟合数据较好，因为鱼的重量不仅与其身长相关，亦与身围有密不可分的联系，综合考虑才能得到较好结果。④结果分析与结论： 从图像中可以看出，随着鱼身长与身围的增大，其质量在不断增加。总结与体会：通过这次拟合实验，我们发现，在做曲线拟合时，单方面考虑得出的结果往往具有较大局限性。多方综合考虑后，才能得到准确的结果。 5 总结与体会 通过这次实验，我对于最小二乘插值法有了更深刻的了解 实验任务 3 ① 实验问题：有一形状较为复杂，但表面很光滑的曲面工件。通过科学手段，将其放置于某一空间坐标系下，测得曲面上若干个点的坐标如下： 坐标值 -5 -4 -3 -2 -1 0 1 2 3 4 5 -5 13.6 -8.2 -14.8 -6.6 1.4 0 -3.8 1.4 13.6 16.8 0 -4 -8.2 -15.8 -7.9 2.2 3.8 0 0.6 7.3 10.1 0 -16.8 -3 -14.8 -7.9 2.5 5.8 2.3 0 2.7 5.1 0 -10.1 -13.7 -2 -6.6 2.2 5.9 3 -0.3 0 1.9 0 -5.1 -7.3 -1.4 -1 1.4 3.8 2.3 -0.3 -0.9 0 0 -1.7 -2.7 -0.6 3.8 0 0 0 0 0 0 0 0 0 0 0 0 1 -3.8 0.6 2.7 1.7 0 0 0.9 0.3 -2.3 -3.8 -1.4 2 1.4 7.3 5.1 0 -1.7 0 0.3 -3.1 -5.8 -2.2 6.6 3 13.6 10.1 0 -5.1 -2.7 0 -2.3 -5.8 -2.5 7.9 14.8 4 16.8 0 -10.1 -7.3 -0.6 0 -3.8 -2.2 7.9 15.8 8.2 5 0 16.3 -13.6 -1.4 3.8 0 -1.4 6.6 14.8 8.2 -13.6 要求： 画出该曲面工件的图形 在已知相邻的横纵坐标之间分别插入三个分点，用 interp2 命令计算出所有点处的竖坐标，画出相应的插值曲面。 用不同方法求出该曲面工件表面积的近似值 ② 问题分析：本题是一道典型的插值问题，第一问可以用指令迅速画出图形。第二问主要难点在于 interp2 命令的应用。第三问依据数学方法求解即可。 ③ 程序设计流程图： 1234567891011121314151617181920212223242526272829x=-5:1:5;y=-5:1:5;[xx,yy]=meshgrid(x,y);zz=Sheet1;figure(1);mesh(xx,yy,zz);figure(2)xb=-5:0.25:5;yb=-5:0.25:5;[xxb,yyb]=meshgrid(xb,yb);zzb=interp2(xx,yy,zz,xxb,yyb,'cubic');mesh(xxb,yyb,zzb)[Fx,Fy]=gradient(zz,0.001,0.001);S=sqrt(1+Fx.^2+Fy.^2)*0.000001.*( ~isnan(zz) ) ;sum(S(~isnan(S))) ④ 结果分析与结论： 原曲面： 插值后的曲面： 算得的曲面面积： ans =0.7669 ④ 总结与体会：通过本题，我们小组对二维插值问题有了一定的了解。 实验任务 4 ① 实验问题：煤矿的储量估计，下表给出了某露天煤矿在平面矩形区域(1100mX700m)上，在纵横均匀的网格交点处测得的煤层厚度(单位:m)(由于客观原因，有些点无法测量煤层厚度，这里用/标出），其中的每个网格都为（100mX100m)的小矩形，试根据这些数据,来估算出该矩形区域煤矿的储藏量(体积） A B C D E F G H I J K 1 / / 12.5 13.5 17.2 / 8.8 14.7 8.0 13.0 / 2 / / / 15.6 18.2 13 6.4 8.9 9.2 11.7 / 3 / 12 13.5 13.5 17.8 16.9 13.2 / / / / 4 7.5 12.6 14.9 18.7 17.7 17.5 14.7 13 / / 6.5 5 8.9 7.8 12.4 13.5 15.7 17.6 11.7 9.6 9.2 9.5 8.6 6 / / / 13.7 13.6 16.5 12.5 8.7 9.7 / / 7 / / 8.6 11.8 12.5 11.3 13.4 / / / / ③ 问题分析：本题与之前的例题并无不同，关键在于如何化归。 ③ 程序设计流程图： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849x=0:100:1000;y=0:100:600;z=[14.2,14.1,12.5,13.5,17.2,12.9,8.8,14.7,8.0,13.0,10.3;19.1,17.9,16.7,15.6,18.2,13,6.4,8.9,9.2,11.7,7.0;12.4,12,13.5,13.5,17.8,16.9,13.2,16.5,17.1,17.7,18.3;7.5,12.6,14.9,18.7,17.7,17.5,14.7,13,9.9,7.6,6.5;8.9,7.8,12.4,13.5,15.7,17.6,11.7,9.6,9.2,9.5,8.6;8.2,9.3,11.7,13.7,13.6,16.5,12.5,8.7,9.7,7.6,9.5;8.1,10.8,8.6,11.8,12.5,11.3,13.4,11.0,8.4,5.0,0.88];[x0,y0]=meshgrid(0:1:1000,0:1:600);z1=interp2(x,y,z,x0,y0,'linear');z2=interp2(x,y,z,x0,y0,'cubic');z3=interp2(x,y,z,x0,y0,'spline');%surf(x0,y0,z1)%surf(x0,y0,z2)surf(x0,y0,z3)shading interp;for i=1:601for j=1:1001%M(i,j)=z1(i,j);%M(i,j)=z2(i,j);M(i,j)=z3(i,j);endendsum(sum(M)) ④结果分析与结论： 第一种插值得到的曲面: 储量估计： ans = 7.5956e+006 第二种插值得到的曲面： 储量估计： ans = 7.6190e+006 第三种插值值得到的曲面: 储量估计： ans =7.6076e+006 5 总结与体会：本次实验，我们运用了三种不同的插值法来求解，实际所得结果相差不大，说明插值结果与实验比较吻合。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"matlab","slug":"matlab","permalink":"https://renzehua1998.github.io/tags/matlab/"}]},{"title":"2018 西安交通大学数学建模竞赛","date":"2018-05-03T12:00:00.000Z","path":"2018/05/03/数学建模校内赛/","text":"大一下数学建模校内赛论文（二等奖存档） 陆基导弹打击航母的数学建模问题 摘要 本文主要研究陆基反舰导弹打击航母的动态轨道问题。为了精确快速打击敌方航母，同时避免导弹被敌方反导系统拦截，需要制定科学合理的进攻路线。通过对导弹发射过程的动态分析，并依据我国现役陆基反舰导弹（如鹰击 18）的各项参数，建立了一种适宜的轨道模型，使用 MATLAB 求解，得到了适合的轨道。 针对问题一：由于导弹发射点与航母所在点经纬度相差较小，故可以将地面其近似为平面求解。将导弹发射分为三个阶段：初始抛物线阶段、中段、末段加速阶段。中段起始于抛物线顶点，再细分为三个阶段：向下抛物线阶段、竖直方向减速阶段（最终竖直方向减速为 0）、超低空巡航段（为使导弹避开拦截，采用超低空巡航模式，高度约为 60m）。在末段从原速度加速到 1000m/s，打中目标。 针对问题二：在问题一的基础上，导弹在中段的巡航段进行精确制导，即导弹的速度方向始终指向航母。经过计算，导弹在 20s 内从巡航速度加速到最高速度所走的路程约为 6 至 7km，故巡航阶段结束时导弹与航母距离 d＜6km，导弹可以通过自主导航在 20s 内击中目标。由此建立导弹运动的轨迹模型，分析中段结束时导弹能否飞到距航母 6km 以内。 针对问题三：在问题一、二的基础上，不经过末段自主制导，此时判断导弹与航母距离随时间的变化（从 6000m 到末尾处）。考察若不经过导弹自主制导而依靠中段导航能否击中目标。修改初始轨道参数，判断导弹打击航母的命中率。分析导弹在其他条件影响下的命中率。 关键词：导弹制导 最优路线 导弹突防 命中概率 一、问题重述 请根据如下的已知条件和有关数据，设计导弹运行的数学模型及其命中目标的算法： 导弹发射车初始位置坐标已知为东经 120°30′0\"，北纬 27°30′0\",它可直接设为导弹打击航母的坐标系原点。 (1)由海洋侦察卫星与高空长航时无人机侦察，传输给陆基导弹发射指挥中心计算确定的航母初始位置坐标 H (X0,Y0) 为东经 123°45′0\"，北纬 25° 39′0\"。航母的舰长为 335m,航速保持为 32 节(1 节=1.852km/h),航向始终为正南方向。航母的动态坐标数据 H(X0,Y0)由卫星和无人机动态提供给指挥中心，动态监控数据记为 Hi(X(ti),Y(ti)),i=1，2，...n...指挥中心由此可建模计算航母的速度和航行轨道，同时计算导弹打击航母命中的动态运行轨道。 导弹运行的轨道曲线划分为发射段，中段和末段。发射段通常为抛物线，发射速度为 500m/s。中段可设计为不同的飞行轨道，由导弹的飞行参数制导所确定。末段最高速度可达到 1000m/s。导弹末段飞行时间般不超过 20 秒。段曲线的衔接点是光滑的(即曲线连续且一阶导数存在)，也就是说导弹飞行的轨道曲线是连续和光滑的，不能折线飞行。 导弹运行的轨道曲线需考虑应对敌方反导系统拦截问题，期望给出难以拦截的攻击曲线。 地面指挥中心提供给导弹中段轨道的制导数据; 而末段则是由导弹自主攻击航母目标。 其它复杂环境及气象等影响暂且简化 解题可局部自主创新添加合理假设. 在建模设计的算中，根据坐标计算距离时，设定地球半径为 6300km 距离的计算精度要求为 m 级。 根据以上已知数据和条件要求，请你运筹帷幄，决胜千里，创新设计出你的陆基反舰导弹打击航母的运行轨道数学模型，论述你的算法步骤。包括: 问题 1: 建立初始状态下，反舰导弹打击航母的静态轨道模型。即 t=0 时，连接导弹初始位置与航母坐标之间的轨道曲线模型。 问题 2: 在航母按照已知条件(1)给出的航向和速度的航行状态下，设计导弹飞行的中段动态模型方程和算法步骤。中段通常以发射段的抛物线顶点为起始点。 问题 3: 讨论你所设计的导弹打击航母的轨道自线的误差分析和命中率分 二、模型假设 1.假设导弹初段末高度为 10km 2.假设导弹在 75s 时启动推进器在竖直方向减速 3.假设导弹末段加速度为 70m/s2 4.假设导弹不受到其他因素（如风、电磁干扰等等） 三、符号说明 符号 意义 t1 导弹初段末时刻（s） t2 导弹开始竖直方向减速的时刻（s） t3 导弹进入超低空水平巡航的时刻（s） x1 z1 导弹初段末坐标（m） x2 z2 导弹开始竖直方向减速的坐标（m） x3 z3 导弹进入超低空水平巡航的坐标（m） k 导弹运动的总时间（s） a(x,y,z) 导弹巡航阶段追击的坐标（m） b(x,y,z) 航母的坐标（m） d 导弹与航母的距离（m） 四、问题分析 针对问题一：将导弹发射分成初段、中段、末段，中段再细分为抛物段、减速段、巡航段。为避免被反导雷达发现，将其布置为超低空巡航。并于末段加速到 1000m/s 打击目标。 针对问题二：在第一问的基础上，在中段巡航段令导弹速度始终指向航母，建立导弹的运行模型，经过计算，导弹在 20s 内从巡航速度加速到最高速度所走的路程约为 6 至 7km，故巡航阶段结束时导弹与航母距离 d＜6km，分析导弹能否运行至距航母 6000m 以内。 针对问题三：在一二问的基础上分析导弹能否在不经过末段自主导航就成功命中目标，并分析如何修改参数能使命中精度最高。分析其他条件对命中率的影响。 五、模型建立及求解 5.1 问题 1 静态轨道 5.1.1 问题分析 图一 问题的分析过程 5.1.2 模型建立 问题一为初始条件下，求解反舰导弹弹打击航母的静态轨道模型，由于导弹发射点与航母所在点经纬度相差较小，将模型建立在在二维平面内，并且是点对点的静态模型。分三段分析导弹的飞行过程，分别为发射段，中段和末段， 其中， 中段起始于抛物线顶点，再细分为三个阶段：向下抛物线阶段、竖直方向减速阶段（最终竖直方向减速为 0）、超低空巡航段（为使导弹避开拦截，采用超低空巡航模式，高度约为 60m）。在末段从原速度加速到1000m/s，打中目标。 5.1.2.1 两点间距离模型 首先确定发射点和打击点的平面距离，将地球抽象为一个球体，两点即为球面上两点的直线距离。利用公式，设所求点 A ，纬度 β1 ，经度 α1 ；点 B ，纬度 β2 ，经度 α2。则距离 S=R·arc cos[cosβ1cosβ2cos（α1-α2）+sinβ1sinβ2]，其中 R 为球体半径。 利用 matlab 求解此直线距离。 5.1.2. 2 发射段飞行模型 根据资料表明[1]，导弹需发射到 10000m 的左右高度。故将初速度分为水平方向和竖直方向。水平速度为…√5×100,竖直方向速度为√21×100m/s （1）发射段为向上抛物线阶段。炮弹在竖直方向上做匀减速运动，竖直初速度为√20×100m/s,末速度为零。在水平方向上一直做匀速直线运动。轨迹为抛物线。 （2）向下抛物线阶段。 到最高点之后，炮弹先按原轨迹抛物线运动，仍以原加速度运动，竖直方向为自由落体运动，水平方向上，仍以原速度运动。 （3）竖直方向减速阶段 至 t=75s(时间为假设时间)时，改变运动轨迹，以向下的加速度 a=7m/s（根据资料查阅可知，导弹的减速加速度为 7m/s)水平速度不变。使至水平方向时竖直方向速度为 0。 （4）根据已知数据及轨迹分析，利用公式 x=vt-1/2at^2 及 v=at，并用 matlab 绘制出图线。 图二 发射段轨迹图线 （蓝线部分为抛物线轨迹，红线部分，改变加速度，水平速度不变，到贴近水平面的超低空飞行，以应对敌方导弹拦截。[2]） 5.1.2.3 低空巡航模型 在导弹飞行过程中，为躲避对方导弹拦截，采用超低空巡航模式，高度约为 60m）。在末段从原速度加速到 1000m/s，打中目标。 炮弹经过竖直减速阶段，竖直速度已经非常低几乎可以忽略不计。水平方向上，理论上（忽略风力，温度气象等阻力）仍是√5×100m/s 距离水平面60m/s。 进行水平的直线运动。 导弹末段飞行时间不超过 20s，且末段速度最大达到 1000m/s，所以要在水平阶段先保持 223.60m/s 的速度，水平方向上保持直线运动。经过查阅可知，导弹的加速度在加速阶段一般保持在 70m/s 左右，故水平加速度取为 70m/s，末段从 223.60m/s 加速到 1000m/s 。 利用公式 v=at 及 matlab 绘图软件求得总体轨迹图线 图三 全过程打击图线 5.2 问题 2 设计导弹飞行的中段动态模型方程和算法步骤 5.2.1 问题分析 图四 问题的分析过程 5.2.2 模型建立 要求在已知航向和速度的航行状态下，设计导弹飞行的中段动态模型方程该问题的核心解决思路是导弹时刻对准敌机以及导弹尽量在超低空掠海航 线上行驶会尽可能避免雷达的侦测和反导系统的拦截。 5.2.2.1 发射段飞行模型 首先第一阶段的函数与问题一相同，从第一段抛物线顶点开始进行第二阶段，首先是开口向下抛物线改变轨迹，然后是开口向上抛物线让导弹的竖直速度降低为 0.两段抛物线轨迹为： 1.x=Vxt;z=Vzt-(1/2)(9.8)t^2 2.x=Vxt;z=z2+Vz2(t-t2)+0.5a(t-t2)^2 5.2.2.2 定向追击模型 然后进行中段定向追击。中端追击过程中，需要导弹和航母的实时坐标，而导弹的方向及坐标由航母确定。考虑到xy平面是以静态航母和导弹初始位置连线为X轴，而航母运动方向为正南并不以x轴衡量，故需建立南方向与x轴y轴的方向关系。 在北纬27.5°的纬度圈上，导弹与航母的经度差为3.25°。由RCos27.5°求得纬度圆半径为5651.2km。则该经度差对应球面上的距离为 2π5651.23.25/360=320.39km。由此得出正南方向与已知坐标系的想轴夹角的正弦值为0.8466，即夹角近似为58°。角度已知，则航母的正南方向运动能正确体现在坐标轴分量上。 假设航母航行距离极短，则此时地球可视为平面，利用x=v*t，求得航母航向的距离，得到其位置坐标，从而求得航母与导弹之间的实时距离。 这是超低空巡航的两个重要参数。通过初始状态下导弹坐标，实时母舰坐标推导出导弹到母舰的方向向量从而确定导弹接下来的轨迹与方向，从而实现导弹任意时刻朝向母舰，同时，为保证模型简化，并最终在第二阶段结束时靠近母舰使与其距离不大于 6km 5.2.2.3 主要转折点坐标 重要点 k a b d 第二阶段起点 k=46 a(334392.97,5403.27,10202.11) b(0,740.80,0) d=334581.05 两抛物线交点 k=5 a(328586.85,8841.44,6362.48) b(0,1212.18,0) d=328736.98 超低空巡航起点 k=116 a(320401.84,13688.29,78.35) b(0,1876.69,0) d=320619.49 超低空巡航终点 k=1528 a(5442.74,23686.95,1.07) b(0,25123.20,0) d=5852.66 表一：主要转折点坐标 5.2.2.4 模型示意图 图五 全程模型 5.3 问题 3 误差分析 5.3.1 分析无自主制导 d&lt;6000m 时 d 随 k 的变化 将停止条件设为导弹高度小于 0，此时判断导弹与航母距离随时间从 6000m 到末尾处的变化： k=1528 a(5442.74,23686.95,1.07) b(0,25123.20,0) d=5852.66 k=1529 a(5226.70,23744.61,1.02) b(0,25139.66,0) d=5633.28 k=1530 a(5010.83,23802.91,0.98) b(0,25156.12,0) d=5413.94 k=1531 a(4795.13,23861.87,0.94) b(0,25172.59,0) d=5194.65 k=1532 a(4579.63,23921.51,0.90) b(0,25189.05,0) d=4975.41 k=1533 a(4364.32,23981.88,0.86) b(0,25205.51,0) d=4756.22 k=1534 a(4149.23,24043.00,0.81) b(0,25221.97,0) d=4537.09 k=1535 a(3934.36,24104.90,0.77) b(0,25238.44,0) d=4318.01 k=1536 a(3719.74,24167.64,0.73) b(0,25254.90,0) d=4098.99 k=1537 a(3505.37,24231.24,0.69) b(0,25271.36,0) d=3880.03 k=1538 a(3291.28,24295.78,0.65) b(0,25287.82,0) d=3661.14 k=1539 a(3077.48,24361.29,0.60) b(0,25304.28,0) d=3442.32 k=1540 a(2864.01,24427.84,0.56) b(0,25320.75,0) d=3223.58 k=1541 a(2650.89,24495.51,0.52) b(0,25337.21,0) d=3004.91 k=1542 a(2438.15,24564.38,0.48) b(0,25353.67,0) d=2786.33 k=1543 a(2225.84,24634.54,0.44) b(0,25370.13,0) d=2567.84 k=1544 a(2014.00,24706.12,0.39) b(0,25386.60,0) d=2349.45 k=1545 a(1802.68,24779.24,0.35) b(0,25403.06,0) d=2131.17 k=1546 a(1591.97,24854.08,0.31) b(0,25419.52,0) d=1913.01 k=1547 a(1381.96,24930.85,0.27) b(0,25435.98,0) d=1694.99 k=1548 a(1172.75,25009.81,0.23) b(0,25452.44,0) d=1477.11 k=1549 a(964.53,25091.32,0.19) b(0,25468.91,0) d=1259.41 k=1550 a(757.53,25175.89,0.15) b(0,25485.37,0) d=1041.92 k=1551 a(552.13,25264.27,0.11) b(0,25501.83,0) d=824.68 k=1552 a(349.00,25357.73,0.07) b(0,25518.29,0) d=607.77 k=1553 a(149.58,25458.88,0.03) b(0,25534.76,0) d=391.33 k=1554 a(-40.69,25576.34,-0.01) b(0,25551.22,0) d=175.78 表二：导弹与航母距离随时间从 6000m 到末尾处的变化 由表格得知，当导弹距水面为 0.03m 时，距航母仍有 391.33m，大于航母的舰长 335m，故若无末段自主制导，将无法击中航母。 5.3.2 分析命中精度与 t2 的关系 改变飞行参数再次运行，此时将初段抛物线轨道参数改变，将中段竖直向下减速段起始时间 75s 进行修改，在不同情况下的运行结果如下表： t2=60s k=1552s a(151.59,25440.48,1.54) b(0,25518.29,0) d=394.00m t2=61s k=1553 a(-26.93,25551.16,-0.26) b(0,25534.76,0) d=192.08m t2=62s k=1553 a(-15.41,25543.97,-0.14) b(0,25534.76,0) d=205.66m t2=63s k=1553 a(-3.74,25536.95,-0.03) b(0,25534.76,0) d=219.27m t2=64s k=1553 a(8.07,25530.09,0.07) b(0,25534.76,0) d=232.93m t2=65s k=1553s a(20.03,25523.34,0.15) b(0,25534.76,0) d=246.66m t2=70s k=1553s a(82.19,25490.81,0.35) b(0,25534.76,0) d=316.81m t2=71s k=1553s a(95.18,25484.43,0.34) b(0,25534.76,0) d=331.28m t2=72s k=1553s a(108.40,25478.06,0.30) b(0,25534.76,0) d=345.94m t2=73s k=1553s a(121.86,25471.68,0.24) b(0,25534.76,0) d=360.82m t2=74s k=1553s a(135.58,25465.30,0.15) b(0,25534.76,0) d=375.94m 表三：打击精度随 t2 的变化 由表可知，当 t2=61s 时打击精度最高，二者距离仅为 192.08m 导弹末端命中概率分析[3]：反舰导弹末段自主制导的命中概率，取决于制导雷达捕捉到目标的可能性，它与导弹雷达搜索区能覆盖到目标的概率与雷达能收到回波的概率有关。即 P 捕捉=P 覆盖·P 发现.且现代雷达比较灵敏，只要覆盖就能搜索到目标，故有 P 捕捉=P 覆盖，即 P 发现.=1。 为方便分析,将导弹搜索区域简化成矩形区域，且设导弹的自控终点是一个 沿 X 轴和 Z 轴方向分布的二维随机变量,服从平面上的正态分布律且互不相关时,计算 P 捕捉的公式可以简化为 式中：a 为导弹搜索区的距离半长，单位(m);b 为导弹搜索区的侧向半宽,单位(m);Ex 为纵向综合散布概率偏差,单位(m);Ez 为侧向综合散布概率偏差,单位(m);mx 为目标运动和常值风干扰引起的纵向概率偏差,单位(m);mz 为目标运动和常值风干扰引起的侧向概率偏差,单位(m)。 由此可以计算出命中概率。 六、模型评价与改进 该型未将风速及不同高度处的空气阻力考虑在内，同时在路程及范围较小情况下未考虑地心引力。会对模模型的精确度造成一定误差。除此之外，假设不变的参量还有母舰运行时距离极小，将距离与纬度近似成为正比关系；角度运算中将小数位四舍五入或忽略误差等。在算法方面，卫星及无人机的传输数据有一定的时间延后性，且进行导弹永远朝向母舰的拟合过程中，取 1 秒为间隔时间也对最终第三阶段的自主攻击增大了误差的可能性。 但总的来说，该模型最大的优点是没有使用复杂曲线的方式来闪避反导拦截而是采用科技上惯用的躲避方式，使雷达不易勘测。除此之外，轨迹变换，速度 变化，点对点定向等处理方式也体现了数学模型省略不必要因素，简单明了的表达被表达物体运行特性的特点。同时，该模型对一些未知参量的选取也尽可能满足现实和近期的科技发展。例如，在第一阶段抛物线的顶点高度设置为 10km，该高度为对流层高度，并且是一般陆基导弹的第一阶段能达到的高度。并且第二阶段整体的时间设定 6 到 8 分钟也符合现实陆基导弹攻击的第二阶段时间。这样的处理方式让依照时间推算出的速度变化有了更高的可信度。同时使超低空巡航阶段的速度不变有了一定得依据。最后，现在一般的路基导弹的第三阶段自主攻击时间一般为 20 秒左右或更少，这也是第二阶段拟合速度，高度，距离的依据。 但该模型的缺点是远距离能避开雷达的侦测使导弹能相对安全的接近母舰附近，但近距离的反导拦截仍不能避免，该导弹在刚进入三阶段开始自主攻击时，有被拦截的危险。所以在二阶段的末端应增加一个小阶段，该阶段拥有较为复杂的轨迹而不是简单的点对点定向接近母舰。初步思路为在点对点定向之后导弹再次做类似于开口向上的抛物线运动在 z 轴方向远离母舰同时在 xy 轴方向靠近，闪避反导系统拦截，再做轨迹为开口向下的抛物线运动然后攻击母舰，期间导弹加速。这样的设计给雷达的侦测带来了困难同时也使一旦被雷达成功侦测后的闪避提供了更大可能，增加了成功率。同时，这一阶段的缓冲，也能让导弹更精确的攻击到舰体。 七、参考文献 [1] Honeywell，《世界七大反舰导弹：祖国排名第一》， https://m.baidu.com/paw/c/m.tiexue.net/touch/thread_8238501_1.html%3F mip ，2018.05.01。 [2] 飞行员梦，《已发射的导弹如何反拦截》， https://zhidao.baidu.com/question/519956706.html ，2018.04.30。 [3] 聂永芳、冯林平、施建礼，新误差分析方法对反舰导弹作战使用的影响，《舰船电子工程》，卷期号：2012 年第七期，总第 217 期，57-59，2012 附录 问题一程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263A=25.65*pi/180;B=123.75*pi/180;C=27.5*pi/180;D=120.5*pi/180;S=6300000*acos(cos(A)*cos(C)*cos(B-D)+sin(A)*sin(C));Vx=sqrt(5)*100;Vy=sqrt(20)*100;t1=Vy/9.8; x1=Vx*t1; y1=Vy*t1-0.5*9.8*t1^2; x2=Vx*75;y2=Vy*75-0.5*9.8*75^2;t2=75;t=0:t2;x=Vx*t;y=Vy*t-0.5*9.8*t.^2;plot(x,y,'b');hold ona=7;Vy2=Vy-9.8*75;t3=t2-Vy2/a;t=t2:t3;x=Vx*t;y=y2+Vy2*(t-t2)+0.5*a*(t-t2).^2;plot(x,y,'r');hold onVy3=Vy2+a*(t3-t2);x3=Vx*t3; y3=y2+Vy2*(t3-t2)+0.5*a*(t3-t2)^2;fprintf('x1=%.4f y1=%.4f t1=%.4f\\nx2=%.4f y2=%.4f t2=%.4f Vy2=%.4f\\nx3=%.4f y3=%.4f t3=%.4f Vy3=%.4f \\n ',x1,y1,t1,x2,y2,t2,Vy2,x3,y3,t3,Vy3) Vx=223.6068;t_5=(1000-Vx)/70; x_5=Vx*t_5+0.5*70*t_5^2;t4=(S)/Vx;x4=Vx*t4t=t3:50:t4;x=Vx*t;y=y3;plot(x,y,'b*')hold ont5=t4+t_5;t=t4:t5;x=x4+Vx*(t5-t4)+0.5*70*(t5-t4)^2;plot(x,y,'r')xlabel('Éä³Ì/m');ylabel('¸ß¶È/m');title('µã¶Ôµã´ò»÷'); 问题二程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127A=25.65*pi/180;B=123.75*pi/180;C=27.5*pi/180;D=120.5*pi/180;S=6300000*acos(cos(A)*cos(C)*cos(B-D)+sin(A)*sin(C));Vx=sqrt(5)*100;Vz=sqrt(20)*100;t1=Vz/9.8; x1=Vx*t1; z1=Vz*t1-0.5*9.8*t1^2;t2=75;x2=Vx*t2; z2=Vz*t2-0.5*9.8*t2^2;aa=7;Vz2=Vz-9.8*75;t3=t2-Vz2/aa;x3=Vx*t3;z3=z2+Vz2*(t3-t2)+0.5*aa*(t3-t2)^2;Vz3=Vz2+aa*(t3-t2);r=6300000*sin(27.5-25.65);X=(123.75-120.5)/360*2*r*pi;Y=(27.5-25.65)/360*2*6300000*pi;m=Y/S;n=X/S;k=0;v=32*1852/3600;for t=0:1:t1x=X-n*Vx*t;y=m*Vx*t;z=Vz*t-0.5*9.8*t^2;plot3(x,y,z,'b*');hold ons=v*t;plot3(0,s,0,'b*');%pause(0.2);k=k+1;d=sqrt(x^2+(y-s)^2+z^2);fprintf('k=%.0f a(%.2f,%.2f,%.2f) b(0,%.2f,0) d=%.2f\\n',k,x,y,z,s,d);xlabel('27.5¡ãÎ³Ïß/m');ylabel('123.75¡ã¾-Ïß/m');zlabel('´ò»÷¸ß¶È/m');title('´ò»÷¹ý³Ì');endfor t=t1:1:t2x=X-n*Vx*t;y=m*Vx*t;z=Vz*t-0.5*9.8*t^2;plot3(x,y,z,'m*');hold ons=v*t;plot3(0,s,0,'b*');%pause(0.2);k=k+1;d=sqrt(x^2+(y-s)^2+z^2);fprintf('k=%.0f a(%.2f,%.2f,%.2f) b(0,%.2f,0) d=%.2f\\n',k,x,y,z,s,d);endfor t=t2:1:t3x=X-n*Vx*t;y=m*Vx*t;z=z2+Vz2*(t-t2)+0.5*aa*(t-t2)^2;plot3(x,y,z,'y*');hold ons=v*t;plot3(0,s,0,'b*');%pause(0.2);k=k+1;d=sqrt(x2+(y-s)^2+z^2);fprintf('k=%.0f a(%.2f,%.2f,%.2f) b(0,%.2f,0) d=%.2f\\n',k,x,y,z,s,d);enda=[(X-n*x3),(m*x3),z3];b=[0,v*t3,0];dt=1;d=sqrt(a(1)^2+(a(2)-b(2))^2+a(3)^2);while d&gt;6000plot3(a(1),a(2),a(3),'r*');hold onplot3(b(1),b(2),b(3),'b*');%pause(0.2);k=k+1;b=b+[0,v*dt,0];e=b-a;d=norm(e); e0=e/d;a=a+Vx*dt*e0;fprintf('k=%.0f a(%.2f,%.2f,%.2f) b(0,%.2f,0) d=%.2f\\n',k,a(1),a(2),a(3),b(2),d);end","tags":[{"name":"matlab","slug":"matlab","permalink":"https://renzehua1998.github.io/tags/matlab/"}]},{"title":"职业生涯规划书","date":"2018-03-28T12:51:00.000Z","path":"2018/03/28/职业生涯规划书/","text":"大一下职业生涯规划大赛资料，被批一顿得个鼓励奖 前言 人们都说，拥有一个好的目标相当于成功了一半。这句话显然有夸张的成分，但是从另一方面也反映出了职业规划对一个人的重要性。作为一名大一年级的学生，刚刚踏入大学校园的我也曾陷入迷茫。在过去的十多年中，上一个好的大学似乎成了我人生中唯一的目标，如今当这个目标实现后，我便无所适从。 我的兴趣是什么，我适合什么样的工作，我该怎样发展自己，在夜深人静的时候我也曾问过自己这样的问题。父母把我养育成人的不易，他们的殷切期望时时刻刻在提醒着我要努力再努力，最终成为一个能够独当一面的人。不过，我应该如何确定自己的目标呢？ 经过一系列系统的测试后，我找到了自己的兴趣所在，其实这些在以前也被我所知，只是专业的数据更加让人信服。我在生活中可以说是个比较内倾的人，喜欢沉浸于自己的小世界，所以，我给自己的职业定位是研发或专业技术类的工作，如软件工程师或电子技术研发人员等等。这种工作会有更高的技术与知识要求，所以我打算读研，在我研究生毕业后再工作。不过在这期间，我会不断地学习专业知识，到合适的企业实习，以求全面了解这个行业，最终走向工作岗位。 可能作为一名大一的学生，现在谈这些为时过早，不过，只有了解自己，才能不断突破挑战。我也相信，通过这次的职业发展规划，我能够找到奋斗的方向，不断进步。 自我认知 1.职业兴趣 根据你最强的兴趣，可见你的特点是： 你是个对数据资料和观念思想都感兴趣的人。你非常感兴趣将各种繁多复杂的资料、数据、文件处理得井井有条，并乐意从其中探究某些事物的规律、原理和本质，这一连串资料处理及深入分析的过程会让你流连忘返，乐不思蜀。在生活中，你相对来说比较严谨、做事认真负责、细致而深入，绝不停留在事物的表层。一般来讲，事前你会有自己的计划，也喜欢按部就班地工作，从而能获得高效率。此外，你可能会对一些研究性的学习、调查或课题感兴趣，并且十分愿意亲自参与整个过程的推进。 2.职业能力 使你如鱼得水的环境：有较为完善的规章制度、稳定而高效、有一定研究性质、对人际交往不宜过多的环境。 你乐衷的活动或课程：制作图表、市场调查分析、研究数据处理等活动；计算类、统计类、测绘类课程。 你特别钟爱的专业有：统计学、数学、金融学、地理信息系统等。 你可能喜欢的职业有：市场调查员、研究助理、投资分析师、统计分析师、测绘员等 你对经济性事务不感兴趣，不好说服、影响和领导他人，因此，在职业生涯规划过程中，你可能要避免一些对领导力要求较高的发展方向，如经营管理、政府官员、外事外交等。 下表为我的综合推荐职业： 职类名称 推荐职类下的相关职业 研发 高校电子信息科学类教师、研发人员、橱窗设计师、核安全工程师、物理学家、生物学研究者、农业工程师、石油工程师、大气科学家、化学工程师、船舶设计师、船舶工程师、工业健康和安全工程师 专业技术 设备工程师、信息管理员、信息技术员、信息支持人员、仪器校准技术员、火灾调查员、摄影测量人员、系统分析师、翻译、计算机技术支持专家、电子工程技术员、民用工程项目技术人员 艺术 作家、作词、编辑、记者 3.个人特质 综合你在四个维度上的倾向，总体来说，你的类型是： 博爱型——基于博爱的理想，设身处地的关怀他人 你的特点: • 你有计划、有条理，喜欢遵照固有的模式处理问题，乐于探求独特的方式以获得有意义的成长和发展。 • 你通过认同和赞扬与别人进行沟通，具有很强的说服力，你可以成为伟大的领导者。 你的贡献被人尊敬和推崇。他人能随时体会到你的善良和体贴，但不太了解你，因为你总是做的含蓄和复杂。事实上你是非常重感情，忠于自你价值观，有强烈的愿望为大家做贡献，有时候你也很紧张和敏感，但表现的深藏不露；你倾向于拥有小范围的而深长久远的友谊。 • 你喜欢独处，性格复杂，有深度，是独立的思考者。你忠诚、有责任心，喜欢解决问题，通常在认真思考之后行动。 • 你在同一时间内只专注一件事情，你独具洞察力，相信灵感，努力寻求生活的意义和事件的内在联系。 • 你有坚定的原则，就算被别人怀疑，也相信自己的想法和决定，依靠坚韧不拔取得成功。生活中的你： • 你信奉有爱就有这个世界。 • 你在社交场合会感到不太自如。 • 你的衣着倾向于保守，很少会穿戴浮华，一些时候是因为你节俭朴素，也有时候你会觉得昂贵的服装与其说是需要，还不如说是一种奢侈。 • 你在人际交往中并不活跃，喜欢一对一的关系，通常是很好的倾听者，能够让人觉得踏实和有情有义。 4.职业价值观 你最突出的职业价值观是工作条件、支持满足。 工作条件:你非常希望获得有充分保障的工作(包括拥有良好的工作条件)，比如能够在一个比较安全和舒适的环境中工作，能够获得应有的报酬，能够有自主决断的可能性等。 而且还希望工作具有多样性，能够在工作的范围内做不同的事情把“工作条件”视为自己重要的职业价值观的你，希望的工作是： 1.内容丰富，在工作的时间里有充实的工作可做； 2.拥有充分的金钱或物质回报； 3.有保障的，稳定的； 4.能够有比较丰富的工作内容，而不是简单重复劳动； 5.拥有一个自由、舒适的环境； 6.有固定的较长假期，可以保证定期的休闲娱乐活动； 7.地处交通便利的位置。 支持满足:期望在职业中，获得管理层的支持，比如获得充分的培训机会，能够在单位的规定范畴内获得应有的待遇把“支持满足”视为自己重要的职业价值观的你，希望自己的工作： 1.能够在一个具有规范约束的背景下有序而顺利进行； 2.能够获得公司的合理反馈，获得应有的资源； 3.能够及时获得上级的支持与肯定； 4.过程中有比较好的培训机会，从而更好地胜任自己的工作； 5.有一个合情理的、具有理解力的上司。 追求成就:希望获得的工作，是能够看到及时的成果展现，并体验到可能的成就体验。即工作的追求是一种自你实现，而并非外在特质利益的满足 赞誉赏识:对职业的追求，是能够使自己获得充分的领导力提升机会，并拥有充分的权威，能够对他人的工作提供指导，并且这个职位是富有社会声望的 注重关系:期望工作的内容是能够给予别人帮助，并希望在这样的职位上同事之间关系融洽，大家都有积极的道德观念和社会服务意识 崇尚独立:你是一个期望在工作中能够独立工作、独立决策，而且能够表现出自己的创新，发挥自己的责任感、自主性的人。而且你能够以自你监督的形式使自己的工作按照自己的计划顺利进行。 职业分析 1.家庭条件 我出生于一个不太富裕的工人家庭，属于小康的类型。父母的社会资源有限，所以之后的发展主要还是看我自己的努力。在就业择业方面，父母充分尊重我的意见，给我以最大的自我发展空间。 2.学校环境分析 我所就读的西安交通大学是一所一流名校，在国家“双一流”的建设当中也名列前茅。交大的学风淳朴，学术氛围浓厚。 我就读于电信学院的自动化专业，现在可以说是比较热的专业，据说我们专业会改名为人工智能及自动化。在人工智能如此火的今天，选择这条路有机遇也有挑战。我们专业在全国的排名在前十名，在同专业当中竞争力也是很强的。 而且，学校于学院也有许多竞赛与活动，比如说大学生创新创业大赛，挑战杯，学院有各种各样参与科研的机会。我也准备在大二或大三参加一次这样的比赛以提升自己的能力。 3.社会环境分析 西安位于丝绸之路经济带的起点，一带一路的沿线国家，无论是从国内需求或是未来区域经济合作的角度分析，这些国家对于基础设施建设的需求均极其旺盛。而且也会催生各种行业的振兴，所以说西安是一个潜力相当大的地方。 而且，随着交大创新港的建成，未来这里将集聚不少于3万人的科技创新创业人才，吸引不少于500家国内外知名企业在此设立研发中心、技术创新联盟。这为你的发展提供了多种可能。 从就业形势上来看，2017届毕业生中，有40.8%的应届毕业生认为就业很难、就业形势严峻，同比去年上升了4.3%。在较大的就业压力下，更多毕业生出现了延迟就业的现象，在调查中选择“慢就业”的应届生比例高达9.8%。 随着越来越多的“95后”走出校园，他们对就业的选择更加多元化，也更加青睐工作与兴趣相结合。但不可否认的是，这也反映出毕业生感知到了当前就业形势的严峻性，又不愿屈就不喜欢的工作，因此选择了用“慢就业”来暂时规避现实的竞争。 在这种大环境下，有一个明确的目标就显得尤为重要，当我拥有一个较清晰的目标并为之付出努力时，就已经在走向成功了。 大学生择业前不应该首先考虑经济收入、生活环境、工作稳定性，而更应该注重个人发展机会和专业知识的应用，以更加长远的眼光看待自己的事业，不只局限在眼前。较受用人单位和社会认可青睐的大学生包括以下几点：思想素质较高;有事业心和责任感;有吃苦精神;基础扎实、知识面宽、外语水平高、懂计算机知识;动手能力强;懂专业、会管理、善交际。 当前影响就业的几个因素： ⒈ 经济增速放缓，对就业的拉动效应减弱。⒉ 城镇化中农村劳动力转移就业压力大。⒊ 新兴产业的加快发展影响到就业水平。⒋ 区域经济格局调整特别是中西部地区加快发展导致劳动力流动新变化。⒌ 企业用工成本的承受力与劳动者高期望值的矛盾导致供求双方难以对接。⒍ 人口结构变化使劳动力供给增长放缓。 4.职业环境分析 软件工程师发展前景 计算机软件领域是一个包括系统软件、linux应用、中间件软件、嵌入式软件、数据库软件、财务及企业管理软件、教育软件、游戏软件、语音应用软件等在内的复杂的集合体。随着计算机的大力普及，计算机应用已深入各行各业，在大大提高效率的同时，也在深刻影响着人们的生活。计算机的深入应用离不开软件，软件业的发展关系到一个国家的政治和未来，软件产业将成为21世纪拥有最大产业规模和最具广阔前景的新兴产业之一。软件开发行业的前景，归纳为以下几点： 1、高成长：全球软件市场以每年13%的平均速度增长，远大于世界经济的平均增长速度; 2、高智力投入：所需固定资产少，生成成本少，纯脑力活动为主; 3、服务性强：软件产品售后服务工作量大，而且软件开发商在做系统集成时必须对用户的需求有深入的了解，在实施项目的过程中得到用户的密切配合，因此兼具制造业和服务业的特点; 4、高附加值：软件的相对附加值高，一个软件产品诞生后的附加值大约是CPU的2倍、存储芯片的3倍、硬盘的5倍; 5、与国民经济关系密切：软件开发行业与各行业都有关联，几乎绝大多数行业的发展都会促进软件行业的发展。因此，一般情况下，只要国民经济保持增长，软件行业就会增长。甚至当国民经济衰退时，也可以保持增长态势，所以说软件是可以做一辈子的行业; 6、全球性强：尤其因特网的出现，给软件开发行业带来巨大的发展机遇，也使得软件产品可以在很短的时间内销售到全球，同时，软件开发又是一个受名族文化、风俗、习惯影响较小的产业。 电子信息产业人才需求分析 电子信息产业是一个高密度型产业，其核心竞争力是高科技人才的竞争。“十二五”期间，电子信息产业依靠创新驱动，加快转型升级，取得了丰硕的成果。然而，随着产业规模的扩大，电子信息人才尤其是高端人才紧缺，已成为制约产业跨越式发展的重要因素之一。 例如自动化设备设计工程师 岗位职责： 1、参与自动化项目方案的前期规划及后续改善检讨； 2、具备独立完成非标自动化设备机构设计的能力； 3、能够完成项目电气方面的设计工作（硬件布局/电气图纸/控制编程）； 4、擅长PLC编程、变频器、伺服系统安装调试； 5、能够独立完成设备各标准件的选型（含机构件及电控件）； 6、能够独立完成非标自动化设备的硬件成本预估； 7、具有良好的个人修养，诚实勤奋，有团队精神； 8、接受经常性国内短期出差。 任职要求： 1、大学本科及以上学历，机械设计、结构设计、机电一体化等相关专业； 2、5年以上非标设备设计经验，有独立设计非标自动化设备成功经验者优先； 3、有服装机械设计研发经验者优先； 4、有丰富的机械加工知识，对所设计的零件的可加工性及成本有清晰的概念； 5、了解常用的标准件，熟悉控制器、气动元件及电机等的选型； 6、熟练使用 AutoCAD 制图， 至少熟练使用solidworks、proe、ug等其中一种三维制图软件； 7、善于和客户进行技术沟通和交流，良好的客户服务意识和团队协作精神,有耐心和责任心。 个人计划 1. 大学目标 总体目标 总目标 大学毕业时成为一个具有丰富知识于经验的自动化专业人才，有良好的英语水平，身体健康 具体目标 努力学习，GPA排名靠前 提高自己人际交往能力 提高自己团队协作能力 有一个健康的身体 提升英语水平，能够用英语进行交流 尝试进行科研工作，并且取得一定的成绩 培养自己丰富的兴趣爱好 详细计划 每天保证充足的学习时间 经常参加志愿活动或学生会活动 经常锻炼自己的英语，如听听力、用英语交流等等 多锻炼身体，提高自己的体育水平 了解所在学院的科研工作 参与社团活动，培养兴趣 具体实施方案 年级 学期 目标 大一 下学期 考过四级，参加数学建模大赛，培养自己的数学思想，下学期学科排名赶上去，学习必要的技能（office，C语言，matlab等等） 大二 上学期 考过六级，报名参加志愿活动，参加计算机二级考试（编程、office） 下学期 参加数学建模大赛，争取取得一个好成绩 大三 上学期 报名参加大学生创业创新大赛，报名校内岗勤工助学锻炼自己，参加一些学校的科研工作 下学期 将大部分精力放在学习与科研上面，锻炼自己的科研能力 大四 上学期 找一份家教或兼职，到大企业实习，增长自己的社会经验 下学期 完成毕业设计，准备攻读研究生 2.毕业后的计划 毕业后五年发展目标 总目标 ： 毕业五年后成为行业内精英 详细目标 提高对职业的适应 提高自己的心理素质 找到适合自己的发展方向 对职业有更深层次的了解 具体目标： 找到一家公司实习，积累经验 参加从事职业的相关高层次交流会 做出一些自己的成就","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"数学实验报告","date":"2017-12-17T11:44:00.000Z","path":"2017/12/17/数学实验报告/","text":"大一上数学实验报告 第一次实验任务 编写程序，解决下列问题： 程序： 1234567891011a=1+3*i;b=2-i;a+ba-ba*ba/b a+b=3.0000 + 2.0000i; a-b=-1.0000 + 4.0000i; a*b=5.0000 + 5.0000i; a/b=-0.2000 + 1.4000i 程序： 12345x=-4.5*180/pi;y=7.6*180/pi;sin(abs(x)+y)/sqrt(cos(abs(x+y))) 答案：0 - 2.4840i 程序： 12345x=1295330000;y=0.0107;renkoushu=x*(1+y)^10 答案：1.4408e+009 程序1： 12345678910111213141516171819x=0:0.1:10;y1=sin(x);y2=cos(x);y3=exp(x);y4=log(x);xlabel(&#x27;x&#x27;)ylabel(&#x27;y&#x27;)plot(x,y1,&#x27;r*-&#x27;,x,y2,&#x27;b*-&#x27;,x,y3,&#x27;g*-&#x27;,x,y4,&#x27;m*-&#x27;)title(&#x27;all&#x27;)axis([0,10,-2,5]) 程序2： 12345678910111213x=0:pi/10:2*pi;y1=sin(x); y2=cos(x);y3=exp(x); y4=log(x);subplot(2,2,1); plot(x,y1,&#x27;bo-&#x27;)subplot(2,2,2); plot(x,y2,&#x27;R*:&#x27;)subplot(2,2,3); plot(x,y3,&#x27;g+&#x27;)subplot(2,2,4); plot(x,y4,&#x27;mp&#x27;) 答案：（1） （2） 5、画出半径为2的圆的图形 程序： 123ezplot(&#x27;x^2+y^2-4&#x27;,[-3,3,-3,3])axis equal 答案： 6、随机生成一个3x3矩阵A及3x2矩阵B，计算（1）AB，（2）对B中每个元素平方后得到的矩阵C，（3）sinB，（4） A的行列式，（5）判断A是否可逆，若可逆，计算 A的逆矩阵，（6）解矩阵方程AX=B，（7）矩阵A中第二行元素加1，其余元素不变，得到矩阵D,计算D。 程序： 1234567891011121314151617181920212223A=rand(3,3)B=rand(3,2)A*BC=A.^2sin(B)det(A)if det(A)~=0 inv(A) endX=A\\BA(2,:)=A(2,:)+1;D=A 结果： A = 0.8147 0.9134 0.2785 0.9058 0.6324 0.5469 0.1270 0.0975 0.9575 B = 0.9649 0.9572 0.1576 0.4854 0.9706 0.8003 AB = 1.2004 1.4460 1.5045 1.6116 1.0673 0.9352 C = 0.6638 0.8343 0.0776 0.8205 0.3999 0.2991 0.0161 0.0095 0.9168 sinB= 0.8220 0.8176 0.1570 0.4665 0.8252 0.7176 Det(A)= -0.2767 Inv(A)= -1.9958 3.0630 -1.1690 2.8839 -2.6919 0.6987 -0.0291 -0.1320 1.1282 X = -2.5775 -1.3591 3.0365 2.0130 1.0462 0.8110 D = 0.8147 0.9134 0.2785 1.9058 1.6324 1.5469 0.1270 0.0975 0.9575 7、设\\(y=(x^2 + e^xcosx+[x])/x\\),分别计算\\(x=1, 3, 5, 7.4\\)时\\(y\\)的值。其中\\([x]\\)表示\\(x\\)的取整函数。 程序： 123x=[1,3,5,7.4];y=(x.^2+exp(x).*cos(x)+round(x))./x 答案：y =3.4687 ，-2.6282， 14.4198，105.2995 8、已知某地区1-12月份的平均气温为5，8，13，20，25，28，31，33，27，24，19，10，请绘图表示。 程序： 1234567x=1:1:12y=[5,8,13,20,25,28,31,33,27,24,19,10]plot(x,y,&#x27;*b-&#x27;)axis([1,12,0,35]) 答案： 第二次实验任务： 某大学本科生就业情况如下：458人考入研究生，60人签到外企或合资企业，184人签到国营大企业，87人签到私人企业，13人自主创业，画出饼图表示之； 程序： 123x=[458 60 184 87 13];pie(x) 求极限 程序： 12345syms x afx=((x-a)/(x+a))^x;limit(fx,x,inf) 答案：exp(-2*a) 求极限 程序： 12345syms xfx=tan(x)^(1/log(x));limit(fx,x,0,&#x27;left&#x27;) 答案：e 设 程序： 1234567syms x ty=(1+1/x)^(2*t*x);ft=limit(y,x,inf);diff(ft,x) 答案：0 展开多项式； 程序： 12345syms x a by=(a+1)^3+(b-1)^2+a+2*b;expand(y) 答案：y=a^3 + 3a^2 + 4a + b^2 + 2 分解因式 程序： 12345syms xy=x^5-3*x^4+2*x^2+x-1;factor(y) 答案：(x - 1)(x^4 - 2x^3 - 2*x^2 + 1) 求方程的根 程序： 12345syms xy=x^3-2*x+1;solve(y) 答案： x= 1； - 5^(1/2)/2 - 1/2；5^(1/2)/2 - 1/2 程序： 12345syms xy=sym(&#x27;sqrt(x+sqrt(x+sqrt(x)))&#x27;);diff(y) 答案：((1/(2x^(1/2)) + 1)/(2(x + x(1/2))(1/2)) + 1)/(2*(x + (x + x(1/2))(1/2))^(1/2)) 求不定积分 程序： 12345syms xy=sym(&#x27;1/(sqrt(2*x+3)+sqrt(2*x-1))&#x27;);ny=int(y) 答案：ny = -(((3^(1/2) - (2x + 3)^(1/2))(184x - 33^(1/2)(2x - 1)^(3/2) - 403^(1/2)(2x + 3)^(1/2) - 33^(1/2)(2x + 3)^(3/2) + 9(2x - 1)^(3/2)i + (2x + 3)(3/2)i + 63(1/2)(2x + 3)i - 93^(1/2)(2x - 1)(2x + 3)^(1/2) + 84 + 243(1/2)i + 63(1/2)(2x - 1)i - 48(2x + 3)^(1/2)i + 3(2x - 1)(2x + 3)^(1/2)i))/6 - ((2x - 1)^(1/2)(3^(1/2) - (2x + 3)(1/2))(243(1/2) + 43^(1/2)(2x + 3)(1/2)i - 22xi - 60(2x + 3)^(1/2) + 93(1/2)(2x + 3) + 15i))/6)/((3^(1/2) + (2x - 1)^(1/2) - (2x + 3)^(1/2) - i)(3^(1/2) - (2x - 1)^(1/2) - (2x + 3)^(1/2) + i)^3) 程序： 12345syms xy=1/(1+cos(x));int(y) 答案：tan(x/2) 10 求定积分 程序： 12345syms xy=1/(x*sqrt(log(x)*(1-log(x))));int(y,x,exp(1/2),exp(3/4)) 答案： 4*atan(((1-log(1856295125090727/1125899906842624))^(1/2)-1)/log(1856295125090727/1125899906842624)^(1/2))-4*atan(((1-log(595882530372511/281474976710656))^(1/2)-1)/log(595882530372511/281474976710656)^(1/2)) 解方程组 程序： 1234567syms x yf1=sym(&#x27;2*x+y-8&#x27;);f2=sym(&#x27;x-3*y-1&#x27;);[x,y]=solve(f1,f2) 答案：x =25/7 y =6/7 求和 程序： 123456789s=0for k=1:20 s=s+1/k^2ends 答案：s =1.5962 程序： 123syms xtaylor(cos(2*x),16,pi/6) 答案： (23^(1/2)(x - pi/6)^3)/3 - 3(1/2)(x - pi/6) - (23(1/2)(x - pi/6)^5)/15 + (43(1/2)(x - pi/6)^7)/315 - (23(1/2)(x - pi/6)^9)/2835 + (43(1/2)(x - pi/6)^11)/155925 - (43(1/2)(x - pi/6)^13)/6081075 + (83^(1/2)(x - pi/6)^15)/638512875 - (x - pi/6)^2 + (x - pi/6)^4/3 - (2(x - pi/6)^6)/45 + (x - pi/6)^8/315 - (2(x - pi/6)^10)/14175 + (2(x - pi/6)^12)/467775 - (4*(x - pi/6)^14)/42567525 + 1/2 第三次实验任务： 1、 每门课程考试阅卷完毕,任课教师都要对各班的考试成绩进行统计,统计内容包括:全班人数,总得分,平均得分,不及格的人数及90分(包括90分)以上的人数.请编制程序解决这一问题,并自给一组数据验证程序的正确性.要求:使用者在提示下通过键盘输入学生成绩,计算机自动处理后,显示需要的结果. 程序： 12345678910111213141516171819202122232425a=input(&#x27;请输入a[n]=&#x27;);[m,n]=size(a);x=0;p=0;s=0;for i=1:n x=x+a(i); if a(i)&lt;60​ p=p+1; elseif a(i)&gt;=90​ s=s+1; endendy=x/n;fprintf(&#x27;n=%.0f,x=%.1f,y=%.3f,p=%.0f,s=%.0f\\n&#x27;,n,x,y,p,s) 答案： （1） 数据：a[n]=[68 98 95 64 37 55 73 69 100 90] （2） 结果：n=10（人数）,x=749.0（总分）,y=74.900（均分）,p=2（不及格）,s=4（及格） 2、 课后习题任选2题. (1).水仙花数： 程序： 12345678910111213141516171819for a=1:9 for b=0:9 for c=0:9 m=a*100+b*10+c; if m==a^3+b^3+c^3 fprintf(&#x27;m=%.0f\\n&#x27;,m) end end endend 答案：m=153 m=370 m=371 m=407 (2).哥德巴赫猜想 程序： 12345678910111213141516171819x=input(&#x27;输入一个大于二的偶数x: &#x27;);p=primes(x);i=1;while p(i)&lt;=x/2 q=x-p(i); if any(q==p) fprintf(&#x27;%d=%d+%d\\n&#x27;,x,p(i),q) end i=i+1;end 答案：输入一个大于二的偶数x：46 46=3+43 46=5+41 46=17+29 46=23+23 3、编写猜数游戏程序： 首先由计算机随机产生一个 [1,100] 之间的一个整数，然后由用户猜测所产生的这个数。根据用户猜测的情况给出不同的提示，如果猜测的数大于产生的数，则显示 “High” ，小于则显示 “ Low ” ，等于则显示 “You won！”，同时退出游戏。用户最多有 7 次机会。 程序： 1234567891011121314151617181920212223242526272829x=round(100*rand);s=1;while s&lt;=7 a=input(&#x27;请输入这个数&#x27;);if a&gt;x fprintf(&#x27;High\\n&#x27;)elseif a&lt;x fprintf(&#x27;Low\\n&#x27;)else fprintf(&#x27;You won!\\n&#x27;) breakends=s+1;endfprintf(&#x27;game over&#x27;) 4、编写程序解决下列问题 Fibonacci数组元素满足Fibonacci规则： （1） 用循环语句形成前20个分量的数组； 程序： 123456789a(1)=1;a(2)=1;for n=1:20 a(n+2)=a(n+1)+a(n);enda(1:20) 答案： 1 至 8 列 ​ 1 1 2 3 5 8 13 21 9 至 16 列 ​ 34 55 89 144 233 377 610 987 17 至 20 列 ​ 1597 2584 4181 6765 （2） 求该数组中第一个大于10000的数. 程序： 12345678910111213a(1)=1;a(2)=1;i=2;while a(i)&lt;=10000 a(i+1)=a(i-1)+a(i); i=i+1;enda(i) 答案：10946 5、 （1）编写一个function函数，调用该函数，可以求一组数的最大值及最小值. （2）通过键盘输入一组数，利用（1）编写的function函数，得出最大最小数. 程序： 1234567function p=qiuzhi(a)n=min(a);m=max(a);p=[m,n]; 结果： qiuzhi([9,43,87,-19,56,36,-7]) ans = 87 -19","tags":[{"name":"实验报告","slug":"实验报告","permalink":"https://renzehua1998.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"matlab","slug":"matlab","permalink":"https://renzehua1998.github.io/tags/matlab/"}]},{"title":"《论语》中的君子与小人浅谈","date":"2017-11-26T01:31:00.000Z","path":"2017/11/26/《论语》中的君子与小人浅谈/","text":"大一上论语的智慧选修课论文（90存档） 《论语》中的君子与小人浅谈 作为一部著名的儒家经典，《论语》中许多道理被人们广为称道。在这本书中，孔子曾多次提到“君子”与“小人”。在当今社会，“君子”成了对一个人品行与道德的最高评价与人们所追求的目标，“小人”则成了人们避之不及的对象。那么，孔子又是怎样理解与评价这两类人呢？在《论语》中，孔子最为推崇的品格就是“仁”，那我们不妨先做一个大胆的推测，“仁”者为君子，“不仁”者为小人。 然而，这未免过于单一，对一个人的评判是多方面的，不是凭借仅仅一条就能断定的。而且，“仁”的内涵对于我们来说又太难把握。所以下面我便从易于理解的角度切入，浅谈一下自己对“君子”与“小人”的理解。 “君子”在古代，有以下几种意思：品德高尚的人、地位高高在上的人、对人的尊称、对丈夫的称谓。被大家所广泛熟知的是第一种解释。而我们在此谈到的也主要是第一种君子。《论语》在开篇就要“人不知而不愠，不亦君子乎？”钱逊先生在《论语读本》中提到：人生在世，总希望被人了解，为人所知、所用，尤其是在有了一定成就的情况下更是如此。“然而在一般情况下，不被人理解，甚至被误解的情况也时有发生。而“人不知而不愠”可以称得上是一种重要的人生态度了。从中也能印证孔子心目中“君子”指的是拥有高尚品德的人。而这与之前人们对于“君子”的理解有了不同，也就是说，是孔子促进了这个词语意义的变迁。 “小人”在古代的解释也有很多种：品德低劣的人、平民百姓、对自己的谦辞。但是有人在研究过程中认为“小人”在古代有小孩的意思，但是给出的引证却都是近现代文学作品中的说法，所以此意还有待商榷。《论语》中很少有单独提及小人的语句，偶有提及，也并非指道德败坏的人。如“唯女子与小人为难养也，近之则不逊，远之则怨。”此处的小人应该是指下人、仆人。这句话自然有其局限性。在整本书中“小人”更多是与君子共同出现形成对比的，具体例子会在下面列出。可见，孔子对于小人的含义有了进一步的理解。他对于这个词语意思的变迁也起到了重要的作用。 有这样一组数据：在《论语》中“君子”一词一共出现了107次，“小人”24次，共同出现19次，而“小人”单独出现有4次。有人经过研究认为，在春秋战国时期，君子与小人仅仅只有政治和人物身份角度的概念，而在孔子之后，才有了我们所熟知的内涵。所以说，孔子在这一词义的转变过程中起了举足轻重的作用。 那么，在孔子看来，君子与小人又有哪些区别？我们应该成为什么样的人呢？ “君子坦荡荡，小人常戚戚”。在孔子看来，君子与小人的不同之处在于君子表里如一，行事无愧于心。而小人在做事时却是表面一套，背后一套。就像成语“口蜜腹剑”中的宰相李林甫，他表面上说话像蜜一样甜，但暗地里却隐藏这害人的阴谋。他假意好心建议同僚李适向皇帝上书进言，暗地里却借此宣扬李适不怀好意，让唐太宗疏远了他。李林甫虽然凭借自己的这项“本事”做了十九年宰相，却也从此背负了骂名。与他相比，禁烟名将林则徐就显得胸怀坦荡，是一个真正的君子。他在面对各方面压力时，毅然决定禁烟销烟，在国家陷入危难之际，他写下了“苟利国家生死以，岂因祸福避趋之”这样大气磅礴的诗句，激励了无数国人。他不畏权贵，只遵从自己的内心，明白什么应该做，什么不该做，这一点值得后世每个人学习。所以说，坦荡的内心是君子的特点，我们无论做什么事，都要尽自己所能做到无愧于心。这样不仅在自己的内心中是平静的，也同样会赢得别人的尊重。 “君子怀德，小人怀土；君子怀刑，小人怀慧。”这句话说的是君子想的是道德与法纪，而小人唯利是图。但是我认为此处“小人”理解为百姓更好。追逐利益并非小人的专利，对于每一个普通人，喜欢利益、追求利益是很正常的事。正如一句古语：众生熙熙皆为利来，众生攘攘皆为利往。追求利益不可怕，可怕的是用不正当的手段获取利益。“君子爱财，取之有道”。像如今社会上那些为了赚钱不惜造假甚至危害公众安全的人，他们的行为就不是“君子之道”了，而是应当受到道德和法律的制裁。作为普通人，我们可以不必时时刻刻心里只想着他人而不计较自己的得失，但是在获取利益的同时，也要兼顾他人的利益。我们更应该把法律作为我们的底线，不能见利忘义。当然，仅仅做到这一点是远远不够的，真正的君子，能够时时刻刻把道德与法纪放在心里，在严格约束自己的同时，也不忘记帮助他人。如果说，不侵犯他人利益是底线的话，那么时时刻刻注重个人修养，助人为乐便是我们应当共同努力而达成的目标了。 “君子成人之美，不成人之恶。小人反是。”君子有一个很重要的品德，就是成人之美。在他人做事情时，君子能够尽己所能予以帮助，当别人的目标达成后，他也会为之感到开心。而小人却是相反，他们处于内心的嫉妒，见不得别人的好，一心想着搞破坏，把别人是失败当作笑柄。他们损人不利己却又乐此不疲。就如宋代的奸臣秦桧，在岳飞在抗击金国的战场上屡立奇功，威名远扬时，他却联合一干奸佞之辈，联合害死了岳飞。这种实例在历史上比比皆是，就连当今也有不少。当别人取得些许成绩时，一些人便难以压抑心中的嫉妒，偏要从中作梗，当把别人的好事搅黄后就沾沾自喜。我们在生活中更应该做成人之美的君子，正所谓“得道多助，失道寡助”，人是社会的生物，我们免不了需要他人的帮助，当别人需要帮助是，我们无动于衷甚至还从中破坏，那么当我们遇到困难后，自然也会举步维艰。当社会上所有人都这样勾心斗角、明争暗斗却没有互助时，这社会也便不会发展。 “君子泰而不骄，小人骄而不泰。”君子之所以能为人所称道，正是因为他们安静泰然而不傲慢，因为真正的实力不是靠嘴说出来的。小人在这方面就远远不及君子了，他们浮躁傲慢，有了一点成就便到处夸耀，似乎想要全世界都知道他们的成就。这种行为是万万不可取的，我们在为人处世的过程中，要时时刻刻保持低调与谦逊。当我们太过张狂时，不仅会遭致他人的反感，过于自负的内心也会把我们引向失败。有句话说得好：“骄兵必败”，在走向成功的过程中，过于骄傲自负，不把他人放在眼里，甚至到处攻击，那离失败便也不远了。三国时期关羽大意失荆州的事例不必多说，因为他的骄傲自负、自以为是，导致荆州失守。就连他这样的一代英豪都付出了如此巨大的代价，作为普通人，我们更不能因为一点小事就沾沾自喜，忘乎所以。沉稳与低调是成功的必要条件，当我们真正地沉下心来，冷静客观地分析时局，并做出相应的努力，我们才能更快地走向成功。正如一句话说的“每临大事有静气，不信今时无古贤。”当我们有一种泰山崩于前而色不变的淡然，才能举重若轻，运筹帷幄，决胜千里。 “君子求诸己，小人求诸人。”君子之所以被人们所尊敬，正是由于他们遇到事情不会推卸责任，而是先从自己身上找问题。与之相比，小人却是从各种客观因素出发为自己找借口，而不是分析自己的错误。日常生活中也经常有这种人，他们自己不求上进，生活窘迫，却时时刻刻在抱怨他人，抱怨社会。他们觉得是别人不赏识自己，是社会不接纳自己。但他们从来没有想过是不是因为他们自己的懒惰或者别的缺点，才让别人对他们敬而远之。而当他们继续抱怨，自然也就没有人愿意帮助他们。当我们遇到问题时，首先应该先想想是不是自己做得不对，而这一点对于每一个普通人来说的确不易。人们经常说，我们总是容易发现别人的问题，而忽略自己的问题，这就需要我们拥有一颗善于自省的心。当我们能够首先找到自己身上的问题时，对别人的批评才能更好地被接受，而我们，也能更好得到别人的尊重。 以上就是我对于《论语》中“君子”与“小人”的一些思考。当然，这并不全面，但是通过这些研究，我们不难看出，“君子”是孔子极力推崇的一种人格，也是我们在生活中想要达到的最理想状态。让我们共同努力，完善自己的品行与修养，不断地接近一位君子。","tags":[{"name":"选修课","slug":"选修课","permalink":"https://renzehua1998.github.io/tags/%E9%80%89%E4%BF%AE%E8%AF%BE/"},{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"汽车构造期末试题","date":"2017-11-18T10:08:00.000Z","path":"2017/11/18/汽车构造/","text":"大一上汽车构造期末考试题（低分存档） 请回答下列问题： 请列出汽车的基本组成部分，并阐述各部分的功用。 常用汽车的总体构造基本上由四部分组成：发动机、底盘、车身、电气设备。 （1） 发动机——发动机是汽车的动力装置。作用是将燃料燃烧的热量转变为机械能，为汽车提供动力。 （2） 底盘——底盘接受发动机动力，使汽车运动，并保证正常行驶。底盘由传动系、行驶系、转向系、制动系组成。 ①传动系：由离合器、变速箱、万向传动装置、驱动桥等组成。作用是将发动机动力传给驱动车轮。 ②行驶系：由车架、车桥、车轮、悬架等组成。作用是布置、安装、连接汽车各总成，起到支持全车保证汽车行驶。 ③转向系：由方向盘、转向器及转向传动装置组成。作用是保证汽车按照驾驶人所定方向行驶。 ④制动系：由制动器，自动传动装置，制动助力辅助装置等组成。作用是行驶中减速、停车。 （3） 车身——用以安置驾驶员、乘客或货物。客车为整体车身，货车分驾驶室和货箱。 （4） 电气设备——为汽车启动、行驶及汽车附属设施提供电源。主要由电源、启动系、点火系，以及汽车照明、信号、辅助电气设施等组成。 请在近3年销售的汽车中选择自己喜欢的一款车型，列出其主要参数。 宝马5系528Li 上市特别版 2018款 基本信息 保修政策： 3年或10万公里 排量[L]： 2.0L 排量： 1998mL 进气形式： 涡轮增压 变速箱类型： 8挡 手自一体 最高车速： 245km/h 车身尺寸 长： 5087mm 宽： 1868mm 高： 1500mm 轴距： 3108mm 整备质量： 1660kg 座位数： 5个 油箱容积： 68L 前轮胎规格： 245/45 R18 后轮胎规格： 245/45 R18 备胎： 无备胎 保修政策： 3年或10万公里 动力系统 排气量： 1998mL 排量[L]： 2.0L 最大功率： 165kW 最大马力： 224Ps 最大功率转速： 5200-6500rpm 最大扭矩： 310N.m 最大扭矩转速： 1400-5000rpm 缸体形式： 直列 气缸： 4缸 进气形式： 涡轮增压 供油方式： 直喷 燃油标号： 95号 发动机启停： ● 变速箱类型： 手自一体 挡位个数： 8 最高车速： 245km/h 0-100km/h加速时间： 7.4s 混合工况油耗： 6.4L/100km 环保标准： 国五 底盘制动 驱动方式： 后轮驱动 前悬架类型： 双叉臂式独立悬架 后悬架类型： 多连杆式独立悬架 可调悬架： - 前轮制动器类型： 通风盘 后轮制动器类型： 通风盘 驻车制动类型： 电子驻车 车体结构： 承载式 限滑差速器/差速锁： - 请列举4种轿车常用的自动变速系统，并阐述其结构特点。 汽车自动变速器常见的有四种型式：分别是液力自动变速器(AT)、机械无级自动变速器(CVT)、电控机械自动变速器(AMT)、双离合器变速器（DSG）。变速器通过改变传动比，改变发动机曲轴的转拒，适应在起步、加速、行驶以及克服各种道路阻碍等不同行驶条件下对驱动车轮牵引力及车速不同要求的需要。通俗上分为手动变速器(MT)，自动变速器(AT)， 手动/自动变速器，无级式变速器。 液力自动变速器(AT)： 应用最广泛的是AT，AT几乎成为自动变速器的代名词。 AT是由液力变扭器、行星齿轮和液压操纵系统组成，通过液力传递和齿轮组合的方式来实现变速变矩。其中液力变扭器是最重要的部件，它由泵轮、涡轮和导轮等构件组成，兼有传递扭矩和离合的作用。 机械无级自动变速器(CVT）: 与AT相比，CVT省去了复杂而又笨重的齿轮组合变速传动，而是两组带轮进行变速传动。通过改变驱动轮与从动轮传动带的接触半径进行变速。由于取消了齿轮传动，因此其传动比可以随意变化，变速更加平顺，没有换挡的突跳感。 电控机械自动变速器(AMT)： AMT和液力自动变速器（AT）一样是有级自动变速器。它在普通手动变速器的基础上，通过加装微电脑控制的电动装置，取代原来由人工操作完成的离合器的分离、接合及变速器的选挡、换挡动作，实现自动换挡。 双离合器变速器（DSG）： DSG变速箱与传统自动变速箱有着明显的区别，DSG从一开始就没有采用液压式扭矩变换器。这款变速器不是在传统概念的自动变速器基础上生产出来的，设计DSG的工程师们走了一条具有革新性的全新技术之路，巧妙地把手动变速器的灵活性和传统自动变速器的方便性结合在一起。 阐述评价汽车燃油经济性的评价方法和主要评价指标，并概述在实际使用过程中5种降低汽车油耗的方法。 汽车的燃油经济性有两种测定法：一是行驶试验法；另一种是在平坦道路上和一定条件下进行等速油耗试验。 世界上评论汽车燃油经济性一般用耗油量或油行程来表示。 耗油量是指汽车满载时单位行驶里程所需燃油体积。我国和欧洲都用行驶百公里消耗的燃油数(L)来表示，即L/ 100 km；油行程是指汽车满载时，单位体积燃油所能行驶的里程，美国就是用每加仑燃油能行驶的里程数来表示，即m ile/gal(英里/加仑)。 前一种表示法，数值越小，燃油经济性越好；后一种表示法，数值越大，燃油经济性越好(换算关系：1加仑=4. 546 L，1英里=1.609 km)。 降低油耗方法： 第一招 养成良好的驾驶习惯 柔和起步，缓慢加速，轻抬油门，换挡及时，减少制动，高挡行车。 第二招 定期为你的爱车瘦身 车子的荷重也是影响油耗的一大因素，所以不必要放的东西就不用常放在车上，不要 把车子当做仓库；另外空滤器的脏油、燃烧室的积碳、消声器是否完好、火花塞是否 正常等都会对油耗产生影响，尽量学会自己排查。 第三招 掌握小技巧用于实际 开车节油节耗油许多小技巧，尽可能多地了解一些，并在日常操作中养成自己的习惯。 比如开窗要比关窗费、轮胎越大越费油、轮胎气压不足也会导致费油等等，在行驶过 程中，注意看温度表，80-90°之间最适宜，过高过低都费油。 第四招 路上因地制宜节油耗 车主在行车路上，在安全的前提下，尽量遵守“时间最短和距离最近”的原则。驾 时可以将车身偏离前车轨道的四分之一，这样可以看到前方情况，及早应变，减少不必要动作，上坡前500米轻微加速，借助惯性冲坡；等红灯时注意观察前车制动灯， 提早准备平顺起步，尽量减少怠速。 第五招 保持良好的驾驶心态 正常情况下，不争速、不抢道，面对其他急躁脾气的车主，心平气和不斗气。要知道， 车辆在起步加速时是最费油的，而频繁的大油门超车并线更是费上加费。切忌争锋斗 气把路面当做赛车道！ 请具体列出汽油发动机和柴油发动机的不同之处（至少10处不同之处）。 （1）吸气冲程 汽油机：吸入的是汽油与空气的混合物 柴油机：只吸入空气 （2）压缩冲程 汽油机：气体体积被压缩为吸进体积的 1/6～1/9 机械能转化为内能 柴油机：气体体积被压缩为吸进体积的 1/6～1/22 机械能转化为内能 （3）燃料不同 汽油机：汽油 柴油机：柴油 （4）构造不同 汽油机：气缸顶部有火花塞 柴油机：气缸顶部有喷油嘴 （5）点火方式 汽油机：压缩冲程末，火花塞产生电火花点燃燃料，称为点燃式 柴油机：压缩冲程末，喷油嘴向气缸内喷进柴油遇温度超过柴油燃点的空气而自动点燃，称为压燃式 （6）转速：大多数情况下，柴油机（不包括农机）3800-4200r/min，汽油机5500-6500r/min。 扭矩：柴油机的扭矩更改一些及马力大、动力足，但由于转速的问题，汽油车的最高时度一般要比柴油车要快 （7）压强不同，效率不同.燃烧方式： 柴油机是压燃式，汽油机为点燃式 2.重量：柴油机一般要比汽油机重（飞轮） （8）经济性：柴油机的经济性更好一些，油耗低。 （9）汽油机震动小、转速高，适用于轿车和轻型车辆，而柴油机功率大，经济性能好，适用于卡车和大型客车。 （10）排放：柴油的排放更好，绿色环保。不过国内柴油的品质真的...真的...很差.... （11）汽油机压缩比过高容易产生爆震。压缩比一般为9-11.5 汽车车灯的正确使用是行车安全的重要保证，请阐述车灯的正确使用方法和使用场合。 行车灯： 行车灯也叫做示宽灯，它的作用是使车辆的四个角为人所见，亮度没有大灯那么高。在雨天、天色昏暗或者在地下停车场时应亮起此灯。行车灯亮起时，仪表盘上会亮起如图所示的标志。 远光灯与近光灯： 远光灯的照射高度比近光灯要高，因此能够照亮更高更远的物体。近光灯一般在有路灯照明的公路上使用。远光灯则在没有灯光照明的公路上使用，也会经常被用于照亮远处公路上方的路牌。 通过不同的变换远近光方式，能够实现与其它司机交流的目的。 在会车时，如果我们使用远光灯，对方驾驶员将由于强光而无法看清路面并无法判断你车辆的准确位置，这将增加意外发生的几率。所以会车时，如开了远光灯，应切换为近光灯。如对方车辆使用了远光灯，你可以通过快速变换远近光来提醒来车的司机。 转向灯： 顾名思义，转向灯是用来表示车辆需要进行转向的。在车辆需要转向的场合必须提前亮起转向灯，在确认后方没有来车时方可转向，切忌打灯后不确认后方情况就马 上转向。在超车前亮左转向灯，确认前方具备超车条件方可超车。后方车辆有超车意图，可以通过亮起右转向灯示意后方车辆超越。在红绿灯前的掉头或转向车道， 除非是排第一，否则没必要一直打开转向灯，在车辆转向时再打转向灯也不晚。 雾灯： 雾灯的穿透力比行车灯要强得多，其功率与大灯相若 ，因此在雾天、暴雨、大雪以及沙尘暴天气时，我们应该把车辆的前后雾灯打开，让其他车辆在更远的地方就能看到你的车子。雾灯的灯光是发散的，射出角度较大，因而有很好的穿透力和辨识度。而近光灯由于射出角度较低，只能照亮近处的路面，如遇上雨、雾、沙尘暴等天气，其穿透力和辨识度比不上雾灯。 双闪灯： 双闪灯又叫“危险警告灯”，在车辆出现紧急状况时应该通过相应的开关开启此灯。车辆抛锚停在路边时，除了要亮起双闪灯还要在车辆后方200m左右的地方设 立三角反光板对后面来车作出警示，避免追尾事故的发生。双闪灯的另一个作用是标识车队中的车辆，让其它车知悉车队将通过。 作为一名普通消费者，在动力性接近的条件下你会选择纯电池电动汽车、混合动力汽车还是传统汽油机汽车？请给出选择的理由。 我会选择混合动力汽车，因为在能源日益紧缺的今天，传统汽油机汽车会为环境带来更多的污染，造成越来越严重的诸如雾霾一类的环境问题。而纯电池电动汽车固然环保，但是造价昂贵，充电时间长，续航里程短，在郊区也面临着无电可充的尴尬。而混合动力汽车同时具备二者的优点，它续航里程长，加油或充电可以灵活选择，较之传统汽油机汽车，它也更加节能环保。虽然比普通汽车略贵，但是由于混合动力汽车耗油量很低，实际使用费用很低，通常在2—3年左右就可以回收购车时多付的钱。此后，其节油性能将给用户带来可观的经济效益。 目前共享经济如雨后春笋般迅速弥漫，像共享单车一样，已有多家汽车分时租赁平台推出，请谈谈你对共享汽车推广和使用的一些看法和见解。 共享汽车手续简便，打个电话或通过网上就可以预约订车。汽车共享一般是通过某个公司来协调车辆，并负责车辆的保险和停放等问题。这种方式不仅可以省钱，而且有助于缓解交通堵塞，以及公路的磨损，减少空气污染，降低对能量的依赖性，发展前景极为广阔。 近年来，我国汽车租赁业呈现快速发展态势，特别是随着移动互联网技术广泛应用和新能源汽车的推广，分时租赁模式（也称汽车共享）在北京、上海、广州、深圳等地兴起。据统计，目前全国有6301家汽车租赁业户，租赁车辆总数约20万辆，市场规模以每年20%左右的速度增长。据了解，目前分时租赁企业40余家，车辆总数超过4万辆，95%以上为新能源车辆。 但总体来看，我国汽车租赁业发展仍处于起步阶段，还存在服务能力不足、法规政策建设滞后、企业经营风险较高、分时租赁新模式发展亟待引导等突出问题，与经济社会发展以及人民群众不断增长的个性化出行需求不相适应。 自动驾驶汽车大幅减少人为因素引起的交通事故，但是在目前自动驾驶汽车与其它汽车共享道路的情况下，车辆事故不可避免。如果出现如下情况： 1）自动驾驶汽车带有一个乘客行驶在两条行车道的路上，此时一个子系统发生了故障。自动驾驶汽车立刻刹车，但同时也已经探测到汽车无法在撞到此车道上５个过马路的行人之前停止。汽车可以在此时换到另一条车道上，如图1所示。但此时车会撞到一个在另一条车道上过马路的行人。假设路人被车撞击后都会受到严重损伤，每一个人死亡的可能性在受撞击后一致。如果你是自动驾驶控制设计师，是否让车转到另一条车道，并阐述理由。 图1 情景1 2）自动驾驶汽车带有一个乘客行驶在两条行车道的路上，此时一个子系统发生了故障。自动驾驶汽车立刻刹车，但同时也已经探测到汽车无法在撞到此车道上５个过马路的行人之前停止。汽车可以在此时换到另一条车道上，如图2所示。但此时车会撞到另一辆迎面驶来的自动驾驶卡车。假设自动驾驶卡车的软件控制设计优先权是保护卡车成员，卡车将不会避让自动驾驶汽车，并导致自动驾驶汽车的乘客严重受伤，而卡车成员不会受伤。假设路人被车撞击后都会受到严重损伤，同时路人和自动驾驶汽车的乘客严重受伤后的死亡的可能性一致。如果你是自动驾驶控制设计师，是否让车转到另一条车道，并阐述理由。 图2 情景2 作为一名普通消费者，选购汽车时你主要关心汽车的哪些技术参数或部件？请依次列出并给出理由。","tags":[{"name":"选修课","slug":"选修课","permalink":"https://renzehua1998.github.io/tags/%E9%80%89%E4%BF%AE%E8%AF%BE/"},{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"Hello World","date":"2017-09-01T01:00:00.000Z","path":"2017/09/01/hello-world/","text":"hexo官方说明文档 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","tags":[]},{"title":"珍惜我们的现在——举手之劳做环保","date":"2015-04-13T13:17:00.000Z","path":"2015/04/13/珍惜我们的现在——举手之劳做环保/","text":"高中自主报告会（科技节凑数的汇报） 在我校第十二届科技节来临之际，我们作了关于“举手之劳做环保”的主题报告会，报告会取得了较好的成果，同时也锻炼了我们的演讲能力。 以下是我们的报告演讲稿： 环保主持稿: 低碳环保 从我做起 亲爱的同学们： 大家好!我是山西省实验中学1402班的马赫 任泽华，今天我们报告会的主题是《举手之劳做环保》! 众所周知，《后天》的场景绝非无中生有，在地球家园的美丽倩影渐行渐远之际，倡导“低碳环保生活”刻不容缓!那什么是低碳环保生活呢?低碳环保生活就是减少二氧化碳排放的低能量、低消耗、低开支的节能减排生活方式。 勿庸置疑，“低碳环保生活”有利于减缓全球气候变暖和环境恶化的速度。减少二氧化碳排放，选择“低碳环保生活”，是每位公民应尽的责任，也是每位公民应尽的义务。那怎样才算低碳环保生活呢?今天，就让我们从小事说起吧! 一、节约一张纸 在场的同学，我相信大家都离不开纸，而且很多同学的草稿纸应该堆成小山头了!知道吗，我国每生产1吨纸就要耗费20棵大树、100立方米水，如果每人每天浪费一张纸，全国就要浪费约2700吨纸、27万吨水，54000棵大树将化为乌有。因此，节约用纸有利于节约能源和保护树木，有利于减少温室气体的排放，有利于保护我们的生态环境。在此，我提倡大家积极回收废纸、不撕作业本，尽量使用双面草稿纸，努力减少纸张消耗。节约一张纸,保护一片林! 二、节约一度电 同学们，家中的电器应该不少吧!而且很多电器随时都处于待机状态吧!电器设备在待机状态下耗电一般为其开机功率的10%左右，家里的电视、空调、音响、电脑、微波炉、饮水机、电热水器等的待机能耗加在一起，相当于开一只30至50瓦的长明灯，照此推算，一户普通人家一年因待机而消耗的能源折合人民币近60元，成都市100多万户居民家庭每年要为待机能耗支付约1亿元。反之，从我做起，取缔无谓的浪费，节约一度电，惠及千万人。 三、节约一升油 同学们，在车水马龙的街头，当一股股蓝色的烟气从一辆辆机动车尾部喷出时;当一阵阵气味怪异，令人头昏、恶心的尾气向我们袭来时，你是否以为躲在自家车子里捏着鼻子就能幸免，就能身体健康?告诉你，生活在城市里，谁也无法全身而退!英国的有关协会曾发表研究报告称，与交通事故遇难者相比，英国每年死于空气污染的人要多出10倍。 节约一升油，减少我们对机动车的依赖，减少我们对空气的污染，近距离出行尽可能使用自行车或者步行，让我们人人都来做公交族，个个争当自行车骑手!节约一升油，净化一片天! 四、分类一袋垃圾 众所周知，我们每个人都是垃圾的制造者，又是垃圾的受害者，但是，我们更应是垃圾公害的治理者，我们每个人都可以通过垃圾分类来战胜垃圾公害。我们的生活垃圾一般可分为四大类：可回收垃圾、厨余垃圾、有害垃圾和其他垃圾。 一袋垃圾，如不分类处理，或浪费资源或“遗臭万年”;反之，分类清运和回收，使之重新变成资源。只需我们的举手之劳，就能创造一个无垃圾的社会，一个使资源循环再生的社会。分类一袋垃圾，创造再生传奇。 同学们，低碳环保生活并不是我们多喊几句口号就可以实现的，它需要我们真正的从实际生活中去改善，去实践;让我们共同携手，从节约一张纸、节约一度电，节约一升油，分类一袋垃圾做起;让我们从身边的小事一点一滴做起，为保护美好的家园而努力! 谢谢大家! 本次报告会，我们紧紧围绕“污染”与“环保”，向大家进行了展示与讲解。最令我们印象深刻的一句话是：“难道只有用橡皮擦才能还原天空的颜色？”它深刻地道出了人类此刻的处境。我们配合图片与文字、视频的展示，让大家了解困扰我们人类的几大环境问题：垃圾围城、雾霾、原油污染、水污染、全球气候变暖等等，通过一系列数据的展示与讲解，让大家明白环境问题已严重威胁到我们的生存。 接下来，我们介绍了世界上几次重大污染事件，并展示了我国的环境现状。同时，我们展示了环境问题对我们日常生活所造成的影响，让大家看到不仅仅是工农业污染，我们在日常生活中的许多行为也会对环境带来严重的危害。包括生活垃圾、生活污水、废旧电池、露天烧烤等等对环境的不良影响。从而引出在生活中我们应当关心环境。 那么，我们具体应当如何做呢？我们向大家展示了日常生活中的一些节能环保的方法，包括节水、节点、绿色出行等等，并且介绍了这么做的巨大意义。我们通过提问的方式向大家征集了许多同学们日常生活中的环保小方法，并向大家介绍了许多环保的小知识，如不用一次性筷子、少用发胶等等日常生活中的“小事”。这虽然是小事，但它们的意义却是非凡的，如果人人都这么做了，我们的环境就不会恶化得如此严重。 最后，我们进行了环保知识的竞赛，通过比赛的方式让同学们更加了解环保的意义与如何进行环保活动，取得了较好的效果。 这次报告会让同学们认识到保护环境刻不容缓，我们应当爱护赖以生存的家园。 山西省实验中学 1402班 任泽华 马赫 2015年4月2日","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"高中瞎写的诗文","date":"2011-03-30T11:45:00.000Z","path":"2011/03/30/高中瞎写的诗文/","text":"高中瞎写的诗文 春日赋 噫！春光无限！天日渐长，大地渐苍。春寒料峭，夜半梦回微寒；青阳温润，清晨出户自暖。清明时节雨，万物皆复苏。山间溪畔，游人踏青如织；田间旷野，纸鸢飞舞曼妙。漫天飞舞皆香絮，弥散人间尽芳华。 春光无限，万物同欣。童稚欢笑追逐，垂髫携手共游。云淡风轻，天高日远。吞春日之气，吐愉悦之情。溪水鸣声潺潺，清风扶柳芊芊。登高望远，满目苍翠尽生气；百花齐放，入眼锦簇满丰腴。绰约芳草，菲菲红素，满载人间春色；群山如黛，绿水轻淌，不禁回忆童真！瑶芳轻摆显高贵，琼苞载露欲喷薄。玉叶苍翠，花友妖艳，好一派阳春美景!雀鸟枝头喧嚣，蝴蝶花间嬉闹。如此春光无限妙，怎一个好字了的？ 沐天地之灵，吐万物之气，容日月之华，享三春美景！噫！吾尝十年寒窗，未曾领造化之功；尝披肝沥胆，不知享万物华光！人于造化，所生之情唯有敬畏！我于造化所产之感唯有回归！青春年华，如早春之景，如日出之阳，如琼苞欲放。嗟乎！吾中华少年，未有此情此景也久矣。少年之日，需悟天地之道，感万物之情。娇生惯养，非成才之道也；不逢造化，不知年华易逝也。昔车胤囊萤，孙康映雪，此皆有恒心，有毅力者，所以成者，皆惜时而勤勉于己也。 吾华夏之少年，需惜时而勤奋。昔启超先生曾言：“少年强则国强”，少而好学，如日出之阳，唯有感于物而发于心，方能勤于律己。感春日之意，方知韶华易逝，青春易改。唯紧握青春年华，方能创天地之造化！吾与诸君共勉！ 创作说明及背景：在学校举办的古风新韵大会上所作，用于和友人共勉，共同进步。 春日赠友 乍暖还寒二月光，春雨如油沁芬芳。 绿意初现遥可见，青芽微吐韶光长。 莺啼婉转忙奔波，燕飞婀娜急筑巢。 年华易逝花月少，莫负早春好时光。 劝君莫贪青阳好，青春年少当奋强！ 清平乐 寻春 春何辉宏？百思终不懂。忽逢青葱与花红，方觉春意渐浓。 翠叶掩映瑶芳，十里临江开遍。韶光易逝难回，珍惜切莫相忘。 创作说明及背景：在学校举办的诗词大会上所作，用于和友人共勉，共同进步。 备注：《清平乐 寻春》借鉴了黄庭坚的《清平乐 春归何处》","tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://renzehua1998.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"博客大事记","date":"2010-12-31T16:00:00.000Z","path":"2011/01/01/博客大事记/","text":"博客大事记 2022年5月30日 在GitHub Pages通过hexo建站。 2022年8月31日 加入十年之约，网站主页点击这里。 资源链接 资源名 资源描述 资源分类 资源链接 开发经验分享 前端开发的粗浅分享以及一些git使用分享 slidev 国内 境外 新港生物图鉴 在港村生活过程中记录的动植物照片图鉴 仓库、slidev GitHub 国内 境外 超图分享课件 XJTU高级图论课程资源 slidev 视频 国内 境外 JS小游戏 使用JavaScript练手的各种同年小游戏（更新中） 仓库 GitHub Gitee magnificent 本博客使用的主题，在smackdown的基础上魔改 仓库 GitHub Gitee video2lcd 将视频取模的Python3源代码，大三实验魔改 仓库 GitHub Gitee NSSA-ST INFOCOM demo演示与论文链接 网页 demo 论文 hyperlap www21论文算法复现、改进与对比 仓库 视频 GitHub free-GPT-UI 基于GPT-API开发的前端页面（已存档） 仓库、网页 GitHub Gitee 网页 fill_docx 基于excel数据批量自动填充word文档的小工具 仓库 视频 GitHub Gitee","tags":[]}]